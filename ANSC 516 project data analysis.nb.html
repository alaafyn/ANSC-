<!DOCTYPE html>

<html>

<head>
# Alpha Diversity
library(ggplot2)
library(dplyr)
library(tidyverse)
library(qiime2R)
library(ggpubr)


# Read timemeta
timemeta <- read_q2metadata("project_metadata.txt")

# Filter timemeta for each time point
timemeta_time1 <- timemeta %>% filter(`time-point` == "Day15")
timemeta_time2 <- timemeta %>% filter(`time-point` == "Day22")

# Read alpha diversity data
evenness <- read_qza("evenness_vector.qza")$data %>% rownames_to_column("SampleID")
observed_features <- read_qza("observed_features_vector.qza")$data %>% rownames_to_column("SampleID")
shannon <- read_qza("shannon_vector.qza")$data %>% rownames_to_column("SampleID")
faith_pd <- read_qza("faith_pd_vector.qza")$data %>% rownames_to_column("SampleID")

# Filter alpha diversity data for each time point
evenness_time1 <- evenness %>% filter(SampleID %in% timemeta_time1$SampleID)
evenness_time2 <- evenness %>% filter(SampleID %in% timemeta_time2$SampleID)

observed_features_time1 <- observed_features %>% filter(SampleID %in% timemeta_time1$SampleID)
observed_features_time2 <- observed_features %>% filter(SampleID %in% timemeta_time2$SampleID)

shannon_time1 <- shannon %>% filter(SampleID %in% timemeta_time1$SampleID)
shannon_time2 <- shannon %>% filter(SampleID %in% timemeta_time2$SampleID)



faith_pd <- read_qza("faith_pd_vector.qza")
faith_pd<-faith_pd$data %>% rownames_to_column("SampleID")
faith_pd <- faith_pd[,-1]
colnames(faith_pd) <- c('SampleID', 'faith_pd')

faith_pd_time1 <- faith_pd %>% filter(SampleID %in% timemeta_time1$SampleID)
faith_pd_time2 <- faith_pd %>% filter(SampleID %in% timemeta_time2$SampleID)

# Now you can perform alpha diversity analysis separately for each time point
# For example, you can calculate means, perform statistical tests, or create plots for each time point

# Example: Mean alpha diversity for each time point
mean_evenness_time1 <- mean(evenness_time1$pielou_evenness)
mean_evenness_time2 <- mean(evenness_time2$pielou_evenness)

mean_observed_features_time1 <- mean(observed_features_time1$observed_features)
mean_observed_features_time2 <- mean(observed_features_time2$observed_features)

mean_shannon_time1 <- mean(shannon_time1$shannon_entropy)
mean_shannon_time2 <- mean(shannon_time2$shannon_entropy)

mean_faith_pd_time1 <- mean(faith_pd_time1$faith_pd)
mean_faith_pd_time2 <- mean(faith_pd_time2$faith_pd)

# Then you can perform statistical tests or create plots based on these means

# Assuming evenness, observed_features, shannon, and faith_pd have been filtered for each time point as shown in your code.

# Combine alpha diversity metrics into a single dataframe for each time point.
alpha_diversity_time1 <- reduce(list(faith_pd_time1, evenness_time1, observed_features_time1, shannon_time1), full_join, by = "SampleID")
alpha_diversity_time2 <- reduce(list(faith_pd_time2, evenness_time2, observed_features_time2, shannon_time2), full_join, by = "SampleID")

# Ensure all relevant metric names are correct and consistent across dataframes before merging.

# Merge combined alpha diversity data with the corresponding time-specific metadata.
metadata_time1 <- merge(timemeta_time1, alpha_diversity_time1, by = "SampleID")
metadata_time2 <- merge(timemeta_time2, alpha_diversity_time2, by = "SampleID")

# Now, metadata_time1 and metadata_time2 contain all the relevant information for each time point.

# Example analysis: Calculating mean alpha diversity metrics for each time point
# You've already done this. You can further perform statistical tests or generate plots for each time point separately.


# Plotting Faith PD for time 1)
ggplot(metadata_time1, aes(x = treatment, y = faith_pd)) +
  geom_boxplot() +
  labs(title = "Faith PD by Treatment for Day 15", x = "Treatment", y = "Faith PD") +
  theme_minimal()

# Create directory to store the plots
dir.create("alpha_diversity_plots", showWarnings = FALSE)

# Combine both time-point plots into a facet with color
combined_plot <- ggplot(mapping = aes(x = treatment, y = faith_pd, fill = treatment)) +
  geom_boxplot(data = metadata_time1, alpha = 0.7) +
  geom_boxplot(data = metadata_time2, alpha = 0.7) +
  labs(title = "Faith PD by Treatment", x = "Treatment", y = "Faith PD") +
  theme_minimal() +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#009E73", "#F0E442"), name = "Treatment") +
  facet_wrap(~`time-point`)+
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
plot.background = element_rect(fill = "white"))

# Print the combined facet plot
print(combined_plot)
# Save the plot to a specific path
pathFPD <- "alpha_diversity_plots/FaithPD_plot.png"
ggsave(filename = pathFPD, plot = combined_plot, width = 10, height = 5)



# Shapiro-Wilk test for normality
shapiro.test(metadata_time1$faith_pd)  #normal
shapiro.test(metadata_time2$faith_pd) #not normal


#ANOVA and Kruskal Walis
aovfpd <- aov(faith_pd ~ treatment, data = metadata_time1)
summary(aovfpd)
kruskal.fp <- kruskal.test(faith_pd~ treatment, data = metadata_time2)
kruskal_p_value <- kruskal.fp$p.value

#the above are recorded in mean, so we have to get rid of boxplot
#and use mean bar

# Plot Faith PD with standard errors for time1
meanfpd <- metadata_time1 %>%
  group_by(treatment) %>%
  summarise(mean_faith_pd = mean(faith_pd),
            sd_faith_pd = sd(faith_pd),
            n = n(),
            se_faith_pd = sd_faith_pd / sqrt(n))


# Create plot for Faith PD
fpd_plot <- ggplot(meanfpd, aes(x = treatment, y = mean_faith_pd, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_faith_pd - se_faith_pd, ymax = mean_faith_pd + se_faith_pd), width = 0.2) +
  labs(y = "Mean Faith PD", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

fpd_plot
ggsave("Mean_Faith_PD_Day15.png", fpd_plot, path = "alpha_diversity_plots")


# Plot Faith PD with standard errors for time2
meanfpd2 <- metadata_time2 %>%
  group_by(treatment) %>%
  summarise(mean_faith_pd2 = mean(faith_pd),
            sd_faith_pd2 = sd(faith_pd),
            n = n(),
            se_faith_pd2 = sd_faith_pd2 / sqrt(n))

# Create plot for Faith PD
fpd_plot2 <- ggplot(meanfpd2, aes(x = treatment, y = mean_faith_pd2, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_faith_pd2 - se_faith_pd2, ymax = mean_faith_pd2 + se_faith_pd2), width = 0.2) +
  labs(y = "Mean Faith PD", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

print(fpd_plot2)
ggsave("Mean_Faith_PD_Day22.png", fpd_plot2, path = "alpha_diversity_plots")

#combining the two
# Add a 'time_point' column to each data frame
meanfpd$time_point <- "Day 15"
meanfpd2$time_point <- "Day 22"

#find column names
colnames(meanfpd)
colnames(meanfpd2)
colnames(meanfpd2) <- c("treatment", "mean_faith_pd", "sd_faith_pd", "n",
                       "se_faith_pd", "time_point")

# Combine the data frames
fpdcomb_data <- rbind(meanfpd, meanfpd2)

# Define custom colors for treatments
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")


# Create the plot
fpdcomb_plots <- ggplot(fpdcomb_data, aes(x = treatment, y = mean_faith_pd, fill = treatment)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = mean_faith_pd - se_faith_pd, ymax = mean_faith_pd + se_faith_pd), width = 0.2) +
  labs(title = "Faith Phylodiversity ", x = "Treatment", y = "Faith PD") +
  scale_fill_manual(values = custom_colors, name = "Treatment") +
  facet_wrap(~time_point, scales = "free_y") +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))
print(fpdcomb_plots)
ggsave("Mean_FithPD_Combined.png", fpdcomb_plots, path = "alpha_diversity_plots", width = 10, height = 5)




#####shannon#####
shannon_plot <- ggplot(mapping = aes(x = treatment, y = shannon_entropy, fill = treatment)) +
  geom_boxplot(data = metadata_time1, alpha = 0.7) +
  geom_boxplot(data = metadata_time2, alpha = 0.7) +
  labs(title = "Shannon Diversity Index", x = "Treatment", y = "Shannon Index") +
  theme_minimal() +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#009E73", "#F0E442"), name = "Treatment") +
  facet_wrap(~`time-point`)+
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))

# Print the combined facet plot
print(shannon_plot)

# Save the plot to a specific path
pathsh <- "alpha_diversity_plots/Shannon_plot.png"
ggsave(filename = pathsh, plot = shannon_plot, width = 10, height = 5)


# Shapiro-Wilk test for normality
shapiro.test(metadata_time1$shannon_entropy)  #not  normal
shapiro.test(metadata_time2$shannon_entropy) #not normal

# Kruskal-Wallis test for shannon_entropy
kruskal.test(shannon_entropy ~ treatment, data = metadata_time1)
kruskal.test(shannon_entropy ~ treatment, data = metadata_time2)

# Plot Shannon Entropy with standard errors for time1
shannonn<- metadata_time1 %>%
  group_by(treatment) %>%
  summarise(mean_shannon_entropy = mean(shannon_entropy),
            sd_shannon_entropy = sd(shannon_entropy),
            n = n(),
            se_shannon_entropy = sd_shannon_entropy / sqrt(n))

# Create plot for Shannon Entropy
shannon_plot2 <- ggplot(shannonn, aes(x = treatment, y = mean_shannon_entropy, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_shannon_entropy - se_shannon_entropy, ymax = mean_shannon_entropy + se_shannon_entropy), width = 0.2) +
  labs(y = "Mean Shannon Entropy", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

print(shannon_plot2)
ggsave("Mean_Shannon_Entropy_Day15.png", shannon_plot2, path = "alpha_diversity_plots")

# Plot Shannon Entropy with standard errors for time2
shannonn2 <- metadata_time2 %>%
  group_by(treatment) %>%
  summarise(mean_shannon_entropy2 = mean(shannon_entropy),
            sd_shannon_entropy2 = sd(shannon_entropy),
            n = n(),
            se_shannon_entropy2 = sd_shannon_entropy2 / sqrt(n))

# Create plot for Shannon Entropy
shannon_plot2 <- ggplot(shannonn2, aes(x = treatment, y = mean_shannon_entropy2, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_shannon_entropy2 - se_shannon_entropy2, ymax = mean_shannon_entropy2 + se_shannon_entropy2), width = 0.2) +
  labs(y = "Mean Shannon Entropy D22", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

print(shannon_plot2)
ggsave("Mean_Shannon_Entropy_Day22.png", shannon_plot2, path = "alpha_diversity_plots")

#combining the two
# Add a 'time_point' column to each data frame
shannonn$time_point <- "Day 15"
shannonn2$time_point <- "Day 22"


colnames(shannonn)
colnames(shannonn2)
colnames(shannonn2) <- c("treatment", "mean_shannon_entropy", "sd_shannon_entropy",
                         "n", "se_shannon_entropy" , "time_point")

# Combine the data frames
Shacomb_data <- rbind(shannonn, shannonn2)

# Define custom colors for treatments
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")

# Create the plot
Shacomb_plots <- ggplot(Shacomb_data, aes(x = treatment, y = mean_shannon_entropy, fill = treatment)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = mean_shannon_entropy - se_shannon_entropy, ymax = mean_shannon_entropy + se_shannon_entropy), width = 0.2) +
  labs(title = "Shannon Diversity Index", x = "Treatment", y = "Shannon Index") +
  scale_fill_manual(values = custom_colors, name = "Treatment") +
  facet_wrap(~time_point, scales = "free_y") +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))
print(Shacomb_plots)
ggsave("Mean_Shannon_Combined.png", Shacomb_plots, path = "alpha_diversity_plots", width = 10, height = 5)


#EVENNESS

Eveness_plot <- ggplot(mapping = aes(x = treatment, y = pielou_evenness, fill = treatment)) +
  geom_boxplot(data = metadata_time1, alpha = 0.7) +
  geom_boxplot(data = metadata_time2, alpha = 0.7) +
  labs(title = "Pielou Evenness Index", x = "Treatment", y = "Pielou Evenness") +
  theme_minimal() +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#009E73", "#F0E442"), name = "Treatment") +
  facet_wrap(~`time-point`)+
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))

print(Eveness_plot)
path <- "alpha_diversity_plots/Eveness.png"
ggsave(filename = path, plot = Eveness_plot, width = 10, height = 5)

# Shapiro-Wilk test for normality
shapiro.test(metadata_time1$pielou_evenness) #normal
shapiro.test(metadata_time2$pielou_evenness) #not normal

#ANOVA and Kruskal Walis
aoveveness <- aov(pielou_evenness ~ treatment, data = metadata_time1)
summary(aoveveness)
kruskal.test(pielou_evenness ~ treatment, data = metadata_time2)


# Plot Shannon Entropy with standard errors for time1
pielou<- metadata_time1 %>%
  group_by(treatment) %>%
  summarise(mean_pielou= mean(pielou_evenness),
            sd_pielou = sd(pielou_evenness),
            n = n(),
            se_pielou = sd_pielou / sqrt(n))

# Create plot for pielou_evenness
pielou_plot <- ggplot(pielou, aes(x = treatment, y = mean_pielou, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_pielou - se_pielou, ymax = mean_pielou + se_pielou), width = 0.2) +
  labs(y = "Mean Pielou Evenness", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

print(pielou_plot)
ggsave("Mean_pielou_plot_Day15.png", pielou_plot, path = "alpha_diversity_plots")

# Plot Shannon Entropy with standard errors for time2
pielou2<- metadata_time2 %>%
  group_by(treatment) %>%
  summarise(mean_pielou2= mean(pielou_evenness),
            sd_pielou2 = sd(pielou_evenness),
            n = n(),
            se_pielou2 = sd_pielou2 / sqrt(n))

# Create plot for pielou_evenness
pielou_plot2 <- ggplot(pielou2, aes(x = treatment, y = mean_pielou2, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_pielou2 - se_pielou2, ymax = mean_pielou2 + se_pielou2), width = 0.2) +
  labs(y = "Mean Pielou Evenness", x = "Treatment") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA),
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        legend.title = element_blank())

print(pielou_plot2)
ggsave("Mean_pielou_plot_Day22.png", pielou_plot2, path = "alpha_diversity_plots")

#combining the two
pielou$time_point <- "Day 15"
pielou2$time_point <- "Day 22"


colnames(pielou)
colnames(pielou2)
colnames(pielou2) <- c("treatment", "mean_pielou", "sd_pielou", "n", "se_pielou" ,
                          "time_point")

# Combine the data frames
piecomb_data <- rbind(pielou, pielou2)

# Define custom colors for treatments
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")

# Create the plot
piecomb_plots <- ggplot(piecomb_data, aes(x = treatment, y = mean_pielou, fill = treatment)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = mean_pielou - se_pielou, ymax = mean_pielou + se_pielou), width = 0.2) +
  labs(title = "Pielou Evenness", x = "Treatment", y = "Pielou Evenness") +
  scale_fill_manual(values = custom_colors, name = "Treatment") +
  facet_wrap(~time_point, scales = "free_y") +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))
print(piecomb_plots)
ggsave("mean Pielou Evenness.png", piecomb_plots, path = "alpha_diversity_plots", width = 10, height = 5)




#observed features#####
obs_plot <- ggplot(mapping = aes(x = treatment, y = observed_features, fill = treatment)) +
  geom_boxplot(data = metadata_time1, alpha = 0.7) +
  geom_boxplot(data = metadata_time2, alpha = 0.7) +
  labs(title = "Observed features", x = "Treatment", y = "Observed Features") +
  theme_minimal() +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#009E73", "#F0E442"), name = "Treatment") +
  facet_wrap(~`time-point`)+
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))

print(obs_plot)
path <- "alpha_diversity_plots/observed_features.png"
ggsave(filename = path, plot = obs_plot, width = 10, height = 5)

# Shapiro-Wilk test for normality
shapiro.test(metadata_time1$observed_features) #normal
shapiro.test(metadata_time2$observed_features) #normal


#if its normal and categorical, use ANOVA.
aov.observed_features.time1 <- aov(observed_features ~ treatment, data = metadata_time1)
summary(aov.observed_features.time1)

aov.observed_features.time2 <- aov(observed_features ~ `treatment`, data = metadata_time2)
summary(aov.observed_features.time2)

#ANOVA USE MEAN, BOXPLOT USES MEDIAN, SO WE NEED TO FIND MEAN DATA TO TALLY WITH OUR ANOVA
# Plot Observed Features with standard errors
obs_features <- metadata_time1 %>%
  group_by(treatment) %>%
  summarise(mean_obs_features = mean(observed_features),
            sd_obs_features = sd(observed_features),
            n = n(),
            se_obs_features = sd_obs_features / sqrt(n))
obs_features 
# Define custom colors for the treatments (assuming 4 treatments as per previous context)
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")

obs_features_se <- ggplot(obs_features, aes(x = treatment, y = mean_obs_features, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_obs_features - se_obs_features, ymax = mean_obs_features + se_obs_features), width = 0.2) +
  scale_fill_manual(values = custom_colors) +
  labs(y = "Mean Observed Features", x = "Treatment") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA), # White background
        panel.border = element_rect(colour = "black", fill=NA, size=1), # Black border around each plot
        legend.title = element_blank())

print(obs_features_se)
ggsave("Mean Observe features_day15.png", obs_features_se, path = "alpha_diversity_plots") 


# Plot Observed Features with standard errors
obs_features2 <- metadata_time2 %>%
  group_by(treatment) %>%
  summarise(mean_obs_features2 = mean(observed_features),
            sd_obs_features2 = sd(metadata_time2$observed_features),
            n = n(),
            se_obs_features2 = sd_obs_features2 / sqrt(n))
obs_features2 
# Define custom colors for the treatments (assuming 4 treatments as per previous context)
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")

obs_features_se2 <- ggplot(obs_features2, aes(x = treatment, y = mean_obs_features2, fill = treatment)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean_obs_features2 - se_obs_features2, ymax = mean_obs_features2 + se_obs_features2), width = 0.2) +
  scale_fill_manual(values = custom_colors) +
  labs(y = "Mean Observed FeaturesD22", x = "Treatment") +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        plot.background = element_rect(fill = "white", colour = NA), # White background
        panel.border = element_rect(colour = "black", fill=NA, size=1), # Black border around each plot
        legend.title = element_blank())

print(obs_features_se2)
ggsave("Mean Observe features_day22.png", obs_features_se2, path = "alpha_diversity_plots") 

#combining the two
# Add a 'time_point' column to each data frame
obs_features$time_point <- "Day 15"
obs_features2$time_point <- "Day 22"


colnames(obs_features)
colnames(obs_features2)

# Rename columns in obs_features2 to match obs_features
colnames(obs_features2) <- c("treatment", "mean_obs_features", "sd_obs_features", "n", "se_obs_features", "time_point")

# Combine the data frames
combined_data <- rbind(obs_features, obs_features2)

# Define custom colors for treatments
custom_colors <- c("#0072B2", "#D55E00", "#009E73", "#F0E442")

# Create the plot
observe_plots <- ggplot(combined_data, aes(x = treatment, y = mean_obs_features, fill = treatment)) +
  geom_col(alpha = 0.7) +
  geom_errorbar(aes(ymin = mean_obs_features - se_obs_features, ymax = mean_obs_features + se_obs_features), width = 0.2) +
  labs(title = "Observed Features", x = "Treatment", y = "Mean Observed Features") +
  scale_fill_manual(values = custom_colors, name = "Treatment") +
  facet_wrap(~time_point, scales = "free_y") +
  theme_minimal() +
  theme(panel.border = element_rect(color = "black", fill = NA),
        strip.background = element_blank(),
        panel.spacing = unit(1, "lines"),
        plot.background = element_rect(fill = "white"))
print(observe_plots)
ggsave("Mean_Observed_Features_Combined.png", observe_plots, path = "alpha_diversity_plots", width = 10, height = 5)





#Combining all boxplots
library(ggpubr)
figure <- ggarrange(combined_plot, shannon_plot, obs_plot, 
                    Eveness_plot,
                    labels = c("A", "B", "C", "D"),common.legend = TRUE,
                    legend = "bottom", ncol = 2, nrow = 2)
figure
path <- "alpha_diversity_plots/alpha diversity.png"
ggsave(filename = path, plot = figure, width = 10, height = 5)

#Combining all bar plots
figure2 <- ggarrange(observe_plots, piecomb_plots, Shacomb_plots, 
                     fpdcomb_plots,
                    labels = c("A", "B", "C", "D"),common.legend = TRUE,
                    legend = "bottom", ncol = 2, nrow = 2)
figure2
path2 <- "alpha_diversity_plots/alpha diversity2.png"
ggsave(filename = path2, plot = figure2, width = 10, height = 5)

# Combine all plots into a single picture
#library(cowplot)
#combined_plots <- plot_grid(combined_plot, shannon_plot,Eveness_plot,
                           # Eveness_plot, nrow = 3, rel_heights = c(2, 2, 2))
#print(combined_plots)
# saving the plot as png  
#ggsave("Faith PD.png", combined_plot, path = "alpha_diversity_plots") 
`

  
  #BETA DIVERSITY  
library(tidyverse)
library(vegan)
library(qiime2R)

metadata2 &lt;- read.delim(&quot;project_metadata.txt&quot;, sep = &quot;\t&quot;, header = T, quote = &quot;&quot;, stringsAsFactors = F)
metadata2[1,]
metadata2[,1]
# When subsetting, the first number is the row and after the comma is the column
metadata2 &lt;- metadata2[-1,]
str(metadata2)
#Now the qiime2R method
metadata&lt;-read_q2metadata(&quot;project_metadata.txt&quot;)
str(metadata)
levels(metadata$`body-site`)
colnames(metadata)[2] &lt;- &quot;time-point&quot;
colnames(metadata)[6] &lt;- &quot;treatment&quot;
str(metadata)

row.names(metadata) &lt;- metadata[,1]
row.names(metadata) &lt;- metadata$SampleID
#metadata &lt;- metadata[,-1]
row.names(metadata)

bc_PCoA&lt;-read_qza(&quot;bray_curtis_pcoa_results.qza&quot;)

trt_colors &lt;- c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;)

#Bray-Curtis
bc_meta &lt;- bc_PCoA$data$Vectors %&gt;%
  select(SampleID, PC1, PC2, PC3) %&gt;%
  inner_join(metadata, by = c(&quot;SampleID&quot; = &quot;SampleID&quot;))

# Now we are going to make an ordination plot
ggplot(bc_meta, aes(x=PC1, y=PC2, color=treatment)) +
  geom_point() + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  xlab(&quot;PC1 (32.27%)&quot;) +
  ylab(&quot;PC2 (22.28%)&quot;) +
  scale_color_manual(values=c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;), name = &quot;Treatment&quot;)

# Now we are going to make our code a little more re-usable
my_column &lt;- &quot;treatment&quot;

ggplot(bc_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point() + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  facet_grid(~`time-point`) +
  xlab(paste0(&quot;PC1 (&quot;, round(100*bc_PCoA$data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*bc_PCoA$data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  scale_color_manual(values=trt_colors, name = my_column)

#apply centroids

centroids &lt;- aggregate(cbind(PC1,PC2)~get(my_column),bc_meta,mean)
colnames(centroids)[1] &lt;- &quot;treatment&quot;

pbray &lt;- ggplot(bc_meta, aes(x = PC1, y = PC2, color = get(my_column))) +
  geom_point(alpha = 0.6, size = 2) +  # Points with transparency
  stat_ellipse(type = &quot;t&quot;, level = 0.95) +  # Statistical ellipse, 95% confidence
  geom_text(data = centroids, aes(label = treatment, x = PC1, y = PC2), vjust = -1, hjust = -0.1) +  # Add centroids labels
  scale_color_manual(values = trt_colors, name = my_column) +
  facet_grid(~`time-point`) +  # Facet by time point
  xlab(paste0(&quot;PC1 (&quot;, round(100 * bc_PCoA$data$ProportionExplained[1], 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100 * bc_PCoA$data$ProportionExplained[2], 2), &quot;%)&quot;)) +
  theme_q2r() +  # Custom theme
  labs(title = &quot;Bray-Curtis Beta Diversity&quot;,  # Setting the title
       subtitle = &quot;Analysis by treatment and time points&quot;)+
  theme(
    plot.title = element_text(size = 16),  # Increase title font size
    plot.subtitle = element_text(size = 16),  # Increase subtitle font size
    axis.title = element_text(size = 15),  # Increase axis titles font size
    axis.text.x = element_text(size = 14),  # Increase x axis text font size
    axis.text.y = element_text(size = 14),  # Increase y axis text font size
    legend.title = element_text(size = 14),  # Increase legend title font size
    legend.text = element_text(size = 12) )  # Increase legend text font size
pbray
ggsave(&quot;./alpha_diversity_plots/pbray.png&quot;, height = 7, width = 10)

bc_dist_mat&lt;-read_qza(&quot;bray_curtis_distance_matrix.qza&quot;)
bc_dm &lt;- as.matrix(bc_dist_mat$data) 
rownames(bc_dm) == metadata$SampleID ## all these values need to be &quot;TRUE&quot;
metadata_sub &lt;- metadata[match(rownames(bc_dm),metadata$SampleID),]
rownames(bc_dm) == metadata_sub$SampleID ## all these values need to be &quot;TRUE&quot;

PERMANOVA_out &lt;- adonis2(bc_dm ~ treatment, data = metadata_sub)
PERMANOVA_out 
PERMANOVAbraytime &lt;- adonis2(bc_dm ~ `time-point`, data = metadata_sub)
PERMANOVAbraytime

######################################################################################
##  Pairwise adonis function
##  we can also perform a pairwise comparison with the function 
##  Pairwise Adonis function by edro Martinez Arbizu &amp; Sylvain Monteux
##  https://github.com/pmartinezarbizu/pairwiseAdonis/blob/master/pairwiseAdonis/R/pairwise.adonis.R
#######################################################################################

pairwise.adonis2 &lt;- function(x, data, strata = NULL, nperm=999, ... ) {
  
  #describe parent call function 
  ststri &lt;- ifelse(is.null(strata),&#39;Null&#39;,strata)
  fostri &lt;- as.character(x)
  #list to store results
  
  #copy model formula
  x1 &lt;- x
  # extract left hand side of formula
  lhs &lt;- x1[[2]]
  # extract factors on right hand side of formula 
  rhs &lt;- x1[[3]]
  # create model.frame matrix  
  x1[[2]] &lt;- NULL   
  rhs.frame &lt;- model.frame(x1, data, drop.unused.levels = TRUE) 
  
  # create unique pairwise combination of factors 
  co &lt;- combn(unique(as.character(rhs.frame[,1])),2)
  
  # create names vector   
  nameres &lt;- c(&#39;parent_call&#39;)
  for (elem in 1:ncol(co)){
    nameres &lt;- c(nameres,paste(co[1,elem],co[2,elem],sep=&#39;_vs_&#39;))
  }
  #create results list  
  res &lt;- vector(mode=&quot;list&quot;, length=length(nameres))
  names(res) &lt;- nameres
  
  #add parent call to res 
  res[&#39;parent_call&#39;] &lt;- list(paste(fostri[2],fostri[1],fostri[3],&#39;, strata =&#39;,ststri, &#39;, permutations&#39;,nperm ))
  
  
  #start iteration trough pairwise combination of factors  
  for(elem in 1:ncol(co)){
    
    #reduce model elements  
    if(inherits(eval(lhs),&#39;dist&#39;)){ 
      xred &lt;- as.dist(as.matrix(eval(lhs))[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),
                                           rhs.frame[,1] %in% c(co[1,elem],co[2,elem])])
    }else{
      xred &lt;- eval(lhs)[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]
    }
    
    mdat1 &lt;-  data[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),] 
    
    # redefine formula
    if(length(rhs) == 1){
      xnew &lt;- as.formula(paste(&#39;xred&#39;,as.character(rhs),sep=&#39;~&#39;))   
    }else{
      xnew &lt;- as.formula(paste(&#39;xred&#39; , 
                               paste(rhs[-1],collapse= as.character(rhs[1])),
                               sep=&#39;~&#39;))}
    
    #pass new formula to adonis
    if(is.null(strata)){
      ad &lt;- adonis2(xnew,data=mdat1, ... )
    }else{
      perm &lt;- how(nperm = nperm)
      setBlocks(perm) &lt;- with(mdat1, mdat1[,ststri])
      ad &lt;- adonis2(xnew,data=mdat1,permutations = perm, ... )}
    
    res[nameres[elem+1]] &lt;- list(ad[1:5])
  }
  #names(res) &lt;- names  
  class(res) &lt;- c(&quot;pwadstrata&quot;, &quot;list&quot;)
  return(res)
} 

trt_Pair &lt;- pairwise.adonis2(bc_dm ~ treatment, data = metadata_sub)
trt_Pair
write.table(trt_Pair,&quot;./alpha_diversity_plots/BrayCurtis_Adonis_pairwise.csv&quot;,sep=&quot;,&quot;, row.names = TRUE) 

##########################################################################################################################################################################

##weighted UniFrac
wUF_PCOA &lt;- read_qza(&quot;weighted_unifrac_pcoa_results.qza&quot;)
Wuni_meta &lt;- wUF_PCOA$data$Vectors %&gt;%
  select(SampleID, PC1, PC2, PC3) %&gt;%
  inner_join(metadata, by = c(&quot;SampleID&quot; = &quot;SampleID&quot;))

my_column &lt;- &quot;treatment&quot;

#overall Weighted uniFrac
ggplot(Wuni_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point(aes(shape= `time-point`), size = 3) + #alpha controls transparency and helps when points are overlapping
  #geom_point(data=centroids, size = 3) +
  theme_q2r() +
  stat_ellipse(level = 0.95, type = &quot;t&quot;) +
  xlab(paste0(&quot;PC1 (&quot;, round(100*wUF_PCOA$data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*wUF_PCOA$data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  scale_color_manual(values=trt_colors, name = &quot;treatment&quot;)

centroid2 &lt;- aggregate(cbind(PC1,PC2)~get(my_column),Wuni_meta,mean)
colnames(centroid2)[1] &lt;- &quot;treatment&quot;

w_UniFrac2 &lt;- ggplot(Wuni_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point(alpha = 0.6, size = 2) +  # Points with transparency
  stat_ellipse(type = &quot;t&quot;, level = 0.95) +  # Statistical ellipse, 95% confidence
  geom_text(data = centroids, aes(label = treatment, x = PC1, y = PC2), vjust = -1, hjust = -0.1) +  # Add centroids labels
  scale_color_manual(values = trt_colors, name = my_column) +
  facet_grid(~`time-point`) +  # Facet by time point
  xlab(paste0(&quot;PC1 (&quot;, round(100*wUF_PCOA$data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*wUF_PCOA$data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  theme_q2r() +  # Custom theme
  labs(title = &quot;weighted UniFrac Beta Diversity&quot;,  # Setting the title
       subtitle = &quot;Analysis by treatment and time points&quot;)+
  theme(
    plot.title = element_text(size = 16),  # Increase title font size
    plot.subtitle = element_text(size = 16),  # Increase subtitle font size
    axis.title = element_text(size = 15),  # Increase axis titles font size
    axis.text.x = element_text(size = 14),  # Increase x axis text font size
    axis.text.y = element_text(size = 14),  # Increase y axis text font size
    legend.title = element_text(size = 14),  # Increase legend title font size
    legend.text = element_text(size = 12)   # Increase legend text font size
  )
w_UniFrac2
ggsave(&quot;./alpha_diversity_plots/w_UniFrac2.png&quot;, height = 7, width = 10)

#PERMOVA

wu_dist_mat&lt;-read_qza(&quot;weighted_unifrac_distance_matrix.qza&quot;)
wu_dm &lt;- as.matrix(wu_dist_mat$data) 
rownames(wu_dm) == metadata$SampleID ## all these values need to be &quot;TRUE&quot;
metadata_sub &lt;- metadata[match(rownames(wu_dm),metadata$SampleID),]
rownames(wu_dm) == metadata_sub$SampleID ## all these values need to be &quot;TRUE&quot;

PERMANOVA_out2 &lt;- adonis2(wu_dm  ~ treatment, data = metadata_sub)
PERMANOVA_out2 

#pairwise ANOVA
pairwise.adonis3 &lt;- function(x, data, strata = NULL, nperm=999, ... ) {
  
  #describe parent call function 
  ststri &lt;- ifelse(is.null(strata),&#39;Null&#39;,strata)
  fostri &lt;- as.character(x)
  #list to store results
  
  #copy model formula
  x1 &lt;- x
  # extract left hand side of formula
  lhs &lt;- x1[[2]]
  # extract factors on right hand side of formula 
  rhs &lt;- x1[[3]]
  # create model.frame matrix  
  x1[[2]] &lt;- NULL   
  rhs.frame &lt;- model.frame(x1, data, drop.unused.levels = TRUE) 
  
  # create unique pairwise combination of factors 
  co &lt;- combn(unique(as.character(rhs.frame[,1])),2)
  
  # create names vector   
  nameres &lt;- c(&#39;parent_call&#39;)
  for (elem in 1:ncol(co)){
    nameres &lt;- c(nameres,paste(co[1,elem],co[2,elem],sep=&#39;_vs_&#39;))
  }
  #create results list  
  res &lt;- vector(mode=&quot;list&quot;, length=length(nameres))
  names(res) &lt;- nameres
  
  #add parent call to res 
  res[&#39;parent_call&#39;] &lt;- list(paste(fostri[2],fostri[1],fostri[3],&#39;, strata =&#39;,ststri, &#39;, permutations&#39;,nperm ))
  
  
  #start iteration trough pairwise combination of factors  
  for(elem in 1:ncol(co)){
    
    #reduce model elements  
    if(inherits(eval(lhs),&#39;dist&#39;)){ 
      xred &lt;- as.dist(as.matrix(eval(lhs))[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),
                                           rhs.frame[,1] %in% c(co[1,elem],co[2,elem])])
    }else{
      xred &lt;- eval(lhs)[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]
    }
    
    mdat1 &lt;-  data[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),] 
    
    # redefine formula
    if(length(rhs) == 1){
      xnew &lt;- as.formula(paste(&#39;xred&#39;,as.character(rhs),sep=&#39;~&#39;))   
    }else{
      xnew &lt;- as.formula(paste(&#39;xred&#39; , 
                               paste(rhs[-1],collapse= as.character(rhs[1])),
                               sep=&#39;~&#39;))}
    
    #pass new formula to adonis
    if(is.null(strata)){
      ad &lt;- adonis2(xnew,data=mdat1, ... )
    }else{
      perm &lt;- how(nperm = nperm)
      setBlocks(perm) &lt;- with(mdat1, mdat1[,ststri])
      ad &lt;- adonis2(xnew,data=mdat1,permutations = perm, ... )}
    
    res[nameres[elem+1]] &lt;- list(ad[1:5])
  }
  #names(res) &lt;- names  
  class(res) &lt;- c(&quot;pwadstrata&quot;, &quot;list&quot;)
  return(res)
} 

trt_Pair2 &lt;- pairwise.adonis3(wu_dm ~ treatment, data = metadata_sub)
trt_Pair2
write.table(trt_Pair2,&quot;./alpha_diversity_plots/WeightedUniFrac_pairwise.csv&quot;,sep=&quot;,&quot;, row.names = TRUE) 

#########################################################################

#unWeighted UNIFRAC
unwuf_PCOA &lt;- read_qza(&quot;unweighted_unifrac_pcoa_results.qza&quot;)
UnWuF_meta &lt;- unwuf_PCOA$data$Vectors %&gt;%
  select(SampleID, PC1, PC2, PC3) %&gt;%
  inner_join(metadata, by = c(&quot;SampleID&quot; = &quot;SampleID&quot;))

#overall unWeighted uniFrac
ggplot(UnWuF_meta, aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point(aes(shape= `time-point`), size = 3) + #alpha controls transparency and helps when points are overlapping
  #geom_point(data=centroids, size = 3) +
  theme_q2r() +
  stat_ellipse(level = 0.95, type = &quot;t&quot;) +
  xlab(paste0(&quot;PC1 (&quot;, round(100*unwuf_PCOA$data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*unwuf_PCOA$data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  scale_color_manual(values=trt_colors, name = &quot;treatment&quot;)


centroid3 &lt;- aggregate(cbind(PC1,PC2)~get(my_column),UnWuF_meta ,mean)
colnames(centroid3)[1] &lt;- &quot;treatment&quot;

uw_UniFrac &lt;- ggplot(UnWuF_meta , aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point(alpha = 0.6, size = 2) +  # Points with transparency
  stat_ellipse(type = &quot;t&quot;, level = 0.95) +  # Statistical ellipse, 95% confidence
  geom_text(data = centroid3, aes(label = treatment, x = PC1, y = PC2), vjust = -1, hjust = -0.1) +  # Add centroids labels
  scale_color_manual(values = trt_colors, name = my_column) +
  facet_grid(~`time-point`) +  # Facet by time point
  xlab(paste0(&quot;PC1 (&quot;, round(100*unwuf_PCOA$data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*unwuf_PCOA$data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  theme_q2r() +  # Custom theme
  labs(title = &quot;Unweighted UniFrac Beta Diversity&quot;,  # Setting the title
       subtitle = &quot;Analysis by treatment and time points&quot;)+
  theme(
    plot.title = element_text(size = 16),  # Increase title font size
    plot.subtitle = element_text(size = 16),  # Increase subtitle font size
    axis.title = element_text(size = 15),  # Increase axis titles font size
    axis.text.x = element_text(size = 14),  # Increase x axis text font size
    axis.text.y = element_text(size = 14),  # Increase y axis text font size
    legend.title = element_text(size = 14),  # Increase legend title font size
    legend.text = element_text(size = 12)   # Increase legend text font size
  )
uw_UniFrac 
ggsave(&quot;./alpha_diversity_plots/uw_UniFrac2.png&quot;, height = 7, width = 10)

#PERMOVA

unwu_dist_mat&lt;-read_qza(&quot;unweighted_unifrac_distance_matrix.qza&quot;)
unwu_dm &lt;- as.matrix(unwu_dist_mat$data) 
rownames(unwu_dm) == metadata$SampleID ## all these values need to be &quot;TRUE&quot;
metadata_sub3 &lt;- metadata[match(rownames(unwu_dm),metadata$SampleID),]
rownames(unwu_dm) == metadata_sub3$SampleID ## all these values need to be &quot;TRUE&quot;

PERM_un &lt;- adonis2(unwu_dm  ~ treatment, data = metadata_sub3)
PERM_un

#pairwise ANOVA
pairwise.adonis4 &lt;- function(x, data, strata = NULL, nperm=999, ... ) {
  
  #describe parent call function 
  ststri &lt;- ifelse(is.null(strata),&#39;Null&#39;,strata)
  fostri &lt;- as.character(x)
  #list to store results
  
  #copy model formula
  x1 &lt;- x
  # extract left hand side of formula
  lhs &lt;- x1[[2]]
  # extract factors on right hand side of formula 
  rhs &lt;- x1[[3]]
  # create model.frame matrix  
  x1[[2]] &lt;- NULL   
  rhs.frame &lt;- model.frame(x1, data, drop.unused.levels = TRUE) 
  
  # create unique pairwise combination of factors 
  co &lt;- combn(unique(as.character(rhs.frame[,1])),2)
  
  # create names vector   
  nameres &lt;- c(&#39;parent_call&#39;)
  for (elem in 1:ncol(co)){
    nameres &lt;- c(nameres,paste(co[1,elem],co[2,elem],sep=&#39;_vs_&#39;))
  }
  #create results list  
  res &lt;- vector(mode=&quot;list&quot;, length=length(nameres))
  names(res) &lt;- nameres
  
  #add parent call to res 
  res[&#39;parent_call&#39;] &lt;- list(paste(fostri[2],fostri[1],fostri[3],&#39;, strata =&#39;,ststri, &#39;, permutations&#39;,nperm ))
  
  
  #start iteration trough pairwise combination of factors  
  for(elem in 1:ncol(co)){
    
    #reduce model elements  
    if(inherits(eval(lhs),&#39;dist&#39;)){ 
      xred &lt;- as.dist(as.matrix(eval(lhs))[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),
                                           rhs.frame[,1] %in% c(co[1,elem],co[2,elem])])
    }else{
      xred &lt;- eval(lhs)[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]
    }
    
    mdat1 &lt;-  data[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),] 
    
    # redefine formula
    if(length(rhs) == 1){
      xnew &lt;- as.formula(paste(&#39;xred&#39;,as.character(rhs),sep=&#39;~&#39;))   
    }else{
      xnew &lt;- as.formula(paste(&#39;xred&#39; , 
                               paste(rhs[-1],collapse= as.character(rhs[1])),
                               sep=&#39;~&#39;))}
    
    #pass new formula to adonis
    if(is.null(strata)){
      ad &lt;- adonis2(xnew,data=mdat1, ... )
    }else{
      perm &lt;- how(nperm = nperm)
      setBlocks(perm) &lt;- with(mdat1, mdat1[,ststri])
      ad &lt;- adonis2(xnew,data=mdat1,permutations = perm, ... )}
    
    res[nameres[elem+1]] &lt;- list(ad[1:5])
  }
  #names(res) &lt;- names  
  class(res) &lt;- c(&quot;pwadstrata&quot;, &quot;list&quot;)
  return(res)
} 

trt_Pair3 &lt;- pairwise.adonis4(unwu_dm ~ treatment, data = metadata_sub3)
trt_Pair3
write.table(trt_Pair3,&quot;./alpha_diversity_plots/unWeightedUniFrac_pairwise.csv&quot;,sep=&quot;,&quot;, row.names = TRUE) 

###########################################################################
#jaccard
jac_PCoA &lt;- read_qza(&quot;jaccard_pcoa_results.qza&quot;)
jac_meta  &lt;- jac_PCoA$data$Vectors %&gt;%
  select(SampleID, PC1, PC2, PC3) %&gt;%
  inner_join(metadata, by = c(&quot;SampleID&quot; = &quot;SampleID&quot;))

# Now we are going to make an ordination plot
ggplot(jac_meta , aes(x=PC1, y=PC2, color=treatment)) +
  geom_point() + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  xlab(&quot;PC1 (32.27%)&quot;) +
  ylab(&quot;PC2 (22.28%)&quot;) +
  scale_color_manual(values=c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;), name = &quot;Treatment&quot;)

# Now we are going to make our code a little more re-usable
my_column &lt;- &quot;treatment&quot;

ggplot(jac_meta , aes(x=PC1, y=PC2, color=get(my_column))) +
  geom_point() + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  facet_grid(~`time-point`) +
  xlab(paste0(&quot;PC1 (&quot;, round(100*jac_PCoA $data$ProportionExplained[1], digits = 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100*jac_PCoA $data$ProportionExplained[2], digits = 2), &quot;%)&quot;)) +
  scale_color_manual(values=trt_colors, name = my_column)

#apply centroids

centroidj &lt;- aggregate(cbind(PC1,PC2)~get(my_column),jac_meta ,mean)
colnames(centroidj)[1] &lt;- &quot;treatment&quot;

plotjac &lt;- ggplot(jac_meta , aes(x = PC1, y = PC2, color = get(my_column))) +
  geom_point(alpha = 0.6, size = 2) +  # Points with transparency
  stat_ellipse(type = &quot;t&quot;, level = 0.95) +  # Statistical ellipse, 95% confidence
  geom_text(data = centroidj, aes(label = treatment, x = PC1, y = PC2), vjust = -1, hjust = -0.1) +  # Add centroidj labels
  scale_color_manual(values = trt_colors, name = my_column) +
  facet_grid(~`time-point`) +  # Facet by time point
  xlab(paste0(&quot;PC1 (&quot;, round(100 * jac_PCoA $data$ProportionExplained[1], 2), &quot;%)&quot;)) +
  ylab(paste0(&quot;PC2 (&quot;, round(100 * jac_PCoA $data$ProportionExplained[2], 2), &quot;%)&quot;)) +
  theme_q2r() +  # Custom theme
  labs(title = &quot; Jaccard Similarity &quot;,  # Setting the title
       subtitle = &quot;Analysis by treatment and time points&quot;)+
  theme(
    plot.title = element_text(size = 16),  # Increase title font size
    plot.subtitle = element_text(size = 16),  # Increase subtitle font size
    axis.title = element_text(size = 15),  # Increase axis titles font size
    axis.text.x = element_text(size = 14),  # Increase x axis text font size
    axis.text.y = element_text(size = 14),  # Increase y axis text font size
    legend.title = element_text(size = 14),  # Increase legend title font size
    legend.text = element_text(size = 14)   # Increase legend text font size
  )
plotjac
ggsave(&quot;./alpha_diversity_plots/plotjac.png&quot;, height = 7, width = 10)

jacc_dist_mat&lt;-read_qza(&quot;jaccard_distance_matrix.qza&quot;)
jacc_dm &lt;- as.matrix(jacc_dist_mat$data) 
rownames(jacc_dm) == metadata$SampleID ## all these values need to be &quot;TRUE&quot;
metadata_subj &lt;- metadata[match(rownames(jacc_dm),metadata$SampleID),]
rownames(jacc_dm) == metadata_subj$SampleID ## all these values need to be &quot;TRUE&quot;

PERMjac &lt;- adonis2(jacc_dm ~ treatment, data = metadata_subj)
PERMjac 
##  Pairwise adonis function
pairwise.adonis2 &lt;- function(x, data, strata = NULL, nperm=999, ... ) {
  
  #describe parent call function 
  ststri &lt;- ifelse(is.null(strata),&#39;Null&#39;,strata)
  fostri &lt;- as.character(x)
  #list to store results
  
  #copy model formula
  x1 &lt;- x
  # extract left hand side of formula
  lhs &lt;- x1[[2]]
  # extract factors on right hand side of formula 
  rhs &lt;- x1[[3]]
  # create model.frame matrix  
  x1[[2]] &lt;- NULL   
  rhs.frame &lt;- model.frame(x1, data, drop.unused.levels = TRUE) 
  
  # create unique pairwise combination of factors 
  co &lt;- combn(unique(as.character(rhs.frame[,1])),2)
  
  # create names vector   
  nameres &lt;- c(&#39;parent_call&#39;)
  for (elem in 1:ncol(co)){
    nameres &lt;- c(nameres,paste(co[1,elem],co[2,elem],sep=&#39;_vs_&#39;))
  }
  #create results list  
  res &lt;- vector(mode=&quot;list&quot;, length=length(nameres))
  names(res) &lt;- nameres
  
  #add parent call to res 
  res[&#39;parent_call&#39;] &lt;- list(paste(fostri[2],fostri[1],fostri[3],&#39;, strata =&#39;,ststri, &#39;, permutations&#39;,nperm ))
  
  
  #start iteration trough pairwise combination of factors  
  for(elem in 1:ncol(co)){
    
    #reduce model elements  
    if(inherits(eval(lhs),&#39;dist&#39;)){ 
      xred &lt;- as.dist(as.matrix(eval(lhs))[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),
                                           rhs.frame[,1] %in% c(co[1,elem],co[2,elem])])
    }else{
      xred &lt;- eval(lhs)[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),]
    }
    
    mdat1 &lt;-  data[rhs.frame[,1] %in% c(co[1,elem],co[2,elem]),] 
    
    # redefine formula
    if(length(rhs) == 1){
      xnew &lt;- as.formula(paste(&#39;xred&#39;,as.character(rhs),sep=&#39;~&#39;))   
    }else{
      xnew &lt;- as.formula(paste(&#39;xred&#39; , 
                               paste(rhs[-1],collapse= as.character(rhs[1])),
                               sep=&#39;~&#39;))}
    
    #pass new formula to adonis
    if(is.null(strata)){
      ad &lt;- adonis2(xnew,data=mdat1, ... )
    }else{
      perm &lt;- how(nperm = nperm)
      setBlocks(perm) &lt;- with(mdat1, mdat1[,ststri])
      ad &lt;- adonis2(xnew,data=mdat1,permutations = perm, ... )}
    
    res[nameres[elem+1]] &lt;- list(ad[1:5])
  }
  #names(res) &lt;- names  
  class(res) &lt;- c(&quot;pwadstrata&quot;, &quot;list&quot;)
  return(res)
} 

trt_Pair4 &lt;- pairwise.adonis2(jacc_dm ~ treatment, data = metadata_subj)
trt_Pair4
write.table(trt_Pair4,&quot;./alpha_diversity_plots/BJaccard_Adonis_pairwise.csv&quot;,sep=&quot;,&quot;, row.names = TRUE)</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>Different differential abundance method</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuI2NoZWNrIGhlcmUgZm9yIGJldHRlciBjb2RlIHRvIHRyYWluIDogaHR0cHM6Ly9ycHVicy5jb20va2pvamVzcy8xMDEzNTI3XG5tZXRhZGF0YTwtcmVhZF9xMm1ldGFkYXRhKFwicHJvamVjdF9tZXRhZGF0YS50eHRcIilcbnN0cihtZXRhZGF0YSlcbmxldmVscyhtZXRhZGF0YSRgYm9keS1zaXRlYClcbmNvbG5hbWVzKG1ldGFkYXRhKVsyXSA8LSBcInRpbWUtcG9pbnRcIlxuY29sbmFtZXMobWV0YWRhdGEpWzZdIDwtIFwidHJlYXRtZW50XCJcbnN0cihtZXRhZGF0YSlcblxuI0JFTE9XIElTIEZPUiBHRVRUSU5HIFRIRSBMRUZTRSBUQUJMRVxuXG4jIyBTZWxlY3QgYW5kIGtlZXAgdGhlIGNvbHVtbnMgeW91IG5lZWQgdG8gdXNlIGFzOlxuIyMgICAgY2xhc3MsIHN1YmNsYXNzIChvcHRpb25hbCkgYW5kIHN1YmplY3Rcbm1ldGFkYXRhX2ZpbHRlcmVkIDwtIG1ldGFkYXRhICU+JVxuICBzZWxlY3QoU2FtcGxlSUQsIHRyZWF0bWVudCwgYHRpbWUtcG9pbnRgKVxuc3RyKG1ldGFkYXRhX2ZpbHRlcmVkKVxuXG4jIFJlYWQgaW4gb3VwdXQgZnJvbSBxaWltZTJcbnRheG9ub215IDwtIHJlYWQuZGVsaW0oXCJmcmVxdWVuY3ktdGFibGUtbDYudHh0XCIsIHNraXAgPSAxKVxuaGVhZCh0YXhvbm9teSlcbnN0cih0YXhvbm9teSlcbiMgU29tZSByZWZvcm1hdHRpbmdcbmNvbG5hbWVzKHRheG9ub215KVsxXSA8LSBcIlRheG9uXCJcbnRheG9ub215IDwtIHRheG9ub215WywtKG5jb2wodGF4b25vbXkpKV1cbnRheG9ub215JEZlYXR1cmUuSUQgPC0gcGFzdGUwKFwiQVNWXCIsIDE6bnJvdyh0YXhvbm9teSkpXG5cbiMgc3BsaXQgdGhlIHRheG9ub215IGludG8gb25lIGxldmVsIHBlciBjb2x1bW4gYW5kIHJlbW92ZSB0aGUgXCJLX19cIiBzdHVmZlxudGF4LmNsZWFuPC1wYXJzZV90YXhvbm9teSh0YXhvbm9teSA9IHRheG9ub215LCB0YXhfc2VwID0gXCI7XCIpXG50YXguY2xlYW4gPC0gdGF4LmNsZWFuWywtN11cbmhlYWQodGF4LmNsZWFuKVxuXG4jIE1ha2UgdGhlIHVuY2xhc3NpZmllZCBjZWxscyBiZSBlbXB0eSBzbyB0aGF0IHdlIGNhbiBlZGl0IHRoZW0gXG50YXguY2xlYW5bdGF4LmNsZWFuPT1cIl9fXCJdIDwtIFwiXCJcbnRheC5jbGVhbltpcy5uYSh0YXguY2xlYW4pXSA8LSBcIlwiXG5cbm5jb2wodGF4LmNsZWFuKSAjI1RoaXMgc2hvdWxkIGVxdWFsIDYuIElmIG5vdCB0aGUgY29kZSB3aWxsIG5lZWQgdG8gYmUgbW9kaWZpZWQuXG5cbiMgQ2hhbmdlIGVtcHR5IGNlbGxzIHRvIHNheSBcInVuY2xhc3NpZmllZFwiIHdpdGggdGhlIGxhc3QgYXNzaWduZWQgdGF4b25vbWljIGxldmVsXG5mb3IgKGkgaW4gMTpucm93KHRheC5jbGVhbikpe1xuICBpZiAodGF4LmNsZWFuW2ksMl0gPT0gXCJcIil7XG4gICAga2luZ2RvbSA8LSBwYXN0ZShcInVuY2xhc3NpZmllZF9cIiwgdGF4LmNsZWFuW2ksMV0sIHNlcCA9IFwiXCIpXG4gICAgdGF4LmNsZWFuW2ksIDI6bmNvbCh0YXguY2xlYW4pXSA8LSBraW5nZG9tXG4gIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksM10gPT0gXCJcIil7XG4gICAgcGh5bHVtIDwtIHBhc3RlKFwidW5jbGFzc2lmaWVkX1wiLCB0YXguY2xlYW5baSwyXSwgc2VwID0gXCJcIilcbiAgICB0YXguY2xlYW5baSwgMzpuY29sKHRheC5jbGVhbildIDwtIHBoeWx1bVxuICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDRdID09IFwiXCIpe1xuICAgIGNsYXNzIDwtIHBhc3RlKFwidW5jbGFzc2lmaWVkX1wiLCB0YXguY2xlYW5baSwzXSwgc2VwID0gXCJcIilcbiAgICB0YXguY2xlYW5baSwgNDpuY29sKHRheC5jbGVhbildIDwtIGNsYXNzXG4gIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNV0gPT0gXCJcIil7XG4gICAgb3JkZXIgPC0gcGFzdGUoXCJ1bmNsYXNzaWZpZWRfXCIsIHRheC5jbGVhbltpLDRdLCBzZXAgPSBcIlwiKVxuICAgIHRheC5jbGVhbltpLCA1Om5jb2wodGF4LmNsZWFuKV0gPC0gb3JkZXJcbiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw2XSA9PSBcIlwiKXtcbiAgICBmYW1pbHkgPC0gcGFzdGUoXCJ1bmNsYXNzaWZpZWRfXCIsIHRheC5jbGVhbltpLDVdLCBzZXAgPSBcIlwiKVxuICAgIHRheC5jbGVhbltpLCA2Om5jb2wodGF4LmNsZWFuKV0gPC0gZmFtaWx5XG4gIH0gXG59XG5cbiMgTm93IGZpbmlzaCB1cCBmb3JtYXR0aW5nIGludG8gdGhlIGZvcm1hdCByZXF1aXJlZCBieSBsZWZzZVxuXG4jIEdldCB0YXhvbm9teSBpbnRvIG9uZSBjZWxsIHNlcGFyYXRlZCBieSBcInxcIlxudGF4LmNsZWFuX2xlZnNlIDwtIHRheC5jbGVhbiAlPiVcbiAgdW5pdGUoXCJsZWZzZVwiLCBLaW5nZG9tOkdlbnVzLCBzZXA9IFwifFwiLCBcbiAgICAgICAgcmVtb3ZlID0gRkFMU0UpXG5cbiMgTWVyZ2UgdGF4b25vbXkgd2l0aCByZWxhdGl2ZSBhYnVuZGFuY2UgZm9yIGVhY2ggc2FtcGxlXG50YXguY2xlYW5fbGVmc2UgPC0gbWVyZ2UodGF4LmNsZWFuX2xlZnNlLCB0YXhvbm9teSwgYnkueCA9IDAsIGJ5LnkgPSBcIkZlYXR1cmUuSURcIilcbnRheC5jbGVhbl9sZWZzZSA8LSB0YXguY2xlYW5fbGVmc2VbLC0zOi05XVxuXG4jIENvbnZlcnQgdC50YXggYmFjayB0byBpdHMgb3JpZ2luYWwgZm9ybSBhbmQgcHJlcGFyZSBpdCBmb3IgbWVyZ2luZ1xudGF4X2RmIDwtIGFzLmRhdGEuZnJhbWUodCh0LnRheCkpICAjIFRyYW5zcG9zZSBpdCBiYWNrXG5jb2xuYW1lcyh0YXhfZGYpIDwtIHRheF9kZlsxLCBdICAjIEFzc3VtaW5nIHRoZSBmaXJzdCByb3cgY29udGFpbnMgY29sdW1uIG5hbWVzIChzYW1wbGUgSURzKVxudGF4X2RmIDwtIHRheF9kZlstMSwgXSAgIyBSZW1vdmUgdGhlIGZpcnN0IHJvdyBub3cgdGhhdCBpdCdzIHVzZWQgYXMgY29sdW1uIG5hbWVzXG5cbiMgQWRkIHJvdyBuYW1lcyBhcyBhIGNvbHVtbiBmb3IgbWVyZ2luZyAoQVNWIGlkZW50aWZpZXJzKVxudGF4X2RmJEFTViA8LSByb3duYW1lcyh0YXhfZGYpXG5cbiMgQWRqdXN0IFNhbXBsZSBJRCBmb3JtYXRzIGluIG1ldGFkYXRhX2ZpbHRlcmVkIGlmIG5lY2Vzc2FyeVxubWV0YWRhdGFfZmlsdGVyZWQkU2FtcGxlSUQgPC0gYXMuY2hhcmFjdGVyKG1ldGFkYXRhX2ZpbHRlcmVkJFNhbXBsZUlEKSAgIyBNYWtlIHN1cmUgaXQncyBjaGFyYWN0ZXJcbm1ldGFkYXRhX2ZpbHRlcmVkJFNhbXBsZUlEIDwtIGdzdWIoXCItXCIsIFwiLlwiLCBtZXRhZGF0YV9maWx0ZXJlZCRTYW1wbGVJRCkgICMgUmVwbGFjZSBkYXNoZXMgd2l0aCBkb3RzIGlmIG5lY2Vzc2FyeVxuXG4jIE1lcmdlIHRoZSBkYXRhIGZyYW1lc1xuIyBBc3N1bWluZyB0aGF0IHNhbXBsZSBJRHMgaW4gdGF4X2RmIGFyZSBub3cgY29ycmVjdGx5IGZvcm1hdHRlZCB0byBtYXRjaCB0aG9zZSBpbiBtZXRhZGF0YV9maWx0ZXJlZFxuIyBUaGUgbWVyZ2luZyBrZXkgaW4gdGF4X2RmIG5lZWRzIHRvIGJlIGNoZWNrZWQgaWYgaXQncyBpbiBjb2x1bW4gbmFtZXMgb3IgbmVlZHMgdG8gYmUgY29uc3RydWN0ZWQgZnJvbSByb3cgbmFtZXNcbm1lcmdlZF9kYXRhIDwtIG1lcmdlKG1ldGFkYXRhX2ZpbHRlcmVkLCB0YXhfZGYsIGJ5LnggPSBcIlNhbXBsZUlEXCIsIGJ5LnkgPSBcIkFTVlwiLCBhbGwgPSBUUlVFKVxuXG4jIENoZWNrIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG1lcmdlZCBkYXRhXG5zdHIobWVyZ2VkX2RhdGEpXG5cbiMgU2F2ZSBmaW5hbF9kYXRhIHRvIGEgQ1NWIGZpbGVcbndyaXRlLmNzdihtZXJnZWRfZGF0YSwgXCJDOi9Vc2Vycy9PTFVNSURFL0Rlc2t0b3AvUHVyZHVlL1NwcmluZyAyMDI0L01vbGVjdWxhciBNaWNyb2Jpb21lIEFuYWx5c2lzIEFOU0M1MTYvcHJvamVjdC9Qcm9qZWN0IG91dHB1dC9mZWxzZWZpbmFsX2RhdGEuY3N2XCIsIHJvdy5uYW1lcyA9IEZBTFNFKVxuXG5cbiNtYWtlIGEgcGh5bG9zZXEgXG5cbmxpYnJhcnkocGh5bG9zZXEpXG5saWJyYXJ5KHJlbW90ZXMpXG5saWJyYXJ5KHFpaW1lMlIpXG5saWJyYXJ5KG1pY3JvYmlvbWVNYXJrZXIpXG5TZWF3ZWVkIDwtIHF6YV90b19waHlsb3NlcSAoXCJyYXJlZmllZF90YWJsZS5xemFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyb290ZWQtdHJlZS5xemFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YXhvbm9teS5xemFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9qZWN0X21ldGFkYXRhLnR4dFwiKVxuXG5TZWF3ZWVkXG4jRmlsdGVyIG91dCBOQSBQaHlsYVxuU2Vhd2VlZCA8LSBzdWJzZXRfdGF4YShTZWF3ZWVkLCAhaXMubmEoUGh5bHVtKSAmICFQaHlsdW0gJWluJSBjKFwiXCIpKVxudGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgXCJQaHlsdW1cIl0sIGV4Y2x1ZGUgPSBOVUxMKVxuXG4jY2hlY2sgZm9yIE5BIG9yIGxvdyBhYnVuZGFudCBDbGFzc2VzXG50YWJsZSh0YXhfdGFibGUoU2Vhd2VlZClbLCBcIkNsYXNzXCJdLCBleGNsdWRlID0gTlVMTClcblxuI1JlbW92ZSBOQSBDbGFzc2VzXG5TZWF3ZWVkIDwtIHN1YnNldF90YXhhKFNlYXdlZWQsICFpcy5uYShDbGFzcykgJiAhQ2xhc3MgJWluJSBjKFwiXCIpKVxudGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgXCJDbGFzc1wiXSwgZXhjbHVkZSA9IE5VTEwpXG5cbiNSZW1vdmUgTkEgQ2xhc3Nlc1xuU2Vhd2VlZCA8LSBzdWJzZXRfdGF4YShTZWF3ZWVkLCAhaXMubmEoQ2xhc3MpICYgIUNsYXNzICVpbiUgYyhcIlwiKSlcbnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssIFwiQ2xhc3NcIl0sIGV4Y2x1ZGUgPSBOVUxMKVxuXG4jQ2hlY2sgTkEgRmFtaWx5XG50YWJsZSh0YXhfdGFibGUoU2Vhd2VlZClbLCBcIkZhbWlseVwiXSwgZXhjbHVkZSA9IE5VTEwpXG5cbiNGaWx0ZXIgb3V0IE5BIEZhbWlseVxuU2Vhd2VlZCA8LSBzdWJzZXRfdGF4YShTZWF3ZWVkLCAhaXMubmEoRmFtaWx5KSAmICFGYW1pbHkgJWluJSBjKFwiXCIpKVxudGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgXCJGYW1pbHlcIl0sIGV4Y2x1ZGUgPSBOVUxMKVxuXG4jQ2hlY2sgTkEgR2VudXNcbnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssIFwiR2VudXNcIl0sIGV4Y2x1ZGUgPSBOVUxMKVxuXG4jRmlsdGVyIG91dCBOQSBHZW51c1xuU2Vhd2VlZCA8LSBzdWJzZXRfdGF4YShTZWF3ZWVkLCAhaXMubmEoR2VudXMpICYgIUdlbnVzICVpbiUgYyhcIlwiKSlcbnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssIFwiR2VudXNcIl0sIGV4Y2x1ZGUgPSBOVUxMKVxuVmlldyhTZWF3ZWVkQHRheF90YWJsZSlcblxuI0NoZWNrIFNwZWNpZXNcbnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssIFwiU3BlY2llc1wiXSwgZXhjbHVkZSA9IE5VTEwpXG4jRmlsdGVyIG91dCBOQSBTcGVjaWVzXG5TZWF3ZWVkIDwtIHN1YnNldF90YXhhKFNlYXdlZWQsICFpcy5uYShTcGVjaWVzKSAmICFTcGVjaWVzICVpbiUgYyhcIlwiKSlcbnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssIFwiU3BlY2llc1wiXSwgZXhjbHVkZSA9IE5VTEwpXG5cbiNSTkEtc2VxIGJhc2VkIERBIG1ldGhvZHNcbiNWb29tIChMYXcgZXQgYWwuIDIwMTQpIFxuI2ZvciB0aGUgZml2ZSBsaW5lYXIgbW9kZWxzLWJhc2VkIG1ldGhvZHMsIGluY2x1ZGluZyBlZGdlUiwgREVTZXEyLCBtZXRhZ2Vub1NlcSwgbGltbWEtdm9vbSwgYW5kIEFOQ09NQkMsIHVzZXJzIGNhbiBwZXJmb3JtIHBhaXItd2lzZSBjb21wYXJpc29ucyBieSBzZXR0aW5nIHRoZSBhcmd1bWVudCBjb250cmFzdCwgYSB0d28gbGVuZ3RoIGNoYXJhY3RlciBpbiB3aGljaCB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcmVmZXJlbmNlIGxldmVsIChkb25vbWluYXRvciBvZiB0aGUgbG9nRkMpIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdXNlZCBhcyBiYXNlbGluZSAobnVtZXJhdG9yIGZvciBmb2xkIGNoYW5nZSkuXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuIyBEYXkgMTVcbmNpZF9kYXkxNSA8LSBzdWJzZXRfc2FtcGxlcyhTZWF3ZWVkLCB0aW1lLnBvaW50ID09IFwiRGF5MTVcIilcbmNpZF9kYXkxNSA8LSBwaHlsb3NlcTo6c3Vic2V0X3NhbXBsZXMoY2lkX2RheTE1LCB0cmVhdG1lbnQgJWluJSBjKFwiQmFzYWxcIiwgXCJCU2VhMDVcIiwgXCJCU2VhMTBcIiwgXCJCU2VhMTVcIikpXG5cbm1tX0Jhc2FsX0JTZWEwNV9kYXkxNSA8LSBydW5fbGltbWFfdm9vbShcbiAgY2lkX2RheTE1LFxuICBcInRyZWF0bWVudFwiLFxuICBjb250cmFzdCA9IGMoXCJCYXNhbFwiLCBcIkJTZWEwNVwiKSxcbiAgcHZhbHVlX2N1dG9mZiA9IDAuMDEsXG4gIHBfYWRqdXN0ID0gXCJub25lXCJcbilcbnBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWEwNV9kYXkxNSlcblxuXG5tbV9CYXNhbF9CU2VhMTVfZGF5MTUgPC0gcnVuX2xpbW1hX3Zvb20oXG4gIGNpZF9kYXkxNSxcbiAgXCJ0cmVhdG1lbnRcIixcbiAgY29udHJhc3QgPSBjKFwiQmFzYWxcIiwgXCJCU2VhMTVcIiksXG4gIHB2YWx1ZV9jdXRvZmYgPSAwLjAxLFxuICBwX2FkanVzdCA9IFwibm9uZVwiXG4pXG5wbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTVfZGF5MTUpXG5cbm1tX0Jhc2FsX0JTZWExMF9kYXkxNSA8LSBydW5fbGltbWFfdm9vbShcbiAgY2lkX2RheTE1LFxuICBcInRyZWF0bWVudFwiLFxuICBjb250cmFzdCA9IGMoXCJCYXNhbFwiLCBcIkJTZWExMFwiKSxcbiAgcHZhbHVlX2N1dG9mZiA9IDAuMDEsXG4gIHBfYWRqdXN0ID0gXCJub25lXCJcbilcbnBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWExMF9kYXkxNSlcblxuXG5cbiMgRGF5IDIyXG5jaWRfZGF5MjIgPC0gc3Vic2V0X3NhbXBsZXMoU2Vhd2VlZCwgdGltZS5wb2ludCA9PSBcIkRheTIyXCIpXG5jaWRfZGF5MjIgPC0gcGh5bG9zZXE6OnN1YnNldF9zYW1wbGVzKGNpZF9kYXkyMiwgdHJlYXRtZW50ICVpbiUgYyhcIkJhc2FsXCIsIFwiQlNlYTA1XCIsIFwiQlNlYTEwXCIsIFwiQlNlYTE1XCIpKVxuXG5tbV9CYXNhbF9CU2VhMDVfZGF5MjIgPC0gcnVuX2xpbW1hX3Zvb20oXG4gIGNpZF9kYXkyMixcbiAgXCJ0cmVhdG1lbnRcIixcbiAgY29udHJhc3QgPSBjKFwiQmFzYWxcIiwgXCJCU2VhMDVcIiksXG4gIHB2YWx1ZV9jdXRvZmYgPSAwLjAxLFxuICBwX2FkanVzdCA9IFwibm9uZVwiXG4pXG5wbG90X2VmX2JhcihtbW1fQmFzYWxfQlNlYTA1X2RheTIyKVxuXG5tbV9CYXNhbF9CU2VhMTVfZGF5MjIgPC0gcnVuX2xpbW1hX3Zvb20oXG4gIGNpZF9kYXkyMixcbiAgXCJ0cmVhdG1lbnRcIixcbiAgY29udHJhc3QgPSBjKFwiQmFzYWxcIiwgXCJCU2VhMTVcIiksXG4gIHB2YWx1ZV9jdXRvZmYgPSAwLjAxLFxuICBwX2FkanVzdCA9IFwibm9uZVwiXG4pXG5wbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTVfZGF5MjIpXG5cbm1tX0Jhc2FsX0JTZWExMF9kYXkyMiA8LSBydW5fbGltbWFfdm9vbShcbiAgY2lkX2RheTIyLFxuICBcInRyZWF0bWVudFwiLFxuICBjb250cmFzdCA9IGMoXCJCYXNhbFwiLCBcIkJTZWExMFwiKSxcbiAgcHZhbHVlX2N1dG9mZiA9IDAuMDEsXG4gIHBfYWRqdXN0ID0gXCJub25lXCJcbilcbnBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWExMF9kYXkyMilcblxuXG4jIEVuc3VyZSBlYWNoIHBsb3QgaGFzIGEgdGl0bGUgc2V0IHdpdGggZ2d0aXRsZSgpXG5saWJyYXJ5KGdyaWRFeHRyYSlcbnBsb3QxIDwtIHBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWExNV9kYXkxNSkgKyBnZ3RpdGxlKFwiQmFzYWwgdnMgQlNlYTE1IERheSAxNVwiKVxucGxvdDIgPC0gcGxvdF9lZl9iYXIobW1fQmFzYWxfQlNlYTEwX2RheTE1KSArIGdndGl0bGUoXCJCYXNhbCB2cyBCU2VhMTAgRGF5IDE1XCIpXG5wbG90MyA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMDVfZGF5MTUpICsgZ2d0aXRsZShcIkJhc2FsIHZzIEJTZWEwNSBEYXkgMTVcIilcbnBsb3Q0IDwtIHBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWExNV9kYXkyMikgKyBnZ3RpdGxlKFwiQmFzYWwgdnMgQlNlYTE1IERheSAyMlwiKVxucGxvdDUgPC0gcGxvdF9lZl9iYXIobW1fQmFzYWxfQlNlYTEwX2RheTIyKSArIGdndGl0bGUoXCJCYXNhbCB2cyBCU2VhMTAgRGF5IDIyXCIpXG5cbiMgVXNlIGdyaWQuYXJyYW5nZSB0byBhcnJhbmdlIHRoZSBwbG90cyB3aXRoIHRpdGxlc1xuYWxsbGltYSA8LSBncmlkLmFycmFuZ2UoXG4gIHBsb3QxLCBwbG90MiwgcGxvdDMsIHBsb3Q0LCBwbG90NSxcbiAgbmNvbCA9IDNcbilcblxuXG4jIFNhdmUgdGhlIGNvbWJpbmVkIHBsb3Rcbmdnc2F2ZShcIkxpaW1hIFZvb20gREEucG5nXCIsIGFsbGxpbWEsIHdpZHRoID0gMTIsIGhlaWdodCA9IDgpXG5cbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4jbGVmc2VcbiN0aGUgY29kZSBiZWxvdyB1c2VzIExlZnNlIGFuZCBpdCBjb21iaW5lZCB0aGUgcGxvdCBmb3IgdGhlIGRpZmZlcm50aWFsIGFidW5kYW5jZSBmb3IgYWxsIHRyZWF0bWVudHMuXG4jb25seSB0aGUgb25lcyBkaWZmZXJlbnRpYWxseSBkaWZmZXJlbnQgZnJvbSBCYXNhbCBhcmUgZGlzcGxhY2VkLiBJdCBwcm9kdWNlcyBhbG1vc3QgaWRlbnRpY2FsIHRvIHZvb20gYnV0IGl0cyBub3JtYWxpc2VkLCBwcm9iYWJseSBiZXR0ZXJcblxuYTE1PC0gcnVuX2xlZnNlKGNpZF9kYXkxNSxncm91cCA9XCJ0cmVhdG1lbnRcIixcbiAgbm9ybSA9IFwiQ1BNXCIsICNgQ1BNYDogcHJlLXNhbXBsZSBub3JtYWxpemF0aW9uIG9mIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyB0byAxZSswNi5cbiAgbm9ybV9wYXJhID0gbGlzdCgpLFxuICBrd19jdXRvZmYgPSAwLjA1LFxuICBsZGFfY3V0b2ZmID0gMixcbiAgYm9vdHN0cmFwX24gPSAzMCxcbiAgYm9vdHN0cmFwX2ZyYWN0aW9uID0gMi8zLFxuICB3aWxjb3hvbl9jdXRvZmYgPSAwLjA1LFxuICBtdWx0aWdycF9zdHJhdCA9IFRSVUUsXG4gIHN0cmljdCA9IGMoXCIwXCIsIFwiMVwiLCBcIjJcIiksXG4gIHNhbXBsZV9taW4gPSAxMCxcbiAgb25seV9zYW1lX3N1YmdycCA9IEZBTFNFLFxuICBjdXJ2ID0gRkFMU0VcbilcbnBsb3RfZWZfYmFyKGExNSkgKyBnZ3RpdGxlKFwiQmFzYWwgdnMgQmFzYWwgcGx1cyBTZWF3ZWVkIERheSAxNVwiKVxuXG5cblxuYTIyPC0gcnVuX2xlZnNlKGNpZF9kYXkyMixncm91cCA9XCJ0cmVhdG1lbnRcIixcbiAgbm9ybSA9IFwiQ1BNXCIsICNgQ1BNYDogcHJlLXNhbXBsZSBub3JtYWxpemF0aW9uIG9mIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyB0byAxZSswNi5cbiAgbm9ybV9wYXJhID0gbGlzdCgpLFxuICBrd19jdXRvZmYgPSAwLjAxLFxuICBsZGFfY3V0b2ZmID0gMixcbiAgYm9vdHN0cmFwX24gPSAzMCxcbiAgYm9vdHN0cmFwX2ZyYWN0aW9uID0gMi8zLFxuICB3aWxjb3hvbl9jdXRvZmYgPSAwLjA1LFxuICBtdWx0aWdycF9zdHJhdCA9IFRSVUUsXG4gIHN0cmljdCA9IGMoXCIwXCIsIFwiMVwiLCBcIjJcIiksXG4gIHNhbXBsZV9taW4gPSAxMCxcbiAgb25seV9zYW1lX3N1YmdycCA9IEZBTFNFLFxuICBjdXJ2ID0gRkFMU0VcbilcbnBsb3RfZWZfYmFyKGEyMikgKyBnZ3RpdGxlKFwiQmFzYWwgdnMgQmFzYWwgcGx1cyBTZWF3ZWVkIERheSAyMlwiKVxuXG5wbG90NiA8LSBwbG90X2VmX2JhcihhMjIpICsgZ2d0aXRsZShcIkJhc2FsIHZzIEJhc2FsIHBsdXMgU2Vhd2VlZCBEYXkgMjJcIilcbnBsb3Q3IDwtIHBsb3RfZWZfYmFyKGExNSkgKyBnZ3RpdGxlKFwiQmFzYWwgdnMgQmFzYWwgcGx1cyBTZWF3ZWVkIERheSAxNVwiKVxuXG4jIFVzZSBncmlkLmFycmFuZ2UgdG8gYXJyYW5nZSB0aGUgcGxvdHMgd2l0aCB0aXRsZXNcbmFsbGxlZnNlIDwtIGdyaWQuYXJyYW5nZShcbiAgcGxvdDYsIHBsb3Q3LFxuICBuY29sID0gMlxuKVxuXG4jIFNhdmUgdGhlIGNvbWJpbmVkIHBsb3Rcbmdnc2F2ZShcIkxlZnNlIERBLnBuZ1wiLCBhbGxsZWZzZSwgd2lkdGggPSAxMiwgaGVpZ2h0ID0gOClcblxuXG5cbiNBYnVuZGFuY2UgYm94IHBsb3Q6ICBncm91cCBwYXJhIGZvciBwbG90X2FidW5hbmNlKCkgbXVzdCBiZSBrZWVwIHNhbWUgd2l0aCB0aGUgZ3JvdXAgcGFyYSBpbiB0aGUgZGlmZmVyZW50aWFsIGFuYWx5c2lzIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCBwbG90X2FidW5kYW5jZSgpIHdpbGwgcGxvdCBhbGwgdGhlIG1hcmtlcnMsIHVzZXJzIGNhbiBwbG90IHRoZSBzcGVjaWZpY2l0eSBtYXJrZXJzIHVzaW5nIHBhcmEgbWFya2Vycy5cblxubGlicmFyeShnZ3Bsb3QyKVxubGlicmFyeShncmlkRXh0cmEpXG5cbiMgQ3JlYXRpbmcgdGhlIGFidW5kYW5jZSBwbG90cyBmb3IgRGF5IDE1IGFuZCBEYXkgMjJcbnBfYWJkMTUgPC0gcGxvdF9hYnVuZGFuY2UoYTE1LCBncm91cCA9IFwidHJlYXRtZW50XCIpICtcbiAgZ2d0aXRsZShcIkxlZnNlIERBIGFidW5kYW5jZSBvbiBEYXkgMTVcIikgK1xuICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjKFwiIzAwNzJCMlwiLCBcIiNENTVFMDBcIiwgXCIjMDA5RTczXCIsIFwiI0YwRTQ0MlwiKSkgIyBDdXN0b20gZmlsbCBjb2xvcnNcblxucF9hYmQyMiA8LSBwbG90X2FidW5kYW5jZShhMjIsIGdyb3VwID0gXCJ0cmVhdG1lbnRcIikgK1xuICBnZ3RpdGxlKFwiTGVmc2UgREEgYWJ1bmRhbmNlIG9uIERheSAyMlwiKSArXG4gIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoXCIjMDA3MkIyXCIsIFwiI0Q1NUUwMFwiLCBcIiMwMDlFNzNcIiwgXCIjRjBFNDQyXCIpKSAjIFVzZSB0aGUgc2FtZSBjb2xvcnMgZm9yIGNvbnNpc3RlbmN5XG5cbiMgQXJyYW5nZSB0aGUgcGxvdHMgaW4gYSBzaW5nbGUgaW1hZ2VcbmNvbWJpbmVkX2xlZnNlYWJkIDwtIGdyaWQuYXJyYW5nZShwX2FiZDE1LCBwX2FiZDIyLCBuY29sID0gMSkgIyBBcnJhbmdlZCB2ZXJ0aWNhbGx5OyBjaGFuZ2UgYG5jb2xgIHRvIDIgZm9yIGhvcml6b250YWxcblxuIyBTYXZlIHRoZSBjb21iaW5lZCBpbWFnZSB0byBmaWxlXG5nZ3NhdmUoXCJjb21iaW5lZF9sZWZzZWFidW5kYW5jZV9wbG90cy5wbmdcIiwgY29tYmluZWRfbGVmc2VhYmQsIHdpZHRoID0gMTAsIGhlaWdodCA9IDE0KVxuXG5cbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiNSTkEtc2VxIGJhc2VkIERBIG1ldGhvZHMgKGh0dHBzOi8veWlsdWhlaWhlaS5naXRodWIuaW8vbWljcm9iaW9tZU1hcmtlci9hcnRpY2xlcy9taWNyb2Jpb21lTWFya2VyLXZpZ25ldHRlLmh0bWwpXG4jZWRnZVIgKFJvYmluc29uLCBNY0NhcnRoeSwgYW5kIFNteXRoIDIwMTApXG4jIG11bHRpcGxlIGdyb3Vwc1xuI1N1YnNldCB0cmVhdG1lbnQgYmFzZWQgb24gZGF5MTVcbm1tX2VkZ2VyX21nIDwtIHJ1bl9lZGdlcihcbiAgICBjaWRfZGF5MTUsXG4gICAgZ3JvdXAgPSBcInRyZWF0bWVudFwiLFxuICAgIG1ldGhvZCAgPSBcIlFMRlRcIixcbiAgICBwdmFsdWVfY3V0b2ZmID0gMC4wNSxcbiAgICBwX2FkanVzdCA9IFwiZmRyXCJcbilcbm1tX2VkZ2VyX21nXG5FZGdlcjE1IDwtcGxvdF9lZl9iYXIobW1fZWRnZXJfbWcpXG5FZGdlcjE1XG5cbiNEYXkgMjJcbm1tX2VkZ2VyIDwtIHJ1bl9lZGdlcihcbiAgICBjaWRfZGF5MjIsXG4gICAgZ3JvdXAgPSBcInRyZWF0bWVudFwiLFxuICAgIG1ldGhvZCAgPSBcIlFMRlRcIixcbiAgICBwdmFsdWVfY3V0b2ZmID0gMC4wNSxcbiAgICBwX2FkanVzdCA9IFwiZmRyXCJcbilcbm1tX2VkZ2VyXG5FZGdlcjIyIDwtcGxvdF9lZl9iYXIobW1fZWRnZXIpXG5FZGdlcjIyXG5cbmxpYnJhcnkoZ2dwbG90MilcbmxpYnJhcnkoZ2dwdWJyKVxuRWRnZVJjb208LSBnZ2FycmFuZ2UoRWRnZXIxNSAsIEVkZ2VyMjIgLCBuY29sID0gMiwgbnJvdyA9IDEpXG5FZGdlUmNvbVxuZ2dzYXZlKFwiRWRnZVJjb20gREFfcGxvdC5wbmdcIiwgRWRnZVJjb20sIHdpZHRoID0gMTAsIGhlaWdodCA9IDUpXG5cblxuRWRnZVJjb20gPC0gZ2dhcnJhbmdlKEVkZ2VyMTUgKyBsYWJzKHRpdGxlID0gXCJEYXkgMTVcIiksIEVkZ2VyMjIgKyBsYWJzKHRpdGxlID0gXCJEYXkgMjJcIiksIG5jb2wgPSAyLCBucm93ID0gMSlcbkVkZ2VSY29tIDwtIEVkZ2VSY29tICsgbGFicyh0aXRsZSA9IFwiRWRnZVIgQ29tcGFyaXNvblwiKVxuRWRnZVJjb21cbmdnc2F2ZShcIkVkZ2VSY29tX0RBX3Bsb3QucG5nXCIsIEVkZ2VSY29tLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1KVxuXG5gYGAifQ== -->
<pre class="r"><code>#check here for better code to train : https://rpubs.com/kjojess/1013527
metadata&lt;-read_q2metadata(&quot;project_metadata.txt&quot;)
str(metadata)
levels(metadata$`body-site`)
colnames(metadata)[2] &lt;- &quot;time-point&quot;
colnames(metadata)[6] &lt;- &quot;treatment&quot;
str(metadata)

#BELOW IS FOR GETTING THE LEFSE TABLE

## Select and keep the columns you need to use as:
##    class, subclass (optional) and subject
metadata_filtered &lt;- metadata %&gt;%
  select(SampleID, treatment, `time-point`)
str(metadata_filtered)

# Read in ouput from qiime2
taxonomy &lt;- read.delim(&quot;frequency-table-l6.txt&quot;, skip = 1)
head(taxonomy)
str(taxonomy)
# Some reformatting
colnames(taxonomy)[1] &lt;- &quot;Taxon&quot;
taxonomy &lt;- taxonomy[,-(ncol(taxonomy))]
taxonomy$Feature.ID &lt;- paste0(&quot;ASV&quot;, 1:nrow(taxonomy))

# split the taxonomy into one level per column and remove the &quot;K__&quot; stuff
tax.clean&lt;-parse_taxonomy(taxonomy = taxonomy, tax_sep = &quot;;&quot;)
tax.clean &lt;- tax.clean[,-7]
head(tax.clean)

# Make the unclassified cells be empty so that we can edit them 
tax.clean[tax.clean==&quot;__&quot;] &lt;- &quot;&quot;
tax.clean[is.na(tax.clean)] &lt;- &quot;&quot;

ncol(tax.clean) ##This should equal 6. If not the code will need to be modified.

# Change empty cells to say &quot;unclassified&quot; with the last assigned taxonomic level
for (i in 1:nrow(tax.clean)){
  if (tax.clean[i,2] == &quot;&quot;){
    kingdom &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,1], sep = &quot;&quot;)
    tax.clean[i, 2:ncol(tax.clean)] &lt;- kingdom
  } else if (tax.clean[i,3] == &quot;&quot;){
    phylum &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,2], sep = &quot;&quot;)
    tax.clean[i, 3:ncol(tax.clean)] &lt;- phylum
  } else if (tax.clean[i,4] == &quot;&quot;){
    class &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,3], sep = &quot;&quot;)
    tax.clean[i, 4:ncol(tax.clean)] &lt;- class
  } else if (tax.clean[i,5] == &quot;&quot;){
    order &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,4], sep = &quot;&quot;)
    tax.clean[i, 5:ncol(tax.clean)] &lt;- order
  } else if (tax.clean[i,6] == &quot;&quot;){
    family &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,5], sep = &quot;&quot;)
    tax.clean[i, 6:ncol(tax.clean)] &lt;- family
  } 
}

# Now finish up formatting into the format required by lefse

# Get taxonomy into one cell separated by &quot;|&quot;
tax.clean_lefse &lt;- tax.clean %&gt;%
  unite(&quot;lefse&quot;, Kingdom:Genus, sep= &quot;|&quot;, 
        remove = FALSE)

# Merge taxonomy with relative abundance for each sample
tax.clean_lefse &lt;- merge(tax.clean_lefse, taxonomy, by.x = 0, by.y = &quot;Feature.ID&quot;)
tax.clean_lefse &lt;- tax.clean_lefse[,-3:-9]

# Convert t.tax back to its original form and prepare it for merging
tax_df &lt;- as.data.frame(t(t.tax))  # Transpose it back
colnames(tax_df) &lt;- tax_df[1, ]  # Assuming the first row contains column names (sample IDs)
tax_df &lt;- tax_df[-1, ]  # Remove the first row now that it&#39;s used as column names

# Add row names as a column for merging (ASV identifiers)
tax_df$ASV &lt;- rownames(tax_df)

# Adjust Sample ID formats in metadata_filtered if necessary
metadata_filtered$SampleID &lt;- as.character(metadata_filtered$SampleID)  # Make sure it&#39;s character
metadata_filtered$SampleID &lt;- gsub(&quot;-&quot;, &quot;.&quot;, metadata_filtered$SampleID)  # Replace dashes with dots if necessary

# Merge the data frames
# Assuming that sample IDs in tax_df are now correctly formatted to match those in metadata_filtered
# The merging key in tax_df needs to be checked if it&#39;s in column names or needs to be constructed from row names
merged_data &lt;- merge(metadata_filtered, tax_df, by.x = &quot;SampleID&quot;, by.y = &quot;ASV&quot;, all = TRUE)

# Check the structure of the merged data
str(merged_data)

# Save final_data to a CSV file
write.csv(merged_data, &quot;C:/Users/OLUMIDE/Desktop/Purdue/Spring 2024/Molecular Microbiome Analysis ANSC516/project/Project output/felsefinal_data.csv&quot;, row.names = FALSE)


#make a phyloseq 

library(phyloseq)
library(remotes)
library(qiime2R)
library(microbiomeMarker)
Seaweed &lt;- qza_to_phyloseq (&quot;rarefied_table.qza&quot;,
                          &quot;rooted-tree.qza&quot;,
                          &quot;taxonomy.qza&quot;,
                          &quot;project_metadata.txt&quot;)

Seaweed
#Filter out NA Phyla
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Phylum) &amp; !Phylum %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Phylum&quot;], exclude = NULL)

#check for NA or low abundant Classes
table(tax_table(Seaweed)[, &quot;Class&quot;], exclude = NULL)

#Remove NA Classes
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Class) &amp; !Class %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Class&quot;], exclude = NULL)

#Remove NA Classes
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Class) &amp; !Class %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Class&quot;], exclude = NULL)

#Check NA Family
table(tax_table(Seaweed)[, &quot;Family&quot;], exclude = NULL)

#Filter out NA Family
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Family) &amp; !Family %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Family&quot;], exclude = NULL)

#Check NA Genus
table(tax_table(Seaweed)[, &quot;Genus&quot;], exclude = NULL)

#Filter out NA Genus
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Genus) &amp; !Genus %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Genus&quot;], exclude = NULL)
View(Seaweed@tax_table)

#Check Species
table(tax_table(Seaweed)[, &quot;Species&quot;], exclude = NULL)
#Filter out NA Species
Seaweed &lt;- subset_taxa(Seaweed, !is.na(Species) &amp; !Species %in% c(&quot;&quot;))
table(tax_table(Seaweed)[, &quot;Species&quot;], exclude = NULL)

#RNA-seq based DA methods
#Voom (Law et al. 2014) 
#for the five linear models-based methods, including edgeR, DESeq2, metagenoSeq, limma-voom, and ANCOMBC, users can perform pair-wise comparisons by setting the argument contrast, a two length character in which the first element is the reference level (donominator of the logFC) and the second element is used as baseline (numerator for fold change).
########################################################
# Day 15
cid_day15 &lt;- subset_samples(Seaweed, time.point == &quot;Day15&quot;)
cid_day15 &lt;- phyloseq::subset_samples(cid_day15, treatment %in% c(&quot;Basal&quot;, &quot;BSea05&quot;, &quot;BSea10&quot;, &quot;BSea15&quot;))

mm_Basal_BSea05_day15 &lt;- run_limma_voom(
  cid_day15,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea05&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mm_Basal_BSea05_day15)


mm_Basal_BSea15_day15 &lt;- run_limma_voom(
  cid_day15,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea15&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mm_Basal_BSea15_day15)

mm_Basal_BSea10_day15 &lt;- run_limma_voom(
  cid_day15,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea10&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mm_Basal_BSea10_day15)



# Day 22
cid_day22 &lt;- subset_samples(Seaweed, time.point == &quot;Day22&quot;)
cid_day22 &lt;- phyloseq::subset_samples(cid_day22, treatment %in% c(&quot;Basal&quot;, &quot;BSea05&quot;, &quot;BSea10&quot;, &quot;BSea15&quot;))

mm_Basal_BSea05_day22 &lt;- run_limma_voom(
  cid_day22,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea05&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mmm_Basal_BSea05_day22)

mm_Basal_BSea15_day22 &lt;- run_limma_voom(
  cid_day22,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea15&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mm_Basal_BSea15_day22)

mm_Basal_BSea10_day22 &lt;- run_limma_voom(
  cid_day22,
  &quot;treatment&quot;,
  contrast = c(&quot;Basal&quot;, &quot;BSea10&quot;),
  pvalue_cutoff = 0.01,
  p_adjust = &quot;none&quot;
)
plot_ef_bar(mm_Basal_BSea10_day22)


# Ensure each plot has a title set with ggtitle()
library(gridExtra)
plot1 &lt;- plot_ef_bar(mm_Basal_BSea15_day15) + ggtitle(&quot;Basal vs BSea15 Day 15&quot;)
plot2 &lt;- plot_ef_bar(mm_Basal_BSea10_day15) + ggtitle(&quot;Basal vs BSea10 Day 15&quot;)
plot3 &lt;- plot_ef_bar(mm_Basal_BSea05_day15) + ggtitle(&quot;Basal vs BSea05 Day 15&quot;)
plot4 &lt;- plot_ef_bar(mm_Basal_BSea15_day22) + ggtitle(&quot;Basal vs BSea15 Day 22&quot;)
plot5 &lt;- plot_ef_bar(mm_Basal_BSea10_day22) + ggtitle(&quot;Basal vs BSea10 Day 22&quot;)

# Use grid.arrange to arrange the plots with titles
alllima &lt;- grid.arrange(
  plot1, plot2, plot3, plot4, plot5,
  ncol = 3
)


# Save the combined plot
ggsave(&quot;Liima Voom DA.png&quot;, alllima, width = 12, height = 8)

########################################################
#lefse
#the code below uses Lefse and it combined the plot for the differntial abundance for all treatments.
#only the ones differentially different from Basal are displaced. It produces almost identical to voom but its normalised, probably better

a15&lt;- run_lefse(cid_day15,group =&quot;treatment&quot;,
  norm = &quot;CPM&quot;, #`CPM`: pre-sample normalization of the sum of the values to 1e+06.
  norm_para = list(),
  kw_cutoff = 0.05,
  lda_cutoff = 2,
  bootstrap_n = 30,
  bootstrap_fraction = 2/3,
  wilcoxon_cutoff = 0.05,
  multigrp_strat = TRUE,
  strict = c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;),
  sample_min = 10,
  only_same_subgrp = FALSE,
  curv = FALSE
)
plot_ef_bar(a15) + ggtitle(&quot;Basal vs Basal plus Seaweed Day 15&quot;)



a22&lt;- run_lefse(cid_day22,group =&quot;treatment&quot;,
  norm = &quot;CPM&quot;, #`CPM`: pre-sample normalization of the sum of the values to 1e+06.
  norm_para = list(),
  kw_cutoff = 0.01,
  lda_cutoff = 2,
  bootstrap_n = 30,
  bootstrap_fraction = 2/3,
  wilcoxon_cutoff = 0.05,
  multigrp_strat = TRUE,
  strict = c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;),
  sample_min = 10,
  only_same_subgrp = FALSE,
  curv = FALSE
)
plot_ef_bar(a22) + ggtitle(&quot;Basal vs Basal plus Seaweed Day 22&quot;)

plot6 &lt;- plot_ef_bar(a22) + ggtitle(&quot;Basal vs Basal plus Seaweed Day 22&quot;)
plot7 &lt;- plot_ef_bar(a15) + ggtitle(&quot;Basal vs Basal plus Seaweed Day 15&quot;)

# Use grid.arrange to arrange the plots with titles
alllefse &lt;- grid.arrange(
  plot6, plot7,
  ncol = 2
)

# Save the combined plot
ggsave(&quot;Lefse DA.png&quot;, alllefse, width = 12, height = 8)



#Abundance box plot:  group para for plot_abunance() must be keep same with the group para in the differential analysis function. By default, plot_abundance() will plot all the markers, users can plot the specificity markers using para markers.

library(ggplot2)
library(gridExtra)

# Creating the abundance plots for Day 15 and Day 22
p_abd15 &lt;- plot_abundance(a15, group = &quot;treatment&quot;) +
  ggtitle(&quot;Lefse DA abundance on Day 15&quot;) +
  scale_fill_manual(values = c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;)) # Custom fill colors

p_abd22 &lt;- plot_abundance(a22, group = &quot;treatment&quot;) +
  ggtitle(&quot;Lefse DA abundance on Day 22&quot;) +
  scale_fill_manual(values = c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;)) # Use the same colors for consistency

# Arrange the plots in a single image
combined_lefseabd &lt;- grid.arrange(p_abd15, p_abd22, ncol = 1) # Arranged vertically; change `ncol` to 2 for horizontal

# Save the combined image to file
ggsave(&quot;combined_lefseabundance_plots.png&quot;, combined_lefseabd, width = 10, height = 14)


###################################

#RNA-seq based DA methods (https://yiluheihei.github.io/microbiomeMarker/articles/microbiomeMarker-vignette.html)
#edgeR (Robinson, McCarthy, and Smyth 2010)
# multiple groups
#Subset treatment based on day15
mm_edger_mg &lt;- run_edger(
    cid_day15,
    group = &quot;treatment&quot;,
    method  = &quot;QLFT&quot;,
    pvalue_cutoff = 0.05,
    p_adjust = &quot;fdr&quot;
)
mm_edger_mg
Edger15 &lt;-plot_ef_bar(mm_edger_mg)
Edger15

#Day 22
mm_edger &lt;- run_edger(
    cid_day22,
    group = &quot;treatment&quot;,
    method  = &quot;QLFT&quot;,
    pvalue_cutoff = 0.05,
    p_adjust = &quot;fdr&quot;
)
mm_edger
Edger22 &lt;-plot_ef_bar(mm_edger)
Edger22

library(ggplot2)
library(ggpubr)
EdgeRcom&lt;- ggarrange(Edger15 , Edger22 , ncol = 2, nrow = 1)
EdgeRcom
ggsave(&quot;EdgeRcom DA_plot.png&quot;, EdgeRcom, width = 10, height = 5)


EdgeRcom &lt;- ggarrange(Edger15 + labs(title = &quot;Day 15&quot;), Edger22 + labs(title = &quot;Day 22&quot;), ncol = 2, nrow = 1)
EdgeRcom &lt;- EdgeRcom + labs(title = &quot;EdgeR Comparison&quot;)
EdgeRcom
ggsave(&quot;EdgeRcom_DA_plot.png&quot;, EdgeRcom, width = 10, height = 5)
</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>Cooccurrence</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuI2Nvb2NjdXJlbmNlXG5saWJyYXJ5KEhtaXNjKVxubGlicmFyeShwbHlyKVxubGlicmFyeShyZXNoYXBlMilcbmxpYnJhcnkocWlpbWUyUilcbmxpYnJhcnkoaWdyYXBoKVxubGlicmFyeShmZHJ0b29sKVxuXG5cbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuQVNWcyA8LSByZWFkX3F6YShcInJhcmVmaWVkX3RhYmxlLnF6YVwiKVxuQVNWX3RhYmxlIDwtIGFzLmRhdGEuZnJhbWUoQVNWcyRkYXRhKVxuXG5BU1ZfdGFibGUkQVNWbm9zIDwtIHBhc3RlMChcIkFTVlwiLCAxOm5yb3coQVNWX3RhYmxlKSlcbkFTVl90YWJsZSRBU1ZzdHJpbmcgPC0gcm93bmFtZXMoQVNWX3RhYmxlKVxucm93bmFtZXMoQVNWX3RhYmxlKSA8LSBBU1ZfdGFibGUkQVNWbm9zXG5BU1ZrZXkgPC0gQVNWX3RhYmxlWywgKG5jb2woQVNWX3RhYmxlKS0xKTpuY29sKEFTVl90YWJsZSldXG5BU1ZfdGFibGUgPC0gQVNWX3RhYmxlWywtKG5jb2woQVNWX3RhYmxlKS0xKTotbmNvbChBU1ZfdGFibGUpXVxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG5kYXRhc2V0IDwtIGFzLmRhdGEuZnJhbWUodChBU1ZfdGFibGUpKVxuXG5cbiMgd2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSBhIG5ldHdvcmsgcGVyIHRyZWF0bWVudFxuaGVhZChkYXRhc2V0WywxOjEwXSlcblxubWV0YWRhdGE8LXJlYWRfcTJtZXRhZGF0YShcInByb2plY3RfbWV0YWRhdGEudHh0XCIpXG5zdHIobWV0YWRhdGEpXG5jb2xuYW1lcyhtZXRhZGF0YSlbMl0gPSBcInRpbWUtcG9pbnRcIlxuY29sbmFtZXMobWV0YWRhdGEpWzZdID0gXCJ0cmVhdG1lbnRcIlxuXG5kYXRhc2V0IDwtIG1lcmdlKG1ldGFkYXRhLCBkYXRhc2V0LCBieS54ID0gXCJTYW1wbGVJRFwiLCBieS55ID0gMClcbnRyZWF0bWVudHM8LWFzLnZlY3Rvcih1bmlxdWUoZGF0YXNldCR0cmVhdG1lbnQpKVxuZGF0YXNldG48LWRhdGFzZXRcbmRhdGFzZXRuW2RhdGFzZXRuPT0wXTwtTkFcblxuI2kgPSAxXG5cbnN1bW1hcnkobWV0YWRhdGEkdHJlYXRtZW50KVxuXG5teV9jb2x1bW4gPC0gXCJ0cmVhdG1lbnRcIlxubjEgPC0gOFxubjIgPC0gOFxubjMgPC0gOFxubjQgPC0gOFxuXG5udW1fbWV0YWRhdGFfY29sdW1ucyA8LSBuY29sKG1ldGFkYXRhKVxuXG5xX2N1dG9mZiA8LSAwLjA1XG5cbmZpbmFsX3Jlc3VsdHM8LWRhdGEuZnJhbWUoKVxuXG5mb3IoaSBpbiAxOmxlbmd0aCh0cmVhdG1lbnRzKSl7XG4gIFxuICAjc3Vic2V0IHRoZSBkYXRhIGZvciBhIHBhcnRpY3VsYXIgdHJlYXRtZW50IFlPVSBNVVNUIEVOVEVSIFRIRSBIRUFERVIgT0YgVEhFIENPTFVNTiBUSEFUIEhBUyBUSEUgRElGRkVSRU5UIFRSRUFUTUVOVFMgSU4gVEhJUyBDQVNFIOKAnHRyZWF0bWVudOKAnVxuICBcbiAgcHJpbnQocGFzdGUoXCJyZWFkaW5nIFwiLHRyZWF0bWVudHNbaV0sc2VwPVwiXCIpKVxuICB0ZW1wPC1zdWJzZXQoZGF0YXNldCwgZ2V0KG15X2NvbHVtbik9PXRyZWF0bWVudHNbaV0pXG4gIHRlbXBuPC1zdWJzZXQoZGF0YXNldG4sIGdldChteV9jb2x1bW4pPT10cmVhdG1lbnRzW2ldKVxuICBwcmludChwYXN0ZShcImZpbmlzaGVkIHJlYWRpbmcgXCIsdHJlYXRtZW50c1tpXSxzZXA9XCJcIikpXG4gICMgbWFraW5nIGFuIG9iamVjdCB0aGF0IGhhcyBhbGwgdGhlIHJlc3VsdHMgaW4gaXQgKGJvdGggcmhvIGFuZCBQIHZhbHVlcylcbiAgcmVzdWx0czwtcmNvcnIoYXMubWF0cml4KHRlbXBbLC1jKDE6bnVtX21ldGFkYXRhX2NvbHVtbnMpXSksdHlwZT1cInNwZWFybWFuXCIpICMjIHVzZSB0aGUgXCItY1wiIHBhcmFtZXRlciB0byByZW1vdmUgbWV0YWRhdGEgY29sdW1uc1xuICByZXN1bHRzbjwtcmNvcnIoYXMubWF0cml4KHRlbXBuWywtYygxOm51bV9tZXRhZGF0YV9jb2x1bW5zKV0pLHR5cGU9XCJzcGVhcm1hblwiKVxuICBcbiAgI21ha2UgdHdvIHNlcGVyYXRlIG9iamVjdHMgZm9yIHAtdmFsdWUgYW5kIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50c1xuICByaG9zPC1yZXN1bHRzJHJcbiAgcHM8LXJlc3VsdHMkUFxuICBuczwtcmVzdWx0c24kblxuICAjIGdvaW5nIHRvIG1lbHQgdGhlc2Ugb2JqZWN0cyB0byAnbG9uZyBmb3JtJyB3aGVyZSB0aGUgZmlyc3QgdHdvIGNvbHVtbnMgbWFrZSB1cCB0aGUgcGFpcnMgb2YgT1RVcywgSSBhbSBhbHNvIHJlbW92aW5nIE5BJ3MgYXMgdGhleSBhcmUgc2VsZi1jb21wYXJpc29ucywgbm90IGVub3VnaCBkYXRhLCBvdGhlciBiYWQgc3R1ZmZcbiAgcHNfbWVsdDwtbmEub21pdChtZWx0KHBzKSlcbiAgI2NyZWF0aW5nIGEgcXZhbHVlIGJhc2VkIG9uIEZEUlxuICBwc19tZWx0JHF2YWw8LXAuYWRqdXN0KHBzX21lbHQkdmFsdWUsIG1ldGhvZCA9IFwiQkhcIilcbiAgI21ha2luZyBjb2x1bW4gbmFtZXMgbW9yZSByZWxldmFudFxuICBcbiAgbmFtZXMocHNfbWVsdClbM108LVwicHZhbFwiXG4gICMgaWYgeW91IGFyZSBvZiB0aGUgb3BpbmlvbiB0aGF0IGl0IGlzIGEgZ29vZCBpZGVhIHRvIHN1YnNldCB5b3VyIG5ldHdvcmsgYmFzZWQgb24gYWRqdXN0ZWQgUC12YWx1ZXMgKHF2YWwgaW4gdGhpcyBjYXNlKSwgeW91IGNhbiB0aGVuIHN1YnNldCBoZXJlXG4gIHBzX3N1Yjwtc3Vic2V0KHBzX21lbHQsIHF2YWwgPCBxX2N1dG9mZilcbiAgXG4gICMgbm93IG1lbHRpbmcgdGhlIHJob3MsIG5vdGUgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBwc19tZWx0IGFuZCByaG9zX21lbHRcbiAgcmhvc19tZWx0PC1uYS5vbWl0KG1lbHQocmhvcykpXG4gIG5hbWVzKHJob3NfbWVsdClbM108LVwicmhvXCJcbiAgXG4gICMgbm93IG1lbHRpbmcgdGhlIG5zXG4gIG5zX21lbHQ8LShtZWx0KG5zKSlcbiAgbmFtZXMobnNfbWVsdClbM108LVwiblwiXG4gIFxuICAjbWVyZ2luZyB0b2dldGhlciBhbmQgcmVtb3ZlIG5lZ2F0aXZlIHJob3NcbiAgbWVyZ2VkPC1tZXJnZShwc19zdWIscmhvc19tZWx0LGJ5PWMoXCJWYXIxXCIsXCJWYXIyXCIpKVxuICBpZiAodHJlYXRtZW50c1tpXT09dHJlYXRtZW50c1sxXSkge1xuICAgIG1lcmdlZDwtbWVyZ2UobWVyZ2VkLHN1YnNldChuc19tZWx0LCBuID4gbjEpLGJ5PWMoXCJWYXIxXCIsXCJWYXIyXCIpKVxuICB9ICAgZWxzZSBpZiAodHJlYXRtZW50c1tpXT09dHJlYXRtZW50c1syXSkge1xuICAgIG1lcmdlZDwtbWVyZ2UobWVyZ2VkLHN1YnNldChuc19tZWx0LCBuID4gbjIpLGJ5PWMoXCJWYXIxXCIsXCJWYXIyXCIpKVxuICB9ICAgZWxzZSBpZiAodHJlYXRtZW50c1tpXT09dHJlYXRtZW50c1szXSkge1xuICAgIG1lcmdlZDwtbWVyZ2UobWVyZ2VkLHN1YnNldChuc19tZWx0LCBuID4gbjMpLGJ5PWMoXCJWYXIxXCIsXCJWYXIyXCIpKVxuICB9ICAgZWxzZSBpZiAodHJlYXRtZW50c1tpXT09dHJlYXRtZW50c1s0XSkge1xuICAgIG1lcmdlZDwtbWVyZ2UobWVyZ2VkLHN1YnNldChuc19tZWx0LCBuID4gbjQpLGJ5PWMoXCJWYXIxXCIsXCJWYXIyXCIpKVxuICB9ICAgZWxzZVxuICAgIHByaW50KFwiU29tZXRoaW5ncyB3cm9uZyB3aXRoIHlvdXIgdHJlYXRtZW50IGRlc2lnbmF0aW9ucy4gUGxlYXNlIENoZWNrISFcIilcbiAgXG4gIGlmIChucm93KG1lcmdlZCkgPiAwKSB7XG4gICAgbWVyZ2VkJHRydDwtdHJlYXRtZW50c1tpXVxuICAgIGZpbmFsX3Jlc3VsdHM8LXJiaW5kKGZpbmFsX3Jlc3VsdHMsIG1lcmdlZClcbiAgfSAgIGVsc2Uge1xuICAgIHByaW50KFwibm8gY29ycmVsYXRpb25zIGZvciB0aGlzIHZhcmlhYmxlXCIpXG4gIH1cbiAgXG4gIHByaW50KHBhc3RlKFwiZmluaXNoZWQgXCIsdHJlYXRtZW50c1tpXSxzZXA9XCJcIikpXG59XG5cbiMgSW4gdGhlIGZvbGxvd2luZyBsaW5lLCB5b3UgZG9uJ3QgaGF2ZSB0byB1c2UgdXNlIHJobyA+PSAwLjkuIFxuIyBJZiB5b3VyIGZpbmFsX3Jlc3VsdHMgdGFibGUgaGFzIGxlc3MgdGhhbiA1MDAgcm93cywgXG4jIHRoZW4gSSBjb25zaWRlciB0aGF0IG5vdCB0b28gbWFueSBhbmQgdGhlcmUncyBubyBuZWVkIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4jIElmIHlvdSBkb24ndCB3YW50IHRvIGZpbHRlciwganVzdCB1c2UgXG5zdHJvbmdfcmVzdWx0cyA8LSBmaW5hbF9yZXN1bHRzXG5cbiMgSWYgeW91IGhhdmUgdG9vIG1hbnkgY29ycmVsYXRpb25zIGFuZCBuZWVkIHRvIHNpbXBsaWZ5LCBcbiMgY29uc2lkZXIgcnVubmluZyB0aGUgZm9sbG93aW5nIGxpbmUsIGFuZCBjaG9vc2UgYW4gYXBwcm9wcmlhdGUgY3V0b2ZmIGZvciByaG8uXG4jIFRoaXMgbGluZSB3aWxsIGtlZXAgYm90aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgY29ycmVsYXRpb25zLiBhYnMoKSBtZWFucyBhYnNvbHV0ZSB2YWx1ZVxuI3N0cm9uZ19yZXN1bHRzPC1zdWJzZXQoZmluYWxfcmVzdWx0cywgYWJzKHJobykgPj0gMC45KVxuXG5cbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuIyBJZiB5b3Ugd2FudCB0byBzZWUgdGhlIGNvcnJlbGF0aW9uIHNjYXR0ZXJwbG90IG9mIFxuIyB0d28gc2lnbmlmaWNhbnQgQVNWc1xuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cblxudHJ0X0FTVnM8LXN1YnNldChkYXRhc2V0LCBnZXQobXlfY29sdW1uKT09dHJlYXRtZW50c1sxXSlcblxuY29sbmFtZXModHJ0X0FTVnNbMToxMF0pXG5oZWFkKGZpbmFsX3Jlc3VsdHMpXG5nZ3Bsb3QodHJ0X0FTVnMsIGFlcyh4ID0gQVNWMiwgeSA9IEFTVjQpKSArXG4gIGdlb21fcG9pbnQoKVxuXG5cblxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4jIElmIHlvdSB3YW50IHRvIHNlZSB0aGUgdGhlIHRheG9ub21pYyBhc3NpZ25tZW50IG9mICBcbiMgdGhlc2Ugc2lnbmlmaWNhbnQgQVNWc1xuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRheG9ub215PC1yZWFkX3F6YShcInRheG9ub215LnF6YVwiKVxuaGVhZCh0YXhvbm9teSRkYXRhKVxuXG50YXguY2xlYW48LXBhcnNlX3RheG9ub215KHRheG9ub215JGRhdGEpXG5oZWFkKHRheC5jbGVhbilcblxuI0FsbCB0aGlzIGlzIE9LIGV4Y2VwdCB0aGF0IGluIGZ1dHVyZSB1c2Ugb2YgdGhlIHRheG9ub215IHRhYmxlLCBcbiN0aGVzZSBBU1ZzIHdpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBjbGFzc2lmaWVkLiBXaHkgXG4jYXJlIEFTVnMgbm90IGNsYXNzaWZpZWQ/IEl0cyBiZWNhdXNlIHRoZXJlIGlzIG5vdCBhIGNsb3NlIGVub3VnaCBcbiNtYXRjaCBpbiB0aGUgZGF0YWJhc2UuIEp1c3QgYmVjYXVzZSB0aGVyZSBpcyBub3QgYSBnb29kIG1hdGNoIGluIFxuI3RoZSBkYXRhYmFzZSBkb2VzIG5vdCBtZWFuIHRoZXkgZG9u4oCZdCBleGlzdCwgc28gSSB3YW50ZWQgdG8gbWFrZSBcbiNzdXJlIHRoaXMgZGF0YSB3YXMgbm90IGxvc3QuIFNvIGluIG15IG5ldyBjb2RlLCAgXG4jSSBtYWtlIGl0IHNvIHRoYXQgQVNWcyB0aGF0IGFyZSB1bmNsYXNzaWZpZWQgYXQgYW55IGxldmVsIGFyZSBcbiNjbGFzc2lmaWVkIGFzIHRoZSBsb3dlc3QgdGF4b25vbWljIGxldmVsIGZvciB3aGljaCB0aGVyZSBpcyBhIFxuI2NsYXNzaWZpY2F0aW9uLlxuI05leHQsIGFsbCB0aGVzZSBgTkFgIGNsYXNzaWZpY2F0aW9ucyB3aXRoIHRoZSBsYXN0IGxldmVsIHRoYXQgd2FzIFxuI2NsYXNzaWZpZWRcblxudGF4LmNsZWFuW2lzLm5hKHRheC5jbGVhbildIDwtIFwiXCJcbmZvciAoaSBpbiAxOm5yb3codGF4LmNsZWFuKSl7XG4gIGlmICh0YXguY2xlYW5baSwyXSA9PSBcIlwiKXtcbiAgICBraW5nZG9tIDwtIHBhc3RlKFwidW5jbGFzc2lmaWVkX1wiLCB0YXguY2xlYW5baSwxXSwgc2VwID0gXCJcIilcbiAgICB0YXguY2xlYW5baSwgMjo3XSA8LSBraW5nZG9tXG4gIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksM10gPT0gXCJcIil7XG4gICAgcGh5bHVtIDwtIHBhc3RlKFwidW5jbGFzc2lmaWVkX1wiLCB0YXguY2xlYW5baSwyXSwgc2VwID0gXCJcIilcbiAgICB0YXguY2xlYW5baSwgMzo3XSA8LSBwaHlsdW1cbiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw0XSA9PSBcIlwiKXtcbiAgICBjbGFzcyA8LSBwYXN0ZShcInVuY2xhc3NpZmllZF9cIiwgdGF4LmNsZWFuW2ksM10sIHNlcCA9IFwiXCIpXG4gICAgdGF4LmNsZWFuW2ksIDQ6N10gPC0gY2xhc3NcbiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw1XSA9PSBcIlwiKXtcbiAgICBvcmRlciA8LSBwYXN0ZShcInVuY2xhc3NpZmllZF9cIiwgdGF4LmNsZWFuW2ksNF0sIHNlcCA9IFwiXCIpXG4gICAgdGF4LmNsZWFuW2ksIDU6N10gPC0gb3JkZXJcbiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw2XSA9PSBcIlwiKXtcbiAgICBmYW1pbHkgPC0gcGFzdGUoXCJ1bmNsYXNzaWZpZWRfXCIsIHRheC5jbGVhbltpLDVdLCBzZXAgPSBcIlwiKVxuICAgIHRheC5jbGVhbltpLCA2OjddIDwtIGZhbWlseVxuICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDddID09IFwiXCIpe1xuICAgIHRheC5jbGVhbiRTcGVjaWVzW2ldIDwtIHBhc3RlKFwidW5jbGFzc2lmaWVkX1wiLHRheC5jbGVhbiRHZW51c1tpXSwgc2VwID0gXCJfXCIpXG4gIH1cbn1cblxuc3Ryb25nX3Jlc3VsdHNfdGF4YSA8LSBtZXJnZShzdHJvbmdfcmVzdWx0cywgQVNWa2V5LCBieS54ID0gXCJWYXIxXCIsIGJ5LnkgPSBcIkFTVm5vc1wiKVxuc3Ryb25nX3Jlc3VsdHNfdGF4YSA8LSBtZXJnZShzdHJvbmdfcmVzdWx0c190YXhhLCBBU1ZrZXksIGJ5LnggPSBcIlZhcjJcIiwgYnkueSA9IFwiQVNWbm9zXCIpXG5zdHJvbmdfcmVzdWx0c190YXhhIDwtIG1lcmdlKHN0cm9uZ19yZXN1bHRzX3RheGEsIHRheC5jbGVhbiwgYnkueCA9IFwiQVNWc3RyaW5nLnhcIiwgYnkueSA9IDApXG5zdHJvbmdfcmVzdWx0c190YXhhIDwtIG1lcmdlKHN0cm9uZ19yZXN1bHRzX3RheGEsIHRheC5jbGVhbiwgYnkueCA9IFwiQVNWc3RyaW5nLnlcIiwgYnkueSA9IDApXG5cbndyaXRlLmNzdihzdHJvbmdfcmVzdWx0c190YXhhLCBcImFscGhhX2RpdmVyc2l0eV9wbG90cy9jb29jY3VyZW5jZS1zdHJvbmctcmVzdWx0cy10YXhhLmNzdlwiLCByb3cubmFtZXMgPSBGKVxud3JpdGUuY3N2KHN1YnNldChzdHJvbmdfcmVzdWx0c190YXhhLCB0cnQ9PVwidHJlYXRtZW50XCIpLCBcImFscGhhX2RpdmVyc2l0eV9wbG90cy9jb2NjdXJlbmNlc3Ryb25nLXJlc3VsdHMtdGF4YS10cmVhdG1lbnQuY3N2XCIsIHJvdy5uYW1lcyA9IEYpXG53cml0ZS5jc3Yoc3Vic2V0KHN0cm9uZ19yZXN1bHRzX3RheGEsIHRydD09XCJCYXNhbFwiKSwgXCJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvc3Ryb25nLXJlc3VsdHMtdGF4YS1CYXNhbC5jc3ZcIiwgcm93Lm5hbWVzID0gRilcbndyaXRlLmNzdihzdWJzZXQoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgdHJ0PT1cIkJTZWEwNVwiKSwgXCJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvc3Ryb25nLXJlc3VsdHMtdGF4YS1CU2VhMDUuY3N2XCIsIHJvdy5uYW1lcyA9IEYpXG53cml0ZS5jc3Yoc3Vic2V0KHN0cm9uZ19yZXN1bHRzX3RheGEsIHRydD09XCJCU2VhMTBcIiksIFwiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL3N0cm9uZy1yZXN1bHRzLXRheGEtQlNlYTEwLmNzdlwiLCByb3cubmFtZXMgPSBGKVxud3JpdGUuY3N2KHN1YnNldChzdHJvbmdfcmVzdWx0c190YXhhLCB0cnQ9PVwiQlNlYTE1XCIpLCBcImFscGhhX2RpdmVyc2l0eV9wbG90cy9zdHJvbmctcmVzdWx0cy10YXhhLUJTZWExNS5jc3ZcIiwgcm93Lm5hbWVzID0gRilcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuIyBOb3cgeW91IGNhbiBpbXBvcnQgdGhlc2UgaW50byBjeXRvc2NhcGUgdG8gdmlzdWFsaXplIHRoZSBuZXR3b3JrXG4jT3BlbiBDeXRvc2NhcGVcbiNJbXBvcnQgTmV0d29yayBmcm9tIEZpbGUgc3lzdGVtXG4jQW55dGhpbmcgd2l0aCBhIC54IGluZGljYXRlIGFzIGEgXCJzb3VyY2Ugbm9kZSBhdHRyaWJ1dGVcIlxuI0FueXRoaW5nIHdpdGggYSAueSBpbmRpY2F0ZSBhcyBhIFwidGFyZ2V0IG5vZGUgYXR0cmlidXRlXCJcbiNcIlZhcjJcIiBpbmRpY2F0ZSBhcyBcIlRhcmdldCBOb2RlXCJcbiNcIlZhcjFcIiBpbmRpY2F0ZSBhcyBcIlNvdXJjZSBOb2RlXCJcbiN0aGUgcmVzdCBsZWF2ZSBhcyBcImVkZ2UgYXR0cmlidXRlXCJcbiNFZGl0PlJlbW92ZSBEdXBsaWNhdGVkIEVkZ2VzLCBjbGljayBcIklnbm9yZSBlZGdlIGRpcmVjdGlvblwiXG4jVG8gbWFudWFsbHkgYXNzaWduIGFlc3RoZXRpY3MsIHVzZSBcIkRpc2NyZXRlIE1hcHBpbmdcIlxuI1xuI1xuI1xuI1xuI1xuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuYGBgIn0= -->
<pre class="r"><code>#cooccurence
library(Hmisc)
library(plyr)
library(reshape2)
library(qiime2R)
library(igraph)
library(fdrtool)


#####################################################################
ASVs &lt;- read_qza(&quot;rarefied_table.qza&quot;)
ASV_table &lt;- as.data.frame(ASVs$data)

ASV_table$ASVnos &lt;- paste0(&quot;ASV&quot;, 1:nrow(ASV_table))
ASV_table$ASVstring &lt;- rownames(ASV_table)
rownames(ASV_table) &lt;- ASV_table$ASVnos
ASVkey &lt;- ASV_table[, (ncol(ASV_table)-1):ncol(ASV_table)]
ASV_table &lt;- ASV_table[,-(ncol(ASV_table)-1):-ncol(ASV_table)]
######################################################################

dataset &lt;- as.data.frame(t(ASV_table))


# we are going to create a network per treatment
head(dataset[,1:10])

metadata&lt;-read_q2metadata(&quot;project_metadata.txt&quot;)
str(metadata)
colnames(metadata)[2] = &quot;time-point&quot;
colnames(metadata)[6] = &quot;treatment&quot;

dataset &lt;- merge(metadata, dataset, by.x = &quot;SampleID&quot;, by.y = 0)
treatments&lt;-as.vector(unique(dataset$treatment))
datasetn&lt;-dataset
datasetn[datasetn==0]&lt;-NA

#i = 1

summary(metadata$treatment)

my_column &lt;- &quot;treatment&quot;
n1 &lt;- 8
n2 &lt;- 8
n3 &lt;- 8
n4 &lt;- 8

num_metadata_columns &lt;- ncol(metadata)

q_cutoff &lt;- 0.05

final_results&lt;-data.frame()

for(i in 1:length(treatments)){
  
  #subset the data for a particular treatment YOU MUST ENTER THE HEADER OF THE COLUMN THAT HAS THE DIFFERENT TREATMENTS IN THIS CASE treatment
  
  print(paste(&quot;reading &quot;,treatments[i],sep=&quot;&quot;))
  temp&lt;-subset(dataset, get(my_column)==treatments[i])
  tempn&lt;-subset(datasetn, get(my_column)==treatments[i])
  print(paste(&quot;finished reading &quot;,treatments[i],sep=&quot;&quot;))
  # making an object that has all the results in it (both rho and P values)
  results&lt;-rcorr(as.matrix(temp[,-c(1:num_metadata_columns)]),type=&quot;spearman&quot;) ## use the &quot;-c&quot; parameter to remove metadata columns
  resultsn&lt;-rcorr(as.matrix(tempn[,-c(1:num_metadata_columns)]),type=&quot;spearman&quot;)
  
  #make two seperate objects for p-value and correlation coefficients
  rhos&lt;-results$r
  ps&lt;-results$P
  ns&lt;-resultsn$n
  # going to melt these objects to &#39;long form&#39; where the first two columns make up the pairs of OTUs, I am also removing NA&#39;s as they are self-comparisons, not enough data, other bad stuff
  ps_melt&lt;-na.omit(melt(ps))
  #creating a qvalue based on FDR
  ps_melt$qval&lt;-p.adjust(ps_melt$value, method = &quot;BH&quot;)
  #making column names more relevant
  
  names(ps_melt)[3]&lt;-&quot;pval&quot;
  # if you are of the opinion that it is a good idea to subset your network based on adjusted P-values (qval in this case), you can then subset here
  ps_sub&lt;-subset(ps_melt, qval &lt; q_cutoff)
  
  # now melting the rhos, note the similarity between ps_melt and rhos_melt
  rhos_melt&lt;-na.omit(melt(rhos))
  names(rhos_melt)[3]&lt;-&quot;rho&quot;
  
  # now melting the ns
  ns_melt&lt;-(melt(ns))
  names(ns_melt)[3]&lt;-&quot;n&quot;
  
  #merging together and remove negative rhos
  merged&lt;-merge(ps_sub,rhos_melt,by=c(&quot;Var1&quot;,&quot;Var2&quot;))
  if (treatments[i]==treatments[1]) {
    merged&lt;-merge(merged,subset(ns_melt, n &gt; n1),by=c(&quot;Var1&quot;,&quot;Var2&quot;))
  }   else if (treatments[i]==treatments[2]) {
    merged&lt;-merge(merged,subset(ns_melt, n &gt; n2),by=c(&quot;Var1&quot;,&quot;Var2&quot;))
  }   else if (treatments[i]==treatments[3]) {
    merged&lt;-merge(merged,subset(ns_melt, n &gt; n3),by=c(&quot;Var1&quot;,&quot;Var2&quot;))
  }   else if (treatments[i]==treatments[4]) {
    merged&lt;-merge(merged,subset(ns_melt, n &gt; n4),by=c(&quot;Var1&quot;,&quot;Var2&quot;))
  }   else
    print(&quot;Somethings wrong with your treatment designations. Please Check!!&quot;)
  
  if (nrow(merged) &gt; 0) {
    merged$trt&lt;-treatments[i]
    final_results&lt;-rbind(final_results, merged)
  }   else {
    print(&quot;no correlations for this variable&quot;)
  }
  
  print(paste(&quot;finished &quot;,treatments[i],sep=&quot;&quot;))
}

# In the following line, you don&#39;t have to use use rho &gt;= 0.9. 
# If your final_results table has less than 500 rows, 
# then I consider that not too many and there&#39;s no need to filter your results.
# If you don&#39;t want to filter, just use 
strong_results &lt;- final_results

# If you have too many correlations and need to simplify, 
# consider running the following line, and choose an appropriate cutoff for rho.
# This line will keep both positive and negative correlations. abs() means absolute value
#strong_results&lt;-subset(final_results, abs(rho) &gt;= 0.9)


###############################################################
# If you want to see the correlation scatterplot of 
# two significant ASVs
###############################################################


trt_ASVs&lt;-subset(dataset, get(my_column)==treatments[1])

colnames(trt_ASVs[1:10])
head(final_results)
ggplot(trt_ASVs, aes(x = ASV2, y = ASV4)) +
  geom_point()



###############################################################
# If you want to see the the taxonomic assignment of  
# these significant ASVs
###############################################################

taxonomy&lt;-read_qza(&quot;taxonomy.qza&quot;)
head(taxonomy$data)

tax.clean&lt;-parse_taxonomy(taxonomy$data)
head(tax.clean)

#All this is OK except that in future use of the taxonomy table, 
#these ASVs will be ignored because they are not classified. Why 
#are ASVs not classified? Its because there is not a close enough 
#match in the database. Just because there is not a good match in 
#the database does not mean they dont exist, so I wanted to make 
#sure this data was not lost. So in my new code,  
#I make it so that ASVs that are unclassified at any level are 
#classified as the lowest taxonomic level for which there is a 
#classification.
#Next, all these `NA` classifications with the last level that was 
#classified

tax.clean[is.na(tax.clean)] &lt;- &quot;&quot;
for (i in 1:nrow(tax.clean)){
  if (tax.clean[i,2] == &quot;&quot;){
    kingdom &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,1], sep = &quot;&quot;)
    tax.clean[i, 2:7] &lt;- kingdom
  } else if (tax.clean[i,3] == &quot;&quot;){
    phylum &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,2], sep = &quot;&quot;)
    tax.clean[i, 3:7] &lt;- phylum
  } else if (tax.clean[i,4] == &quot;&quot;){
    class &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,3], sep = &quot;&quot;)
    tax.clean[i, 4:7] &lt;- class
  } else if (tax.clean[i,5] == &quot;&quot;){
    order &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,4], sep = &quot;&quot;)
    tax.clean[i, 5:7] &lt;- order
  } else if (tax.clean[i,6] == &quot;&quot;){
    family &lt;- paste(&quot;unclassified_&quot;, tax.clean[i,5], sep = &quot;&quot;)
    tax.clean[i, 6:7] &lt;- family
  } else if (tax.clean[i,7] == &quot;&quot;){
    tax.clean$Species[i] &lt;- paste(&quot;unclassified_&quot;,tax.clean$Genus[i], sep = &quot;_&quot;)
  }
}

strong_results_taxa &lt;- merge(strong_results, ASVkey, by.x = &quot;Var1&quot;, by.y = &quot;ASVnos&quot;)
strong_results_taxa &lt;- merge(strong_results_taxa, ASVkey, by.x = &quot;Var2&quot;, by.y = &quot;ASVnos&quot;)
strong_results_taxa &lt;- merge(strong_results_taxa, tax.clean, by.x = &quot;ASVstring.x&quot;, by.y = 0)
strong_results_taxa &lt;- merge(strong_results_taxa, tax.clean, by.x = &quot;ASVstring.y&quot;, by.y = 0)

write.csv(strong_results_taxa, &quot;alpha_diversity_plots/cooccurence-strong-results-taxa.csv&quot;, row.names = F)
write.csv(subset(strong_results_taxa, trt==&quot;treatment&quot;), &quot;alpha_diversity_plots/coccurencestrong-results-taxa-treatment.csv&quot;, row.names = F)
write.csv(subset(strong_results_taxa, trt==&quot;Basal&quot;), &quot;alpha_diversity_plots/strong-results-taxa-Basal.csv&quot;, row.names = F)
write.csv(subset(strong_results_taxa, trt==&quot;BSea05&quot;), &quot;alpha_diversity_plots/strong-results-taxa-BSea05.csv&quot;, row.names = F)
write.csv(subset(strong_results_taxa, trt==&quot;BSea10&quot;), &quot;alpha_diversity_plots/strong-results-taxa-BSea10.csv&quot;, row.names = F)
write.csv(subset(strong_results_taxa, trt==&quot;BSea15&quot;), &quot;alpha_diversity_plots/strong-results-taxa-BSea15.csv&quot;, row.names = F)
############################################################
# Now you can import these into cytoscape to visualize the network
#Open Cytoscape
#Import Network from File system
#Anything with a .x indicate as a &quot;source node attribute&quot;
#Anything with a .y indicate as a &quot;target node attribute&quot;
#&quot;Var2&quot; indicate as &quot;Target Node&quot;
#&quot;Var1&quot; indicate as &quot;Source Node&quot;
#the rest leave as &quot;edge attribute&quot;
#Edit&gt;Remove Duplicated Edges, click &quot;Ignore edge direction&quot;
#To manually assign aesthetics, use &quot;Discrete Mapping&quot;
#
#
#
#
#
######################################################################</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>Taxa Plot</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxucHNfYmFyX3Bsb3RcblxuYGBgIn0= -->
<pre class="r"><code>ps_bar_plot
</code></pre>
<!-- rnb-source-end -->
<!-- rnb-output-begin eyJkYXRhIjoicGh5bG9zZXEtY2xhc3MgZXhwZXJpbWVudC1sZXZlbCBvYmplY3Rcbm90dV90YWJsZSgpICAgT1RVIFRhYmxlOiAgICAgICAgIFsgNzA0IHRheGEgYW5kIDY0IHNhbXBsZXMgXVxuc2FtcGxlX2RhdGEoKSBTYW1wbGUgRGF0YTogICAgICAgWyA2NCBzYW1wbGVzIGJ5IDUgc2FtcGxlIHZhcmlhYmxlcyBdXG50YXhfdGFibGUoKSAgIFRheG9ub215IFRhYmxlOiAgICBbIDcwNCB0YXhhIGJ5IDcgdGF4b25vbWljIHJhbmtzIF1cbiJ9 -->
<pre><code>phyloseq-class experiment-level object
otu_table()   OTU Table:         [ 704 taxa and 64 samples ]
sample_data() Sample Data:       [ 64 samples by 5 sample variables ]
tax_table()   Taxonomy Table:    [ 704 taxa by 7 taxonomic ranks ]</code></pre>
<!-- rnb-output-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>DESeq</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuZGlhZ2RkczIgPC0gREVTZXEoZGlhZ2RkczIsIHRlc3Q9XCJXYWxkXCIsIGZpdFR5cGU9XCJwYXJhbWV0cmljXCIpXG5cbmBgYCJ9 -->
<pre class="r"><code>diagdds2 &lt;- DESeq(diagdds2, test=&quot;Wald&quot;, fitType=&quot;parametric&quot;)
</code></pre>
<!-- rnb-source-end -->
<!-- rnb-output-begin eyJkYXRhIjoiZXN0aW1hdGluZyBzaXplIGZhY3RvcnNcbmVzdGltYXRpbmcgZGlzcGVyc2lvbnNcbmdlbmUtd2lzZSBkaXNwZXJzaW9uIGVzdGltYXRlc1xubWVhbi1kaXNwZXJzaW9uIHJlbGF0aW9uc2hpcFxuLS0gbm90ZTogZml0VHlwZT0ncGFyYW1ldHJpYycsIGJ1dCB0aGUgZGlzcGVyc2lvbiB0cmVuZCB3YXMgbm90IHdlbGwgY2FwdHVyZWQgYnkgdGhlXG4gICBmdW5jdGlvbjogeSA9IGEveCArIGIsIGFuZCBhIGxvY2FsIHJlZ3Jlc3Npb24gZml0IHdhcyBhdXRvbWF0aWNhbGx5IHN1YnN0aXR1dGVkLlxuICAgc3BlY2lmeSBmaXRUeXBlPSdsb2NhbCcgb3IgJ21lYW4nIHRvIGF2b2lkIHRoaXMgbWVzc2FnZSBuZXh0IHRpbWUuXG5maW5hbCBkaXNwZXJzaW9uIGVzdGltYXRlc1xuZml0dGluZyBtb2RlbCBhbmQgdGVzdGluZ1xuLS0gcmVwbGFjaW5nIG91dGxpZXJzIGFuZCByZWZpdHRpbmcgZm9yIDY5IGdlbmVzXG4tLSBERVNlcSBhcmd1bWVudCAnbWluUmVwbGljYXRlc0ZvclJlcGxhY2UnID0gNyBcbi0tIG9yaWdpbmFsIGNvdW50cyBhcmUgcHJlc2VydmVkIGluIGNvdW50cyhkZHMpXG5lc3RpbWF0aW5nIGRpc3BlcnNpb25zXG5maXR0aW5nIG1vZGVsIGFuZCB0ZXN0aW5nXG4ifQ== -->
<pre><code>estimating size factors
estimating dispersions
gene-wise dispersion estimates
mean-dispersion relationship
-- note: fitType=&#39;parametric&#39;, but the dispersion trend was not well captured by the
   function: y = a/x + b, and a local regression fit was automatically substituted.
   specify fitType=&#39;local&#39; or &#39;mean&#39; to avoid this message next time.
final dispersion estimates
fitting model and testing
-- replacing outliers and refitting for 69 genes
-- DESeq argument &#39;minReplicatesForReplace&#39; = 7 
-- original counts are preserved in counts(dds)
estimating dispersions
fitting model and testing</code></pre>
<!-- rnb-output-end -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuZGlhZ2RkczIgPC0gREVTZXEoZGlhZ2RkczIsIHRlc3Q9XCJXYWxkXCIsIGZpdFR5cGU9XCJwYXJhbWV0cmljXCIpXG5gYGAifQ== -->
<pre class="r"><code>diagdds2 &lt;- DESeq(diagdds2, test=&quot;Wald&quot;, fitType=&quot;parametric&quot;)</code></pre>
<!-- rnb-source-end -->
<!-- rnb-output-begin eyJkYXRhIjoidXNpbmcgcHJlLWV4aXN0aW5nIHNpemUgZmFjdG9yc1xuZXN0aW1hdGluZyBkaXNwZXJzaW9uc1xuZm91bmQgYWxyZWFkeSBlc3RpbWF0ZWQgZGlzcGVyc2lvbnMsIHJlcGxhY2luZyB0aGVzZVxuZ2VuZS13aXNlIGRpc3BlcnNpb24gZXN0aW1hdGVzXG5tZWFuLWRpc3BlcnNpb24gcmVsYXRpb25zaGlwXG4tLSBub3RlOiBmaXRUeXBlPSdwYXJhbWV0cmljJywgYnV0IHRoZSBkaXNwZXJzaW9uIHRyZW5kIHdhcyBub3Qgd2VsbCBjYXB0dXJlZCBieSB0aGVcbiAgIGZ1bmN0aW9uOiB5ID0gYS94ICsgYiwgYW5kIGEgbG9jYWwgcmVncmVzc2lvbiBmaXQgd2FzIGF1dG9tYXRpY2FsbHkgc3Vic3RpdHV0ZWQuXG4gICBzcGVjaWZ5IGZpdFR5cGU9J2xvY2FsJyBvciAnbWVhbicgdG8gYXZvaWQgdGhpcyBtZXNzYWdlIG5leHQgdGltZS5cbmZpbmFsIGRpc3BlcnNpb24gZXN0aW1hdGVzXG5maXR0aW5nIG1vZGVsIGFuZCB0ZXN0aW5nXG4tLSByZXBsYWNpbmcgb3V0bGllcnMgYW5kIHJlZml0dGluZyBmb3IgNjkgZ2VuZXNcbi0tIERFU2VxIGFyZ3VtZW50ICdtaW5SZXBsaWNhdGVzRm9yUmVwbGFjZScgPSA3IFxuLS0gb3JpZ2luYWwgY291bnRzIGFyZSBwcmVzZXJ2ZWQgaW4gY291bnRzKGRkcylcbmVzdGltYXRpbmcgZGlzcGVyc2lvbnNcbmZpdHRpbmcgbW9kZWwgYW5kIHRlc3RpbmdcbiJ9 -->
<pre><code>using pre-existing size factors
estimating dispersions
found already estimated dispersions, replacing these
gene-wise dispersion estimates
mean-dispersion relationship
-- note: fitType=&#39;parametric&#39;, but the dispersion trend was not well captured by the
   function: y = a/x + b, and a local regression fit was automatically substituted.
   specify fitType=&#39;local&#39; or &#39;mean&#39; to avoid this message next time.
final dispersion estimates
fitting model and testing
-- replacing outliers and refitting for 69 genes
-- DESeq argument &#39;minReplicatesForReplace&#39; = 7 
-- original counts are preserved in counts(dds)
estimating dispersions
fitting model and testing</code></pre>
<!-- rnb-output-end -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuYWxwaGEgPC0gMC4wNVxucnVuX2Rlc2VxMiA8LSBmdW5jdGlvbih0cmVhdG1lbnQsIEJhc2FsLCBCU2VhMDUsIEJTZWExMCwgQlNlYTE1KSB7XG5teV9jb250cmFzdCA8LSBjKFwidHJlYXRtZW50XCIsIEJhc2FsLCBCU2VhMDUpIFxuIHJlcyA8LSByZXN1bHRzKGRpYWdkZHMyLCBjb250cmFzdCA9IG15X2NvbnRyYXN0LCBjb29rc0N1dG9mZiA9IEZBTFNFKVxuIHNpZ3RhYjIgPC0gcmVzW3doaWNoKHJlcyRwYWRqIDwgYWxwaGEpLCBdXG4gIHNpZ3RhYjIgPC0gY2JpbmQoYXMoc2lndGFiMiwgXCJkYXRhLmZyYW1lXCIpLCBhcyh0YXhfdGFibGUocHMyMilbcm93bmFtZXMoc2lndGFiMiksIF0sIFwibWF0cml4XCIpKVxuXG4gIHRoZW1lX3NldCh0aGVtZV9idygpKVxuICBzY2FsZV9maWxsX2Rpc2NyZXRlIDwtIGZ1bmN0aW9uKHBhbG5hbWUgPSBcIlNldDFcIiwgLi4uKSB7XG4gICAgc2NhbGVfZmlsbF9icmV3ZXIocGFsZXR0ZSA9IHBhbG5hbWUsIC4uLilcbiAgfVxuICBcbiAgeCA8LSB0YXBwbHkoc2lndGFiMiRsb2cyRm9sZENoYW5nZSwgc2lndGFiMiRHZW51cywgZnVuY3Rpb24oeCkgbWF4KHgpKVxuICB4IDwtIHNvcnQoeCwgVFJVRSlcbiAgc2lndGFiMiRHZW51cyA8LSBmYWN0b3IoYXMuY2hhcmFjdGVyKHNpZ3RhYjIkR2VudXMpLCBsZXZlbHM9bmFtZXMoeCkpXG4gIFxuICBERVNlcV9maWcgPC0gZ2dwbG90KHNpZ3RhYjIsIGFlcyh4PUdlbnVzLCB5PWxvZzJGb2xkQ2hhbmdlLCBjb2xvcj1QaHlsdW0pKSArIFxuICAgIGdlb21fcG9pbnQoc2l6ZT0zKSArIFxuICAgIHlsYWIocGFzdGUwKFwiKFwiLCBCYXNhbCwgXCIvXCIsIEJTZWEwNSwgXCIpXFxuXCIsIFwibG9nMkZvbGRDaGFuZ2VcIikpICtcbiAgICBjb29yZF9mbGlwKCkgK1xuICAgIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBteV9jb2xvcnNbYyg0LDYsOCwxMCwxMiwxNCwxNiwxOCwyMCldKSArXG4gICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSAtOTAsIGhqdXN0ID0gMCwgdmp1c3Q9MC41KSlcbiAgXG4gIGdnc2F2ZShwYXN0ZTAoXCJEZXNlcWRheS9ERVNlcTItXCIsIEJhc2FsLCBcIi1cIiwgQlNlYTA1LCBcIi1kYXkyMi5wbmdcIiksIERFU2VxX2ZpZywgaGVpZ2h0ID0gMTAsIHdpZHRoID0gNylcbn1cbmBgYCJ9 -->
<pre class="r"><code>alpha &lt;- 0.05
run_deseq2 &lt;- function(treatment, Basal, BSea05, BSea10, BSea15) {
my_contrast &lt;- c(&quot;treatment&quot;, Basal, BSea05) 
 res &lt;- results(diagdds2, contrast = my_contrast, cooksCutoff = FALSE)
 sigtab2 &lt;- res[which(res$padj &lt; alpha), ]
  sigtab2 &lt;- cbind(as(sigtab2, &quot;data.frame&quot;), as(tax_table(ps22)[rownames(sigtab2), ], &quot;matrix&quot;))

  theme_set(theme_bw())
  scale_fill_discrete &lt;- function(palname = &quot;Set1&quot;, ...) {
    scale_fill_brewer(palette = palname, ...)
  }
  
  x &lt;- tapply(sigtab2$log2FoldChange, sigtab2$Genus, function(x) max(x))
  x &lt;- sort(x, TRUE)
  sigtab2$Genus &lt;- factor(as.character(sigtab2$Genus), levels=names(x))
  
  DESeq_fig &lt;- ggplot(sigtab2, aes(x=Genus, y=log2FoldChange, color=Phylum)) + 
    geom_point(size=3) + 
    ylab(paste0(&quot;(&quot;, Basal, &quot;/&quot;, BSea05, &quot;)\n&quot;, &quot;log2FoldChange&quot;)) +
    coord_flip() +
    scale_color_manual(values = my_colors[c(4,6,8,10,12,14,16,18,20)]) +
    theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5))
  
  ggsave(paste0(&quot;Deseqday/DESeq2-&quot;, Basal, &quot;-&quot;, BSea05, &quot;-day22.png&quot;), DESeq_fig, height = 10, width = 7)
}</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>Co-abundant groups of taxa</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-plot-begin eyJoZWlnaHQiOjQzMi42MzI5LCJ3aWR0aCI6NzAwLCJzaXplX2JlaGF2aW9yIjowLCJjb25kaXRpb25zIjpbXX0= -->
<p><img src="data:image/png;base64,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" /></p>
<!-- rnb-plot-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>Random Forest</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuI1JhbmRvbSBGb3Jlc3QgOiBodHRwczovL3JwdWJzLmNvbS9taWNoYmVyci9yYW5kb21mb3Jlc3RtaWNyb2JlXG5saWJyYXJ5KGdncGxvdDIpXG5saWJyYXJ5KHZlZ2FuKVxubGlicmFyeShkcGx5cilcbmxpYnJhcnkobWFncml0dHIpXG5saWJyYXJ5KHNjYWxlcylcbmxpYnJhcnkoZ3JpZClcbmxpYnJhcnkocmVzaGFwZTIpXG5saWJyYXJ5KHBoeWxvc2VxKVxubGlicmFyeShyYW5kb21Gb3Jlc3QpXG5saWJyYXJ5KGtuaXRyKVxubGlicmFyeSh2aXJpZGlzKVxuXG5cbiN1c2luZyB0aGUgUFMgZ2VuZXJhdGVkIGFib3ZlXG5wc2VxIDwtIHBzXG5wc2VxIDwtIGFnZ3JlZ2F0ZV9yYXJlKHBzZXEsIGxldmVsID0gXCJHZW51c1wiLCBkZXRlY3Rpb24gPSAxLzEwMCwgcHJldmFsZW5jZSA9IDUwLzEwMClcblxuIyBHZW5lcmF0ZSA1MCBjb2xvcnMgZnJvbSB0aGUgdmlyaWRpcyBwYWxldHRlXG5waHkgPC0gdmlyaWRpcyg1MClcbnBoeSRjb2xvcnMgPC0gY29sb3JzXG5cbm50YXhhKHBzZXEpXG4jIFNldCBwcnVuZXNjYWxlIFxucHJ1bmVzY2FsZSA9IDAuMDAwMVxuXG4jIFNldCBtaW5saWJcbm1pbmxpYiA9IDEzOTAwICNncmVhdGVyIHRoYW4gbWluZVxuXG4jIFBydW5lIG91dCByYXJlIE9UVXMgYnkgbWVhbiByZWxhdGl2ZSBhYnVuZGFuY2Ugc2V0IGJ5IHBydW5lc2NhbGVcbnRheC5tZWFuIDwtIHRheGFfc3Vtcyhwc2VxKS9uc2FtcGxlcyhwc2VxKVxuc2l0ZXMucHJ1bmUgPC0gcHJ1bmVfdGF4YSh0YXgubWVhbiA+IHBydW5lc2NhbGUqbWlubGliLCBwc2VxKVxuXG5zaXRlcy5wcnVuZVxuXG4jIE1ha2UgYSBkYXRhZnJhbWUgb2YgdHJhaW5pbmcgcHNhIHdpdGggT1RVcyBhcyBjb2x1bW4gYW5kIHNhbXBsZXMgYXMgcm93c1xucHJlZGljdG9ycyA8LSB0KG90dV90YWJsZShwc2VxKSlcbmRpbShwcmVkaWN0b3JzKVxucHJlZGljdG9yc1xuI1dlIGhhdmUgNjQgc2FtcGxlcyBhbmQgMzI2IE9UVXNcbiMgTWFrZSBvbmUgY29sdW1uIGZvciBvdXIgb3V0Y29tZS9yZXNwb25zZSB2YXJpYWJsZSBcbnJlc3BvbnNlIDwtIGFzLmZhY3RvcihzYW1wbGVfZGF0YShzaXRlcy5wcnVuZSkkdHJlYXRtZW50KVxuXG4jIENvbWJpbmUgdGhlbSBpbnRvIDEgcHNhIGZyYW1lXG5yZi5wc2EgPC0gZGF0YS5mcmFtZShyZXNwb25zZSwgcHJlZGljdG9ycylcblxuI3Jlc3VsdFxuc2V0LnNlZWQoMClcbnBzLmNsYXNzaWZ5IDwtIHJhbmRvbUZvcmVzdChyZXNwb25zZX4uLCBkYXRhID0gcmYucHNhLCBudHJlZSA9IDEwMClcbnByaW50KHBzLmNsYXNzaWZ5KVxuXG4jVGhlIG91dCBvZiBiYWcgZXJyb3IgaXMgNTQuNjklIC5cbiMgV2hhdCB2YXJpYWJsZXMgYXJlIHN0b3JlZCBpbiB0aGUgb3V0cHV0P1xubmFtZXMocHMuY2xhc3NpZnkpXG5cbiNwbG90c1xuXG4jIE1ha2UgYSBwc2EgZnJhbWUgd2l0aCBwcmVkaWN0b3IgbmFtZXMgYW5kIHRoZWlyIGltcG9ydGFuY2VcbmltcCA8LSBpbXBvcnRhbmNlKHBzLmNsYXNzaWZ5KVxuaW1wIDwtIGRhdGEuZnJhbWUocHJlZGljdG9ycyA9IHJvd25hbWVzKGltcCksIGltcClcblxuIyBPcmRlciB0aGUgcHJlZGljdG9yIGxldmVscyBieSBpbXBvcnRhbmNlXG5pbXAuc29ydCA8LSBhcnJhbmdlKGltcCwgZGVzYyhNZWFuRGVjcmVhc2VHaW5pKSlcbmltcC5zb3J0JHByZWRpY3RvcnMgPC0gZmFjdG9yKGltcC5zb3J0JHByZWRpY3RvcnMsIGxldmVscyA9IGltcC5zb3J0JHByZWRpY3RvcnMpXG5cbiMgU2VsZWN0IHRoZSB0b3AgMTAgcHJlZGljdG9yc1xuaW1wLjIwIDwtIGltcC5zb3J0WzE6MzAsIF1cblxuXG4jIGdncGxvdFxuUmFuZG9mb3JlIDwtIGdncGxvdChpbXAuMjAsIGFlcyh4ID0gcHJlZGljdG9ycywgeSA9IE1lYW5EZWNyZWFzZUdpbmkpKSArXG4gIGdlb21fYmFyKHN0YXQgPSBcImlkZW50aXR5XCIsIGZpbGwgPSBcImluZGlhbnJlZFwiKSArXG4gIGNvb3JkX2ZsaXAoKSArXG4gIGdndGl0bGUoXCJNb3N0IGltcG9ydGFudCBPVFVzIGZvciBjbGFzc2lmeWluZyBzYW1wbGVzIGJ5IHRyZWF0bWVudCBhbmQgdGltZVwiKVxuUmFuZG9mb3JlXG5cbmdnc2F2ZShcImFscGhhX2RpdmVyc2l0eV9wbG90cy9SYW5kb20gZm9yZXN0LnBuZ1wiLCBSYW5kb2ZvcmUsIHdpZHRoID0gMTIsIGhlaWdodCA9IDYsIGJnID0gXCJ3aGl0ZVwiKVxuYGBgIn0= -->
<pre class="r"><code>#Random Forest : https://rpubs.com/michberr/randomforestmicrobe
library(ggplot2)
library(vegan)
library(dplyr)
library(magrittr)
library(scales)
library(grid)
library(reshape2)
library(phyloseq)
library(randomForest)
library(knitr)
library(viridis)


#using the PS generated above
pseq &lt;- ps
pseq &lt;- aggregate_rare(pseq, level = &quot;Genus&quot;, detection = 1/100, prevalence = 50/100)

# Generate 50 colors from the viridis palette
phy &lt;- viridis(50)
phy$colors &lt;- colors

ntaxa(pseq)
# Set prunescale 
prunescale = 0.0001

# Set minlib
minlib = 13900 #greater than mine

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean &lt;- taxa_sums(pseq)/nsamples(pseq)
sites.prune &lt;- prune_taxa(tax.mean &gt; prunescale*minlib, pseq)

sites.prune

# Make a dataframe of training psa with OTUs as column and samples as rows
predictors &lt;- t(otu_table(pseq))
dim(predictors)
predictors
#We have 64 samples and 326 OTUs
# Make one column for our outcome/response variable 
response &lt;- as.factor(sample_data(sites.prune)$treatment)

# Combine them into 1 psa frame
rf.psa &lt;- data.frame(response, predictors)

#result
set.seed(0)
ps.classify &lt;- randomForest(response~., data = rf.psa, ntree = 100)
print(ps.classify)

#The out of bag error is 54.69% .
# What variables are stored in the output?
names(ps.classify)

#plots

# Make a psa frame with predictor names and their importance
imp &lt;- importance(ps.classify)
imp &lt;- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort &lt;- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors &lt;- factor(imp.sort$predictors, levels = imp.sort$predictors)

# Select the top 10 predictors
imp.20 &lt;- imp.sort[1:30, ]


# ggplot
Randofore &lt;- ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = &quot;identity&quot;, fill = &quot;indianred&quot;) +
  coord_flip() +
  ggtitle(&quot;Most important OTUs for classifying samples by treatment and time&quot;)
Randofore

ggsave(&quot;alpha_diversity_plots/Random forest.png&quot;, Randofore, width = 12, height = 6, bg = &quot;white&quot;)</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<p>PICRUST</p>
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxucnVuX2Rlc2VxMihcInRyZWF0bWVudFwiLCBcIkJhc2FsXCIsIFwiQlNlYTEwXCIpXG5cbmBgYCJ9 -->
<pre class="r"><code>run_deseq2(&quot;treatment&quot;, &quot;Basal&quot;, &quot;BSea10&quot;)
</code></pre>
<!-- rnb-source-end -->
<!-- rnb-output-begin eyJkYXRhIjoiJ2RhdGEuZnJhbWUnOlx0MCBvYnMuIG9mICA3IHZhcmlhYmxlczpcbiAkIGJhc2VNZWFuICAgICAgOiBudW0gXG4gJCBsb2cyRm9sZENoYW5nZTogbnVtIFxuICQgbGZjU0UgICAgICAgICA6IG51bSBcbiAkIHN0YXQgICAgICAgICAgOiBudW0gXG4gJCBwdmFsdWUgICAgICAgIDogbnVtIFxuICQgcGFkaiAgICAgICAgICA6IG51bSBcbiAkIHBhdGh3YXkgICAgICAgOiBjaHIgXG4nZGF0YS5mcmFtZSc6XHQyNzE0IG9icy4gb2YgIDIgdmFyaWFibGVzOlxuICQgVjE6IGNociAgXCIxMkRJQ0hMT1JFVEhERUctUFdZXCIgXCIxNERJQ0hMT1JCRU5aREVHLVBXWVwiIFwiMUNNRVQyLVBXWVwiIFwiMkFNSU5PQkVOWkRFRy1QV1lcIiAuLi5cbiAkIFYyOiBjaHIgIFwiMSwyLWRpY2hsb3JvZXRoYW5lIGRlZ3JhZGF0aW9uXCIgXCIxLDQtZGljaGxvcm9iZW56ZW5lIGRlZ3JhZGF0aW9uXCIgXCJOMTAtZm9ybXlsLXRldHJhaHlkcm9mb2xhdGUgYmlvc3ludGhlc2lzXCIgXCJhbnRocmFuaWxhdGUgZGVncmFkYXRpb24gSUlJIChhbmFlcm9iaWMpXCIgLi4uXG4ifQ== -->
<pre><code>&#39;data.frame&#39;:   0 obs. of  7 variables:
 $ baseMean      : num 
 $ log2FoldChange: num 
 $ lfcSE         : num 
 $ stat          : num 
 $ pvalue        : num 
 $ padj          : num 
 $ pathway       : chr 
&#39;data.frame&#39;:   2714 obs. of  2 variables:
 $ V1: chr  &quot;12DICHLORETHDEG-PWY&quot; &quot;14DICHLORBENZDEG-PWY&quot; &quot;1CMET2-PWY&quot; &quot;2AMINOBENZDEG-PWY&quot; ...
 $ V2: chr  &quot;1,2-dichloroethane degradation&quot; &quot;1,4-dichlorobenzene degradation&quot; &quot;N10-formyl-tetrahydrofolate biosynthesis&quot; &quot;anthranilate degradation III (anaerobic)&quot; ...</code></pre>
<!-- rnb-output-end -->
<!-- rnb-output-begin eyJkYXRhIjoiV2FybmluZzogbm8gbm9uLW1pc3NpbmcgYXJndW1lbnRzIHRvIG1heDsgcmV0dXJuaW5nIC1JbmZXYXJuaW5nOiBubyBub24tbWlzc2luZyBhcmd1bWVudHMgdG8gbWluOyByZXR1cm5pbmcgSW5mXG4ifQ== -->
<pre><code>Warning: no non-missing arguments to max; returning -InfWarning: no non-missing arguments to min; returning Inf</code></pre>
<!-- rnb-output-end -->
<!-- rnb-chunk-end -->
<!-- rnb-text-begin -->
<!-- rnb-text-end -->
<!-- rnb-chunk-begin -->
<!-- rnb-source-begin eyJkYXRhIjoiYGBgclxuV2hlbiB5b3Ugc2F2ZSB0aGUgbm90ZWJvb2ssIGFuIEhUTUwgZmlsZSBjb250YWluaW5nIHRoZSBjb2RlIGFuZCBvdXRwdXQgd2lsbCBiZSBzYXZlZCBhbG9uZ3NpZGUgaXQgKGNsaWNrIHRoZSAqUHJldmlldyogYnV0dG9uIG9yIHByZXNzICpDdHJsK1NoaWZ0K0sqIHRvIHByZXZpZXcgdGhlIEhUTUwgZmlsZSkuXG5cblRoZSBwcmV2aWV3IHNob3dzIHlvdSBhIHJlbmRlcmVkIEhUTUwgY29weSBvZiB0aGUgY29udGVudHMgb2YgdGhlIGVkaXRvci4gQ29uc2VxdWVudGx5LCB1bmxpa2UgKktuaXQqLCAqUHJldmlldyogZG9lcyBub3QgcnVuIGFueSBSIGNvZGUgY2h1bmtzLiBJbnN0ZWFkLCB0aGUgb3V0cHV0IG9mIHRoZSBjaHVuayB3aGVuIGl0IHdhcyBsYXN0IHJ1biBpbiB0aGUgZWRpdG9yIGlzIGRpc3BsYXllZC5cbmBgYCJ9 -->
<pre class="r"><code>When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.</code></pre>
<!-- rnb-source-end -->
<!-- rnb-chunk-end -->

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlIgTm90ZWJvb2siDQpvdXRwdXQ6IGh0bWxfbm90ZWJvb2sNCmVkaXRvcl9vcHRpb25zOiANCiAgY2h1bmtfb3V0cHV0X3R5cGU6IGlubGluZQ0KLS0tDQoNClRoaXMgaXMgYW4gW1IgTWFya2Rvd25dKGh0dHA6Ly9ybWFya2Rvd24ucnN0dWRpby5jb20pIE5vdGVib29rLiBXaGVuIHlvdSBleGVjdXRlIGNvZGUgd2l0aGluIHRoZSBub3RlYm9vaywgdGhlIHJlc3VsdHMgYXBwZWFyIGJlbmVhdGggdGhlIGNvZGUuIA0KDQpBbHBoYSBEaXZlcnNpdHkNCmBgYHtyfQ0KIyBBbHBoYSBEaXZlcnNpdHkNCmxpYnJhcnkoZHBseXIpDQpsaWJyYXJ5KHRpZHl2ZXJzZSkNCmxpYnJhcnkocWlpbWUyUikNCmxpYnJhcnkoZ2dwdWJyKQ0KDQoNCiMgUmVhZCB0aW1lbWV0YQ0KdGltZW1ldGEgPC0gcmVhZF9xMm1ldGFkYXRhKCJwcm9qZWN0X21ldGFkYXRhLnR4dCIpDQoNCiMgRmlsdGVyIHRpbWVtZXRhIGZvciBlYWNoIHRpbWUgcG9pbnQNCnRpbWVtZXRhX3RpbWUxIDwtIHRpbWVtZXRhICU+JSBmaWx0ZXIoYHRpbWUtcG9pbnRgID09ICJEYXkxNSIpDQp0aW1lbWV0YV90aW1lMiA8LSB0aW1lbWV0YSAlPiUgZmlsdGVyKGB0aW1lLXBvaW50YCA9PSAiRGF5MjIiKQ0KDQojIFJlYWQgYWxwaGEgZGl2ZXJzaXR5IGRhdGENCmV2ZW5uZXNzIDwtIHJlYWRfcXphKCJldmVubmVzc192ZWN0b3IucXphIikkZGF0YSAlPiUgcm93bmFtZXNfdG9fY29sdW1uKCJTYW1wbGVJRCIpDQpvYnNlcnZlZF9mZWF0dXJlcyA8LSByZWFkX3F6YSgib2JzZXJ2ZWRfZmVhdHVyZXNfdmVjdG9yLnF6YSIpJGRhdGEgJT4lIHJvd25hbWVzX3RvX2NvbHVtbigiU2FtcGxlSUQiKQ0Kc2hhbm5vbiA8LSByZWFkX3F6YSgic2hhbm5vbl92ZWN0b3IucXphIikkZGF0YSAlPiUgcm93bmFtZXNfdG9fY29sdW1uKCJTYW1wbGVJRCIpDQpmYWl0aF9wZCA8LSByZWFkX3F6YSgiZmFpdGhfcGRfdmVjdG9yLnF6YSIpJGRhdGEgJT4lIHJvd25hbWVzX3RvX2NvbHVtbigiU2FtcGxlSUQiKQ0KDQojIEZpbHRlciBhbHBoYSBkaXZlcnNpdHkgZGF0YSBmb3IgZWFjaCB0aW1lIHBvaW50DQpldmVubmVzc190aW1lMSA8LSBldmVubmVzcyAlPiUgZmlsdGVyKFNhbXBsZUlEICVpbiUgdGltZW1ldGFfdGltZTEkU2FtcGxlSUQpDQpldmVubmVzc190aW1lMiA8LSBldmVubmVzcyAlPiUgZmlsdGVyKFNhbXBsZUlEICVpbiUgdGltZW1ldGFfdGltZTIkU2FtcGxlSUQpDQoNCm9ic2VydmVkX2ZlYXR1cmVzX3RpbWUxIDwtIG9ic2VydmVkX2ZlYXR1cmVzICU+JSBmaWx0ZXIoU2FtcGxlSUQgJWluJSB0aW1lbWV0YV90aW1lMSRTYW1wbGVJRCkNCm9ic2VydmVkX2ZlYXR1cmVzX3RpbWUyIDwtIG9ic2VydmVkX2ZlYXR1cmVzICU+JSBmaWx0ZXIoU2FtcGxlSUQgJWluJSB0aW1lbWV0YV90aW1lMiRTYW1wbGVJRCkNCg0Kc2hhbm5vbl90aW1lMSA8LSBzaGFubm9uICU+JSBmaWx0ZXIoU2FtcGxlSUQgJWluJSB0aW1lbWV0YV90aW1lMSRTYW1wbGVJRCkNCnNoYW5ub25fdGltZTIgPC0gc2hhbm5vbiAlPiUgZmlsdGVyKFNhbXBsZUlEICVpbiUgdGltZW1ldGFfdGltZTIkU2FtcGxlSUQpDQoNCg0KDQoNCmZhaXRoX3BkIDwtIHJlYWRfcXphKCJmYWl0aF9wZF92ZWN0b3IucXphIikNCmZhaXRoX3BkPC1mYWl0aF9wZCRkYXRhICU+JSByb3duYW1lc190b19jb2x1bW4oIlNhbXBsZUlEIikNCmZhaXRoX3BkIDwtIGZhaXRoX3BkWywtMV0NCmNvbG5hbWVzKGZhaXRoX3BkKSA8LSBjKCdTYW1wbGVJRCcsICdmYWl0aF9wZCcpDQoNCmZhaXRoX3BkX3RpbWUxIDwtIGZhaXRoX3BkICU+JSBmaWx0ZXIoU2FtcGxlSUQgJWluJSB0aW1lbWV0YV90aW1lMSRTYW1wbGVJRCkNCmZhaXRoX3BkX3RpbWUyIDwtIGZhaXRoX3BkICU+JSBmaWx0ZXIoU2FtcGxlSUQgJWluJSB0aW1lbWV0YV90aW1lMiRTYW1wbGVJRCkNCg0KIyBOb3cgeW91IGNhbiBwZXJmb3JtIGFscGhhIGRpdmVyc2l0eSBhbmFseXNpcyBzZXBhcmF0ZWx5IGZvciBlYWNoIHRpbWUgcG9pbnQNCiMgRm9yIGV4YW1wbGUsIHlvdSBjYW4gY2FsY3VsYXRlIG1lYW5zLCBwZXJmb3JtIHN0YXRpc3RpY2FsIHRlc3RzLCBvciBjcmVhdGUgcGxvdHMgZm9yIGVhY2ggdGltZSBwb2ludA0KDQojIEV4YW1wbGU6IE1lYW4gYWxwaGEgZGl2ZXJzaXR5IGZvciBlYWNoIHRpbWUgcG9pbnQNCm1lYW5fZXZlbm5lc3NfdGltZTEgPC0gbWVhbihldmVubmVzc190aW1lMSRwaWVsb3VfZXZlbm5lc3MpDQptZWFuX2V2ZW5uZXNzX3RpbWUyIDwtIG1lYW4oZXZlbm5lc3NfdGltZTIkcGllbG91X2V2ZW5uZXNzKQ0KDQptZWFuX29ic2VydmVkX2ZlYXR1cmVzX3RpbWUxIDwtIG1lYW4ob2JzZXJ2ZWRfZmVhdHVyZXNfdGltZTEkb2JzZXJ2ZWRfZmVhdHVyZXMpDQptZWFuX29ic2VydmVkX2ZlYXR1cmVzX3RpbWUyIDwtIG1lYW4ob2JzZXJ2ZWRfZmVhdHVyZXNfdGltZTIkb2JzZXJ2ZWRfZmVhdHVyZXMpDQoNCm1lYW5fc2hhbm5vbl90aW1lMSA8LSBtZWFuKHNoYW5ub25fdGltZTEkc2hhbm5vbl9lbnRyb3B5KQ0KbWVhbl9zaGFubm9uX3RpbWUyIDwtIG1lYW4oc2hhbm5vbl90aW1lMiRzaGFubm9uX2VudHJvcHkpDQoNCm1lYW5fZmFpdGhfcGRfdGltZTEgPC0gbWVhbihmYWl0aF9wZF90aW1lMSRmYWl0aF9wZCkNCm1lYW5fZmFpdGhfcGRfdGltZTIgPC0gbWVhbihmYWl0aF9wZF90aW1lMiRmYWl0aF9wZCkNCg0KIyBUaGVuIHlvdSBjYW4gcGVyZm9ybSBzdGF0aXN0aWNhbCB0ZXN0cyBvciBjcmVhdGUgcGxvdHMgYmFzZWQgb24gdGhlc2UgbWVhbnMNCg0KIyBBc3N1bWluZyBldmVubmVzcywgb2JzZXJ2ZWRfZmVhdHVyZXMsIHNoYW5ub24sIGFuZCBmYWl0aF9wZCBoYXZlIGJlZW4gZmlsdGVyZWQgZm9yIGVhY2ggdGltZSBwb2ludCBhcyBzaG93biBpbiB5b3VyIGNvZGUuDQoNCiMgQ29tYmluZSBhbHBoYSBkaXZlcnNpdHkgbWV0cmljcyBpbnRvIGEgc2luZ2xlIGRhdGFmcmFtZSBmb3IgZWFjaCB0aW1lIHBvaW50Lg0KYWxwaGFfZGl2ZXJzaXR5X3RpbWUxIDwtIHJlZHVjZShsaXN0KGZhaXRoX3BkX3RpbWUxLCBldmVubmVzc190aW1lMSwgb2JzZXJ2ZWRfZmVhdHVyZXNfdGltZTEsIHNoYW5ub25fdGltZTEpLCBmdWxsX2pvaW4sIGJ5ID0gIlNhbXBsZUlEIikNCmFscGhhX2RpdmVyc2l0eV90aW1lMiA8LSByZWR1Y2UobGlzdChmYWl0aF9wZF90aW1lMiwgZXZlbm5lc3NfdGltZTIsIG9ic2VydmVkX2ZlYXR1cmVzX3RpbWUyLCBzaGFubm9uX3RpbWUyKSwgZnVsbF9qb2luLCBieSA9ICJTYW1wbGVJRCIpDQoNCiMgRW5zdXJlIGFsbCByZWxldmFudCBtZXRyaWMgbmFtZXMgYXJlIGNvcnJlY3QgYW5kIGNvbnNpc3RlbnQgYWNyb3NzIGRhdGFmcmFtZXMgYmVmb3JlIG1lcmdpbmcuDQoNCiMgTWVyZ2UgY29tYmluZWQgYWxwaGEgZGl2ZXJzaXR5IGRhdGEgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB0aW1lLXNwZWNpZmljIG1ldGFkYXRhLg0KbWV0YWRhdGFfdGltZTEgPC0gbWVyZ2UodGltZW1ldGFfdGltZTEsIGFscGhhX2RpdmVyc2l0eV90aW1lMSwgYnkgPSAiU2FtcGxlSUQiKQ0KbWV0YWRhdGFfdGltZTIgPC0gbWVyZ2UodGltZW1ldGFfdGltZTIsIGFscGhhX2RpdmVyc2l0eV90aW1lMiwgYnkgPSAiU2FtcGxlSUQiKQ0KDQojIE5vdywgbWV0YWRhdGFfdGltZTEgYW5kIG1ldGFkYXRhX3RpbWUyIGNvbnRhaW4gYWxsIHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmb3IgZWFjaCB0aW1lIHBvaW50Lg0KDQojIEV4YW1wbGUgYW5hbHlzaXM6IENhbGN1bGF0aW5nIG1lYW4gYWxwaGEgZGl2ZXJzaXR5IG1ldHJpY3MgZm9yIGVhY2ggdGltZSBwb2ludA0KIyBZb3UndmUgYWxyZWFkeSBkb25lIHRoaXMuIFlvdSBjYW4gZnVydGhlciBwZXJmb3JtIHN0YXRpc3RpY2FsIHRlc3RzIG9yIGdlbmVyYXRlIHBsb3RzIGZvciBlYWNoIHRpbWUgcG9pbnQgc2VwYXJhdGVseS4NCg0KDQojIFBsb3R0aW5nIEZhaXRoIFBEIGZvciB0aW1lIDEpDQpnZ3Bsb3QobWV0YWRhdGFfdGltZTEsIGFlcyh4ID0gdHJlYXRtZW50LCB5ID0gZmFpdGhfcGQpKSArDQogIGdlb21fYm94cGxvdCgpICsNCiAgbGFicyh0aXRsZSA9ICJGYWl0aCBQRCBieSBUcmVhdG1lbnQgZm9yIERheSAxNSIsIHggPSAiVHJlYXRtZW50IiwgeSA9ICJGYWl0aCBQRCIpICsNCiAgdGhlbWVfbWluaW1hbCgpDQoNCiMgQ3JlYXRlIGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgcGxvdHMNCmRpci5jcmVhdGUoImFscGhhX2RpdmVyc2l0eV9wbG90cyIsIHNob3dXYXJuaW5ncyA9IEZBTFNFKQ0KDQojIENvbWJpbmUgYm90aCB0aW1lLXBvaW50IHBsb3RzIGludG8gYSBmYWNldCB3aXRoIGNvbG9yDQpjb21iaW5lZF9wbG90IDwtIGdncGxvdChtYXBwaW5nID0gYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBmYWl0aF9wZCwgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMSwgYWxwaGEgPSAwLjcpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMiwgYWxwaGEgPSAwLjcpICsNCiAgbGFicyh0aXRsZSA9ICJGYWl0aCBQRCBieSBUcmVhdG1lbnQiLCB4ID0gIlRyZWF0bWVudCIsIHkgPSAiRmFpdGggUEQiKSArDQogIHRoZW1lX21pbmltYWwoKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKSwgbmFtZSA9ICJUcmVhdG1lbnQiKSArDQogIGZhY2V0X3dyYXAofmB0aW1lLXBvaW50YCkrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJibGFjayIsIGZpbGwgPSBOQSksDQogICAgICAgIHN0cmlwLmJhY2tncm91bmQgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLnNwYWNpbmcgPSB1bml0KDEsICJsaW5lcyIpLA0KcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiKSkNCg0KIyBQcmludCB0aGUgY29tYmluZWQgZmFjZXQgcGxvdA0KcHJpbnQoY29tYmluZWRfcGxvdCkNCiMgU2F2ZSB0aGUgcGxvdCB0byBhIHNwZWNpZmljIHBhdGgNCnBhdGhGUEQgPC0gImFscGhhX2RpdmVyc2l0eV9wbG90cy9GYWl0aFBEX3Bsb3QucG5nIg0KZ2dzYXZlKGZpbGVuYW1lID0gcGF0aEZQRCwgcGxvdCA9IGNvbWJpbmVkX3Bsb3QsIHdpZHRoID0gMTAsIGhlaWdodCA9IDUpDQoNCg0KDQojIFNoYXBpcm8tV2lsayB0ZXN0IGZvciBub3JtYWxpdHkNCnNoYXBpcm8udGVzdChtZXRhZGF0YV90aW1lMSRmYWl0aF9wZCkgICNub3JtYWwNCnNoYXBpcm8udGVzdChtZXRhZGF0YV90aW1lMiRmYWl0aF9wZCkgI25vdCBub3JtYWwNCg0KDQojQU5PVkEgYW5kIEtydXNrYWwgV2FsaXMNCmFvdmZwZCA8LSBhb3YoZmFpdGhfcGQgfiB0cmVhdG1lbnQsIGRhdGEgPSBtZXRhZGF0YV90aW1lMSkNCnN1bW1hcnkoYW92ZnBkKQ0Ka3J1c2thbC5mcCA8LSBrcnVza2FsLnRlc3QoZmFpdGhfcGR+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUyKQ0Ka3J1c2thbF9wX3ZhbHVlIDwtIGtydXNrYWwuZnAkcC52YWx1ZQ0KDQojdGhlIGFib3ZlIGFyZSByZWNvcmRlZCBpbiBtZWFuLCBzbyB3ZSBoYXZlIHRvIGdldCByaWQgb2YgYm94cGxvdA0KI2FuZCB1c2UgbWVhbiBiYXINCg0KIyBQbG90IEZhaXRoIFBEIHdpdGggc3RhbmRhcmQgZXJyb3JzIGZvciB0aW1lMQ0KbWVhbmZwZCA8LSBtZXRhZGF0YV90aW1lMSAlPiUNCiAgZ3JvdXBfYnkodHJlYXRtZW50KSAlPiUNCiAgc3VtbWFyaXNlKG1lYW5fZmFpdGhfcGQgPSBtZWFuKGZhaXRoX3BkKSwNCiAgICAgICAgICAgIHNkX2ZhaXRoX3BkID0gc2QoZmFpdGhfcGQpLA0KICAgICAgICAgICAgbiA9IG4oKSwNCiAgICAgICAgICAgIHNlX2ZhaXRoX3BkID0gc2RfZmFpdGhfcGQgLyBzcXJ0KG4pKQ0KDQoNCiMgQ3JlYXRlIHBsb3QgZm9yIEZhaXRoIFBEDQpmcGRfcGxvdCA8LSBnZ3Bsb3QobWVhbmZwZCwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX2ZhaXRoX3BkLCBmaWxsID0gdHJlYXRtZW50KSkgKw0KICBnZW9tX2NvbChzaG93LmxlZ2VuZCA9IEZBTFNFKSArDQogIGdlb21fZXJyb3JiYXIoYWVzKHltaW4gPSBtZWFuX2ZhaXRoX3BkIC0gc2VfZmFpdGhfcGQsIHltYXggPSBtZWFuX2ZhaXRoX3BkICsgc2VfZmFpdGhfcGQpLCB3aWR0aCA9IDAuMikgKw0KICBsYWJzKHkgPSAiTWVhbiBGYWl0aCBQRCIsIHggPSAiVHJlYXRtZW50IikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21fY29sb3JzKSArDQogIHRoZW1lX21pbmltYWwoYmFzZV9zaXplID0gMTIpICsNCiAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSA5MCwgaGp1c3QgPSAxLCB2anVzdCA9IDAuNSksDQogICAgICAgIHBsb3QuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChmaWxsID0gIndoaXRlIiwgY29sb3VyID0gTkEpLA0KICAgICAgICBwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3VyID0gImJsYWNrIiwgZmlsbCA9IE5BLCBzaXplID0gMSksDQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCg0KZnBkX3Bsb3QNCmdnc2F2ZSgiTWVhbl9GYWl0aF9QRF9EYXkxNS5wbmciLCBmcGRfcGxvdCwgcGF0aCA9ICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMiKQ0KDQoNCiMgUGxvdCBGYWl0aCBQRCB3aXRoIHN0YW5kYXJkIGVycm9ycyBmb3IgdGltZTINCm1lYW5mcGQyIDwtIG1ldGFkYXRhX3RpbWUyICU+JQ0KICBncm91cF9ieSh0cmVhdG1lbnQpICU+JQ0KICBzdW1tYXJpc2UobWVhbl9mYWl0aF9wZDIgPSBtZWFuKGZhaXRoX3BkKSwNCiAgICAgICAgICAgIHNkX2ZhaXRoX3BkMiA9IHNkKGZhaXRoX3BkKSwNCiAgICAgICAgICAgIG4gPSBuKCksDQogICAgICAgICAgICBzZV9mYWl0aF9wZDIgPSBzZF9mYWl0aF9wZDIgLyBzcXJ0KG4pKQ0KDQojIENyZWF0ZSBwbG90IGZvciBGYWl0aCBQRA0KZnBkX3Bsb3QyIDwtIGdncGxvdChtZWFuZnBkMiwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX2ZhaXRoX3BkMiwgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9jb2woc2hvdy5sZWdlbmQgPSBGQUxTRSkgKw0KICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluID0gbWVhbl9mYWl0aF9wZDIgLSBzZV9mYWl0aF9wZDIsIHltYXggPSBtZWFuX2ZhaXRoX3BkMiArIHNlX2ZhaXRoX3BkMiksIHdpZHRoID0gMC4yKSArDQogIGxhYnMoeSA9ICJNZWFuIEZhaXRoIFBEIiwgeCA9ICJUcmVhdG1lbnQiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMpICsNCiAgdGhlbWVfbWluaW1hbChiYXNlX3NpemUgPSAxMikgKw0KICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IDkwLCBoanVzdCA9IDEsIHZqdXN0ID0gMC41KSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiLCBjb2xvdXIgPSBOQSksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvdXIgPSAiYmxhY2siLCBmaWxsID0gTkEsIHNpemUgPSAxKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQ0KDQpwcmludChmcGRfcGxvdDIpDQpnZ3NhdmUoIk1lYW5fRmFpdGhfUERfRGF5MjIucG5nIiwgZnBkX3Bsb3QyLCBwYXRoID0gImFscGhhX2RpdmVyc2l0eV9wbG90cyIpDQoNCiNjb21iaW5pbmcgdGhlIHR3bw0KIyBBZGQgYSAndGltZV9wb2ludCcgY29sdW1uIHRvIGVhY2ggZGF0YSBmcmFtZQ0KbWVhbmZwZCR0aW1lX3BvaW50IDwtICJEYXkgMTUiDQptZWFuZnBkMiR0aW1lX3BvaW50IDwtICJEYXkgMjIiDQoNCg0KY29sbmFtZXMobWVhbmZwZCkNCmNvbG5hbWVzKG1lYW5mcGQyKQ0KY29sbmFtZXMobWVhbmZwZDIpIDwtIGMoInRyZWF0bWVudCIsICJtZWFuX2ZhaXRoX3BkIiwgInNkX2ZhaXRoX3BkIiwgIm4iLA0KICAgICAgICAgICAgICAgICAgICAgICAic2VfZmFpdGhfcGQiLCAidGltZV9wb2ludCIpDQoNCiMgQ29tYmluZSB0aGUgZGF0YSBmcmFtZXMNCmZwZGNvbWJfZGF0YSA8LSByYmluZChtZWFuZnBkLCBtZWFuZnBkMikNCg0KIyBEZWZpbmUgY3VzdG9tIGNvbG9ycyBmb3IgdHJlYXRtZW50cw0KY3VzdG9tX2NvbG9ycyA8LSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikNCg0KIyBDcmVhdGUgdGhlIHBsb3QNCmZwZGNvbWJfcGxvdHMgPC0gZ2dwbG90KGZwZGNvbWJfZGF0YSwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX2ZhaXRoX3BkLCBmaWxsID0gdHJlYXRtZW50KSkgKw0KICBnZW9tX2NvbChhbHBoYSA9IDAuNykgKw0KICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluID0gbWVhbl9mYWl0aF9wZCAtIHNlX2ZhaXRoX3BkLCB5bWF4ID0gbWVhbl9mYWl0aF9wZCArIHNlX2ZhaXRoX3BkKSwgd2lkdGggPSAwLjIpICsNCiAgbGFicyh0aXRsZSA9ICJGYWl0aCBQaHlsb2RpdmVyc2l0eSAiLCB4ID0gIlRyZWF0bWVudCIsIHkgPSAiRmFpdGggUEQiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMsIG5hbWUgPSAiVHJlYXRtZW50IikgKw0KICBmYWNldF93cmFwKH50aW1lX3BvaW50LCBzY2FsZXMgPSAiZnJlZV95IikgKw0KICB0aGVtZV9taW5pbWFsKCkgKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siLCBmaWxsID0gTkEpLA0KICAgICAgICBzdHJpcC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5zcGFjaW5nID0gdW5pdCgxLCAibGluZXMiKSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiKSkNCnByaW50KGZwZGNvbWJfcGxvdHMpDQpnZ3NhdmUoIk1lYW5fRml0aFBEX0NvbWJpbmVkLnBuZyIsIGZwZGNvbWJfcGxvdHMsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIiwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSkNCg0KDQoNCg0KIyMjIyNzaGFubm9uIyMjIyMNCnNoYW5ub25fcGxvdCA8LSBnZ3Bsb3QobWFwcGluZyA9IGFlcyh4ID0gdHJlYXRtZW50LCB5ID0gc2hhbm5vbl9lbnRyb3B5LCBmaWxsID0gdHJlYXRtZW50KSkgKw0KICBnZW9tX2JveHBsb3QoZGF0YSA9IG1ldGFkYXRhX3RpbWUxLCBhbHBoYSA9IDAuNykgKw0KICBnZW9tX2JveHBsb3QoZGF0YSA9IG1ldGFkYXRhX3RpbWUyLCBhbHBoYSA9IDAuNykgKw0KICBsYWJzKHRpdGxlID0gIlNoYW5ub24gRGl2ZXJzaXR5IEluZGV4IiwgeCA9ICJUcmVhdG1lbnQiLCB5ID0gIlNoYW5ub24gSW5kZXgiKSArDQogIHRoZW1lX21pbmltYWwoKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKSwgbmFtZSA9ICJUcmVhdG1lbnQiKSArDQogIGZhY2V0X3dyYXAofmB0aW1lLXBvaW50YCkrDQogIHRoZW1lKHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvciA9ICJibGFjayIsIGZpbGwgPSBOQSksDQogICAgICAgIHN0cmlwLmJhY2tncm91bmQgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLnNwYWNpbmcgPSB1bml0KDEsICJsaW5lcyIpLA0KICAgICAgICBwbG90LmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoZmlsbCA9ICJ3aGl0ZSIpKQ0KDQojIFByaW50IHRoZSBjb21iaW5lZCBmYWNldCBwbG90DQpwcmludChzaGFubm9uX3Bsb3QpDQoNCiMgU2F2ZSB0aGUgcGxvdCB0byBhIHNwZWNpZmljIHBhdGgNCnBhdGhzaCA8LSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL1NoYW5ub25fcGxvdC5wbmciDQpnZ3NhdmUoZmlsZW5hbWUgPSBwYXRoc2gsIHBsb3QgPSBzaGFubm9uX3Bsb3QsIHdpZHRoID0gMTAsIGhlaWdodCA9IDUpDQoNCg0KIyBTaGFwaXJvLVdpbGsgdGVzdCBmb3Igbm9ybWFsaXR5DQpzaGFwaXJvLnRlc3QobWV0YWRhdGFfdGltZTEkc2hhbm5vbl9lbnRyb3B5KSAgI25vdCAgbm9ybWFsDQpzaGFwaXJvLnRlc3QobWV0YWRhdGFfdGltZTIkc2hhbm5vbl9lbnRyb3B5KSAjbm90IG5vcm1hbA0KDQojIEtydXNrYWwtV2FsbGlzIHRlc3QgZm9yIHNoYW5ub25fZW50cm9weQ0Ka3J1c2thbC50ZXN0KHNoYW5ub25fZW50cm9weSB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUxKQ0Ka3J1c2thbC50ZXN0KHNoYW5ub25fZW50cm9weSB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUyKQ0KDQojIFBsb3QgU2hhbm5vbiBFbnRyb3B5IHdpdGggc3RhbmRhcmQgZXJyb3JzIGZvciB0aW1lMQ0Kc2hhbm5vbm48LSBtZXRhZGF0YV90aW1lMSAlPiUNCiAgZ3JvdXBfYnkodHJlYXRtZW50KSAlPiUNCiAgc3VtbWFyaXNlKG1lYW5fc2hhbm5vbl9lbnRyb3B5ID0gbWVhbihzaGFubm9uX2VudHJvcHkpLA0KICAgICAgICAgICAgc2Rfc2hhbm5vbl9lbnRyb3B5ID0gc2Qoc2hhbm5vbl9lbnRyb3B5KSwNCiAgICAgICAgICAgIG4gPSBuKCksDQogICAgICAgICAgICBzZV9zaGFubm9uX2VudHJvcHkgPSBzZF9zaGFubm9uX2VudHJvcHkgLyBzcXJ0KG4pKQ0KDQojIENyZWF0ZSBwbG90IGZvciBTaGFubm9uIEVudHJvcHkNCnNoYW5ub25fcGxvdDIgPC0gZ2dwbG90KHNoYW5ub25uLCBhZXMoeCA9IHRyZWF0bWVudCwgeSA9IG1lYW5fc2hhbm5vbl9lbnRyb3B5LCBmaWxsID0gdHJlYXRtZW50KSkgKw0KICBnZW9tX2NvbChzaG93LmxlZ2VuZCA9IEZBTFNFKSArDQogIGdlb21fZXJyb3JiYXIoYWVzKHltaW4gPSBtZWFuX3NoYW5ub25fZW50cm9weSAtIHNlX3NoYW5ub25fZW50cm9weSwgeW1heCA9IG1lYW5fc2hhbm5vbl9lbnRyb3B5ICsgc2Vfc2hhbm5vbl9lbnRyb3B5KSwgd2lkdGggPSAwLjIpICsNCiAgbGFicyh5ID0gIk1lYW4gU2hhbm5vbiBFbnRyb3B5IiwgeCA9ICJUcmVhdG1lbnQiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMpICsNCiAgdGhlbWVfbWluaW1hbChiYXNlX3NpemUgPSAxMikgKw0KICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IDkwLCBoanVzdCA9IDEsIHZqdXN0ID0gMC41KSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiLCBjb2xvdXIgPSBOQSksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvdXIgPSAiYmxhY2siLCBmaWxsID0gTkEsIHNpemUgPSAxKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQ0KDQpwcmludChzaGFubm9uX3Bsb3QyKQ0KZ2dzYXZlKCJNZWFuX1NoYW5ub25fRW50cm9weV9EYXkxNS5wbmciLCBzaGFubm9uX3Bsb3QyLCBwYXRoID0gImFscGhhX2RpdmVyc2l0eV9wbG90cyIpDQoNCiMgUGxvdCBTaGFubm9uIEVudHJvcHkgd2l0aCBzdGFuZGFyZCBlcnJvcnMgZm9yIHRpbWUyDQpzaGFubm9ubjIgPC0gbWV0YWRhdGFfdGltZTIgJT4lDQogIGdyb3VwX2J5KHRyZWF0bWVudCkgJT4lDQogIHN1bW1hcmlzZShtZWFuX3NoYW5ub25fZW50cm9weTIgPSBtZWFuKHNoYW5ub25fZW50cm9weSksDQogICAgICAgICAgICBzZF9zaGFubm9uX2VudHJvcHkyID0gc2Qoc2hhbm5vbl9lbnRyb3B5KSwNCiAgICAgICAgICAgIG4gPSBuKCksDQogICAgICAgICAgICBzZV9zaGFubm9uX2VudHJvcHkyID0gc2Rfc2hhbm5vbl9lbnRyb3B5MiAvIHNxcnQobikpDQoNCiMgQ3JlYXRlIHBsb3QgZm9yIFNoYW5ub24gRW50cm9weQ0Kc2hhbm5vbl9wbG90MiA8LSBnZ3Bsb3Qoc2hhbm5vbm4yLCBhZXMoeCA9IHRyZWF0bWVudCwgeSA9IG1lYW5fc2hhbm5vbl9lbnRyb3B5MiwgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9jb2woc2hvdy5sZWdlbmQgPSBGQUxTRSkgKw0KICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluID0gbWVhbl9zaGFubm9uX2VudHJvcHkyIC0gc2Vfc2hhbm5vbl9lbnRyb3B5MiwgeW1heCA9IG1lYW5fc2hhbm5vbl9lbnRyb3B5MiArIHNlX3NoYW5ub25fZW50cm9weTIpLCB3aWR0aCA9IDAuMikgKw0KICBsYWJzKHkgPSAiTWVhbiBTaGFubm9uIEVudHJvcHkgRDIyIiwgeCA9ICJUcmVhdG1lbnQiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMpICsNCiAgdGhlbWVfbWluaW1hbChiYXNlX3NpemUgPSAxMCkgKw0KICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IDkwLCBoanVzdCA9IDEsIHZqdXN0ID0gMC41KSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiLCBjb2xvdXIgPSBOQSksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvdXIgPSAiYmxhY2siLCBmaWxsID0gTkEsIHNpemUgPSAxKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQ0KDQpwcmludChzaGFubm9uX3Bsb3QyKQ0KZ2dzYXZlKCJNZWFuX1NoYW5ub25fRW50cm9weV9EYXkyMi5wbmciLCBzaGFubm9uX3Bsb3QyLCBwYXRoID0gImFscGhhX2RpdmVyc2l0eV9wbG90cyIpDQoNCiNjb21iaW5pbmcgdGhlIHR3bw0KIyBBZGQgYSAndGltZV9wb2ludCcgY29sdW1uIHRvIGVhY2ggZGF0YSBmcmFtZQ0Kc2hhbm5vbm4kdGltZV9wb2ludCA8LSAiRGF5IDE1Ig0Kc2hhbm5vbm4yJHRpbWVfcG9pbnQgPC0gIkRheSAyMiINCg0KDQpjb2xuYW1lcyhzaGFubm9ubikNCmNvbG5hbWVzKHNoYW5ub25uMikNCmNvbG5hbWVzKHNoYW5ub25uMikgPC0gYygidHJlYXRtZW50IiwgIm1lYW5fc2hhbm5vbl9lbnRyb3B5IiwgInNkX3NoYW5ub25fZW50cm9weSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgIm4iLCAic2Vfc2hhbm5vbl9lbnRyb3B5IiAsICJ0aW1lX3BvaW50IikNCg0KIyBDb21iaW5lIHRoZSBkYXRhIGZyYW1lcw0KU2hhY29tYl9kYXRhIDwtIHJiaW5kKHNoYW5ub25uLCBzaGFubm9ubjIpDQoNCiMgRGVmaW5lIGN1c3RvbSBjb2xvcnMgZm9yIHRyZWF0bWVudHMNCmN1c3RvbV9jb2xvcnMgPC0gYygiIzAwNzJCMiIsICIjRDU1RTAwIiwgIiMwMDlFNzMiLCAiI0YwRTQ0MiIpDQoNCiMgQ3JlYXRlIHRoZSBwbG90DQpTaGFjb21iX3Bsb3RzIDwtIGdncGxvdChTaGFjb21iX2RhdGEsIGFlcyh4ID0gdHJlYXRtZW50LCB5ID0gbWVhbl9zaGFubm9uX2VudHJvcHksIGZpbGwgPSB0cmVhdG1lbnQpKSArDQogIGdlb21fY29sKGFscGhhID0gMC43KSArDQogIGdlb21fZXJyb3JiYXIoYWVzKHltaW4gPSBtZWFuX3NoYW5ub25fZW50cm9weSAtIHNlX3NoYW5ub25fZW50cm9weSwgeW1heCA9IG1lYW5fc2hhbm5vbl9lbnRyb3B5ICsgc2Vfc2hhbm5vbl9lbnRyb3B5KSwgd2lkdGggPSAwLjIpICsNCiAgbGFicyh0aXRsZSA9ICJTaGFubm9uIERpdmVyc2l0eSBJbmRleCIsIHggPSAiVHJlYXRtZW50IiwgeSA9ICJTaGFubm9uIEluZGV4IikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21fY29sb3JzLCBuYW1lID0gIlRyZWF0bWVudCIpICsNCiAgZmFjZXRfd3JhcCh+dGltZV9wb2ludCwgc2NhbGVzID0gImZyZWVfeSIpICsNCiAgdGhlbWVfbWluaW1hbCgpICsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiwgZmlsbCA9IE5BKSwNCiAgICAgICAgc3RyaXAuYmFja2dyb3VuZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGFuZWwuc3BhY2luZyA9IHVuaXQoMSwgImxpbmVzIiksDQogICAgICAgIHBsb3QuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChmaWxsID0gIndoaXRlIikpDQpwcmludChTaGFjb21iX3Bsb3RzKQ0KZ2dzYXZlKCJNZWFuX1NoYW5ub25fQ29tYmluZWQucG5nIiwgU2hhY29tYl9wbG90cywgcGF0aCA9ICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMiLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1KQ0KDQoNCiNFVkVOTkVTUw0KDQpFdmVuZXNzX3Bsb3QgPC0gZ2dwbG90KG1hcHBpbmcgPSBhZXMoeCA9IHRyZWF0bWVudCwgeSA9IHBpZWxvdV9ldmVubmVzcywgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMSwgYWxwaGEgPSAwLjcpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMiwgYWxwaGEgPSAwLjcpICsNCiAgbGFicyh0aXRsZSA9ICJQaWVsb3UgRXZlbm5lc3MgSW5kZXgiLCB4ID0gIlRyZWF0bWVudCIsIHkgPSAiUGllbG91IEV2ZW5uZXNzIikgKw0KICB0aGVtZV9taW5pbWFsKCkgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIiksIG5hbWUgPSAiVHJlYXRtZW50IikgKw0KICBmYWNldF93cmFwKH5gdGltZS1wb2ludGApKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siLCBmaWxsID0gTkEpLA0KICAgICAgICBzdHJpcC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5zcGFjaW5nID0gdW5pdCgxLCAibGluZXMiKSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiKSkNCg0KcHJpbnQoRXZlbmVzc19wbG90KQ0KcGF0aCA8LSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL0V2ZW5lc3MucG5nIg0KZ2dzYXZlKGZpbGVuYW1lID0gcGF0aCwgcGxvdCA9IEV2ZW5lc3NfcGxvdCwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSkNCg0KIyBTaGFwaXJvLVdpbGsgdGVzdCBmb3Igbm9ybWFsaXR5DQpzaGFwaXJvLnRlc3QobWV0YWRhdGFfdGltZTEkcGllbG91X2V2ZW5uZXNzKSAjbm9ybWFsDQpzaGFwaXJvLnRlc3QobWV0YWRhdGFfdGltZTIkcGllbG91X2V2ZW5uZXNzKSAjbm90IG5vcm1hbA0KDQojQU5PVkEgYW5kIEtydXNrYWwgV2FsaXMNCmFvdmV2ZW5lc3MgPC0gYW92KHBpZWxvdV9ldmVubmVzcyB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUxKQ0Kc3VtbWFyeShhb3ZldmVuZXNzKQ0Ka3J1c2thbC50ZXN0KHBpZWxvdV9ldmVubmVzcyB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUyKQ0KDQoNCiMgUGxvdCBTaGFubm9uIEVudHJvcHkgd2l0aCBzdGFuZGFyZCBlcnJvcnMgZm9yIHRpbWUxDQpwaWVsb3U8LSBtZXRhZGF0YV90aW1lMSAlPiUNCiAgZ3JvdXBfYnkodHJlYXRtZW50KSAlPiUNCiAgc3VtbWFyaXNlKG1lYW5fcGllbG91PSBtZWFuKHBpZWxvdV9ldmVubmVzcyksDQogICAgICAgICAgICBzZF9waWVsb3UgPSBzZChwaWVsb3VfZXZlbm5lc3MpLA0KICAgICAgICAgICAgbiA9IG4oKSwNCiAgICAgICAgICAgIHNlX3BpZWxvdSA9IHNkX3BpZWxvdSAvIHNxcnQobikpDQoNCiMgQ3JlYXRlIHBsb3QgZm9yIHBpZWxvdV9ldmVubmVzcw0KcGllbG91X3Bsb3QgPC0gZ2dwbG90KHBpZWxvdSwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX3BpZWxvdSwgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9jb2woc2hvdy5sZWdlbmQgPSBGQUxTRSkgKw0KICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluID0gbWVhbl9waWVsb3UgLSBzZV9waWVsb3UsIHltYXggPSBtZWFuX3BpZWxvdSArIHNlX3BpZWxvdSksIHdpZHRoID0gMC4yKSArDQogIGxhYnMoeSA9ICJNZWFuIFBpZWxvdSBFdmVubmVzcyIsIHggPSAiVHJlYXRtZW50IikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21fY29sb3JzKSArDQogIHRoZW1lX21pbmltYWwoYmFzZV9zaXplID0gMTIpICsNCiAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSA5MCwgaGp1c3QgPSAxLCB2anVzdCA9IDAuNSksDQogICAgICAgIHBsb3QuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChmaWxsID0gIndoaXRlIiwgY29sb3VyID0gTkEpLA0KICAgICAgICBwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3VyID0gImJsYWNrIiwgZmlsbCA9IE5BLCBzaXplID0gMSksDQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCg0KcHJpbnQocGllbG91X3Bsb3QpDQpnZ3NhdmUoIk1lYW5fcGllbG91X3Bsb3RfRGF5MTUucG5nIiwgcGllbG91X3Bsb3QsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIikNCg0KIyBQbG90IFNoYW5ub24gRW50cm9weSB3aXRoIHN0YW5kYXJkIGVycm9ycyBmb3IgdGltZTINCnBpZWxvdTI8LSBtZXRhZGF0YV90aW1lMiAlPiUNCiAgZ3JvdXBfYnkodHJlYXRtZW50KSAlPiUNCiAgc3VtbWFyaXNlKG1lYW5fcGllbG91Mj0gbWVhbihwaWVsb3VfZXZlbm5lc3MpLA0KICAgICAgICAgICAgc2RfcGllbG91MiA9IHNkKHBpZWxvdV9ldmVubmVzcyksDQogICAgICAgICAgICBuID0gbigpLA0KICAgICAgICAgICAgc2VfcGllbG91MiA9IHNkX3BpZWxvdTIgLyBzcXJ0KG4pKQ0KDQojIENyZWF0ZSBwbG90IGZvciBwaWVsb3VfZXZlbm5lc3MNCnBpZWxvdV9wbG90MiA8LSBnZ3Bsb3QocGllbG91MiwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX3BpZWxvdTIsIGZpbGwgPSB0cmVhdG1lbnQpKSArDQogIGdlb21fY29sKHNob3cubGVnZW5kID0gRkFMU0UpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbiA9IG1lYW5fcGllbG91MiAtIHNlX3BpZWxvdTIsIHltYXggPSBtZWFuX3BpZWxvdTIgKyBzZV9waWVsb3UyKSwgd2lkdGggPSAwLjIpICsNCiAgbGFicyh5ID0gIk1lYW4gUGllbG91IEV2ZW5uZXNzIiwgeCA9ICJUcmVhdG1lbnQiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMpICsNCiAgdGhlbWVfbWluaW1hbChiYXNlX3NpemUgPSAxMikgKw0KICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IDkwLCBoanVzdCA9IDEsIHZqdXN0ID0gMC41KSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiLCBjb2xvdXIgPSBOQSksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvdXIgPSAiYmxhY2siLCBmaWxsID0gTkEsIHNpemUgPSAxKSwNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQ0KDQpwcmludChwaWVsb3VfcGxvdDIpDQpnZ3NhdmUoIk1lYW5fcGllbG91X3Bsb3RfRGF5MjIucG5nIiwgcGllbG91X3Bsb3QyLCBwYXRoID0gImFscGhhX2RpdmVyc2l0eV9wbG90cyIpDQoNCiNjb21iaW5pbmcgdGhlIHR3bw0KcGllbG91JHRpbWVfcG9pbnQgPC0gIkRheSAxNSINCnBpZWxvdTIkdGltZV9wb2ludCA8LSAiRGF5IDIyIg0KDQoNCmNvbG5hbWVzKHBpZWxvdSkNCmNvbG5hbWVzKHBpZWxvdTIpDQpjb2xuYW1lcyhwaWVsb3UyKSA8LSBjKCJ0cmVhdG1lbnQiLCAibWVhbl9waWVsb3UiLCAic2RfcGllbG91IiwgIm4iLCAic2VfcGllbG91IiAsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJ0aW1lX3BvaW50IikNCg0KIyBDb21iaW5lIHRoZSBkYXRhIGZyYW1lcw0KcGllY29tYl9kYXRhIDwtIHJiaW5kKHBpZWxvdSwgcGllbG91MikNCg0KIyBEZWZpbmUgY3VzdG9tIGNvbG9ycyBmb3IgdHJlYXRtZW50cw0KY3VzdG9tX2NvbG9ycyA8LSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikNCg0KIyBDcmVhdGUgdGhlIHBsb3QNCnBpZWNvbWJfcGxvdHMgPC0gZ2dwbG90KHBpZWNvbWJfZGF0YSwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX3BpZWxvdSwgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9jb2woYWxwaGEgPSAwLjcpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbiA9IG1lYW5fcGllbG91IC0gc2VfcGllbG91LCB5bWF4ID0gbWVhbl9waWVsb3UgKyBzZV9waWVsb3UpLCB3aWR0aCA9IDAuMikgKw0KICBsYWJzKHRpdGxlID0gIlBpZWxvdSBFdmVubmVzcyIsIHggPSAiVHJlYXRtZW50IiwgeSA9ICJQaWVsb3UgRXZlbm5lc3MiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMsIG5hbWUgPSAiVHJlYXRtZW50IikgKw0KICBmYWNldF93cmFwKH50aW1lX3BvaW50LCBzY2FsZXMgPSAiZnJlZV95IikgKw0KICB0aGVtZV9taW5pbWFsKCkgKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siLCBmaWxsID0gTkEpLA0KICAgICAgICBzdHJpcC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5zcGFjaW5nID0gdW5pdCgxLCAibGluZXMiKSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiKSkNCnByaW50KHBpZWNvbWJfcGxvdHMpDQpnZ3NhdmUoIm1lYW4gUGllbG91IEV2ZW5uZXNzLnBuZyIsIHBpZWNvbWJfcGxvdHMsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIiwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSkNCg0KDQoNCg0KI29ic2VydmVkIGZlYXR1cmVzIyMjIyMNCm9ic19wbG90IDwtIGdncGxvdChtYXBwaW5nID0gYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBvYnNlcnZlZF9mZWF0dXJlcywgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMSwgYWxwaGEgPSAwLjcpICsNCiAgZ2VvbV9ib3hwbG90KGRhdGEgPSBtZXRhZGF0YV90aW1lMiwgYWxwaGEgPSAwLjcpICsNCiAgbGFicyh0aXRsZSA9ICJPYnNlcnZlZCBmZWF0dXJlcyIsIHggPSAiVHJlYXRtZW50IiwgeSA9ICJPYnNlcnZlZCBGZWF0dXJlcyIpICsNCiAgdGhlbWVfbWluaW1hbCgpICsNCiAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gYygiIzAwNzJCMiIsICIjRDU1RTAwIiwgIiMwMDlFNzMiLCAiI0YwRTQ0MiIpLCBuYW1lID0gIlRyZWF0bWVudCIpICsNCiAgZmFjZXRfd3JhcCh+YHRpbWUtcG9pbnRgKSsNCiAgdGhlbWUocGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG9yID0gImJsYWNrIiwgZmlsbCA9IE5BKSwNCiAgICAgICAgc3RyaXAuYmFja2dyb3VuZCA9IGVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGFuZWwuc3BhY2luZyA9IHVuaXQoMSwgImxpbmVzIiksDQogICAgICAgIHBsb3QuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChmaWxsID0gIndoaXRlIikpDQoNCnByaW50KG9ic19wbG90KQ0KcGF0aCA8LSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL29ic2VydmVkX2ZlYXR1cmVzLnBuZyINCmdnc2F2ZShmaWxlbmFtZSA9IHBhdGgsIHBsb3QgPSBvYnNfcGxvdCwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSkNCg0KIyBTaGFwaXJvLVdpbGsgdGVzdCBmb3Igbm9ybWFsaXR5DQpzaGFwaXJvLnRlc3QobWV0YWRhdGFfdGltZTEkb2JzZXJ2ZWRfZmVhdHVyZXMpICNub3JtYWwNCnNoYXBpcm8udGVzdChtZXRhZGF0YV90aW1lMiRvYnNlcnZlZF9mZWF0dXJlcykgI25vcm1hbA0KDQoNCiNpZiBpdHMgbm9ybWFsIGFuZCBjYXRlZ29yaWNhbCwgdXNlIEFOT1ZBLg0KYW92Lm9ic2VydmVkX2ZlYXR1cmVzLnRpbWUxIDwtIGFvdihvYnNlcnZlZF9mZWF0dXJlcyB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUxKQ0Kc3VtbWFyeShhb3Yub2JzZXJ2ZWRfZmVhdHVyZXMudGltZTEpDQoNCmFvdi5vYnNlcnZlZF9mZWF0dXJlcy50aW1lMiA8LSBhb3Yob2JzZXJ2ZWRfZmVhdHVyZXMgfiBgdHJlYXRtZW50YCwgZGF0YSA9IG1ldGFkYXRhX3RpbWUyKQ0Kc3VtbWFyeShhb3Yub2JzZXJ2ZWRfZmVhdHVyZXMudGltZTIpDQoNCiNBTk9WQSBVU0UgTUVBTiwgQk9YUExPVCBVU0VTIE1FRElBTiwgU08gV0UgTkVFRCBUTyBGSU5EIE1FQU4gREFUQSBUTyBUQUxMWSBXSVRIIE9VUiBBTk9WQQ0KIyBQbG90IE9ic2VydmVkIEZlYXR1cmVzIHdpdGggc3RhbmRhcmQgZXJyb3JzDQpvYnNfZmVhdHVyZXMgPC0gbWV0YWRhdGFfdGltZTEgJT4lDQogIGdyb3VwX2J5KHRyZWF0bWVudCkgJT4lDQogIHN1bW1hcmlzZShtZWFuX29ic19mZWF0dXJlcyA9IG1lYW4ob2JzZXJ2ZWRfZmVhdHVyZXMpLA0KICAgICAgICAgICAgc2Rfb2JzX2ZlYXR1cmVzID0gc2Qob2JzZXJ2ZWRfZmVhdHVyZXMpLA0KICAgICAgICAgICAgbiA9IG4oKSwNCiAgICAgICAgICAgIHNlX29ic19mZWF0dXJlcyA9IHNkX29ic19mZWF0dXJlcyAvIHNxcnQobikpDQpvYnNfZmVhdHVyZXMgDQojIERlZmluZSBjdXN0b20gY29sb3JzIGZvciB0aGUgdHJlYXRtZW50cyAoYXNzdW1pbmcgNCB0cmVhdG1lbnRzIGFzIHBlciBwcmV2aW91cyBjb250ZXh0KQ0KY3VzdG9tX2NvbG9ycyA8LSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikNCg0Kb2JzX2ZlYXR1cmVzX3NlIDwtIGdncGxvdChvYnNfZmVhdHVyZXMsIGFlcyh4ID0gdHJlYXRtZW50LCB5ID0gbWVhbl9vYnNfZmVhdHVyZXMsIGZpbGwgPSB0cmVhdG1lbnQpKSArDQogIGdlb21fY29sKHNob3cubGVnZW5kID0gRkFMU0UpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbiA9IG1lYW5fb2JzX2ZlYXR1cmVzIC0gc2Vfb2JzX2ZlYXR1cmVzLCB5bWF4ID0gbWVhbl9vYnNfZmVhdHVyZXMgKyBzZV9vYnNfZmVhdHVyZXMpLCB3aWR0aCA9IDAuMikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjdXN0b21fY29sb3JzKSArDQogIGxhYnMoeSA9ICJNZWFuIE9ic2VydmVkIEZlYXR1cmVzIiwgeCA9ICJUcmVhdG1lbnQiKSArDQogIHRoZW1lX21pbmltYWwoYmFzZV9zaXplID0gMTIpICsNCiAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSA5MCwgaGp1c3QgPSAxLCB2anVzdCA9IDAuNSksDQogICAgICAgIHBsb3QuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChmaWxsID0gIndoaXRlIiwgY29sb3VyID0gTkEpLCAjIFdoaXRlIGJhY2tncm91bmQNCiAgICAgICAgcGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGNvbG91ciA9ICJibGFjayIsIGZpbGw9TkEsIHNpemU9MSksICMgQmxhY2sgYm9yZGVyIGFyb3VuZCBlYWNoIHBsb3QNCiAgICAgICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF9ibGFuaygpKQ0KDQpwcmludChvYnNfZmVhdHVyZXNfc2UpDQpnZ3NhdmUoIk1lYW4gT2JzZXJ2ZSBmZWF0dXJlc19kYXkxNS5wbmciLCBvYnNfZmVhdHVyZXNfc2UsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIikgDQoNCg0KIyBQbG90IE9ic2VydmVkIEZlYXR1cmVzIHdpdGggc3RhbmRhcmQgZXJyb3JzDQpvYnNfZmVhdHVyZXMyIDwtIG1ldGFkYXRhX3RpbWUyICU+JQ0KICBncm91cF9ieSh0cmVhdG1lbnQpICU+JQ0KICBzdW1tYXJpc2UobWVhbl9vYnNfZmVhdHVyZXMyID0gbWVhbihvYnNlcnZlZF9mZWF0dXJlcyksDQogICAgICAgICAgICBzZF9vYnNfZmVhdHVyZXMyID0gc2QobWV0YWRhdGFfdGltZTIkb2JzZXJ2ZWRfZmVhdHVyZXMpLA0KICAgICAgICAgICAgbiA9IG4oKSwNCiAgICAgICAgICAgIHNlX29ic19mZWF0dXJlczIgPSBzZF9vYnNfZmVhdHVyZXMyIC8gc3FydChuKSkNCm9ic19mZWF0dXJlczIgDQojIERlZmluZSBjdXN0b20gY29sb3JzIGZvciB0aGUgdHJlYXRtZW50cyAoYXNzdW1pbmcgNCB0cmVhdG1lbnRzIGFzIHBlciBwcmV2aW91cyBjb250ZXh0KQ0KY3VzdG9tX2NvbG9ycyA8LSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikNCg0Kb2JzX2ZlYXR1cmVzX3NlMiA8LSBnZ3Bsb3Qob2JzX2ZlYXR1cmVzMiwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX29ic19mZWF0dXJlczIsIGZpbGwgPSB0cmVhdG1lbnQpKSArDQogIGdlb21fY29sKHNob3cubGVnZW5kID0gRkFMU0UpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbiA9IG1lYW5fb2JzX2ZlYXR1cmVzMiAtIHNlX29ic19mZWF0dXJlczIsIHltYXggPSBtZWFuX29ic19mZWF0dXJlczIgKyBzZV9vYnNfZmVhdHVyZXMyKSwgd2lkdGggPSAwLjIpICsNCiAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gY3VzdG9tX2NvbG9ycykgKw0KICBsYWJzKHkgPSAiTWVhbiBPYnNlcnZlZCBGZWF0dXJlc0QyMiIsIHggPSAiVHJlYXRtZW50IikgKw0KICB0aGVtZV9taW5pbWFsKGJhc2Vfc2l6ZSA9IDEwKSArDQogIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGFuZ2xlID0gOTAsIGhqdXN0ID0gMSwgdmp1c3QgPSAwLjUpLA0KICAgICAgICBwbG90LmJhY2tncm91bmQgPSBlbGVtZW50X3JlY3QoZmlsbCA9ICJ3aGl0ZSIsIGNvbG91ciA9IE5BKSwgIyBXaGl0ZSBiYWNrZ3JvdW5kDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChjb2xvdXIgPSAiYmxhY2siLCBmaWxsPU5BLCBzaXplPTEpLCAjIEJsYWNrIGJvcmRlciBhcm91bmQgZWFjaCBwbG90DQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCg0KcHJpbnQob2JzX2ZlYXR1cmVzX3NlMikNCmdnc2F2ZSgiTWVhbiBPYnNlcnZlIGZlYXR1cmVzX2RheTIyLnBuZyIsIG9ic19mZWF0dXJlc19zZTIsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIikgDQoNCiNjb21iaW5pbmcgdGhlIHR3bw0KIyBBZGQgYSAndGltZV9wb2ludCcgY29sdW1uIHRvIGVhY2ggZGF0YSBmcmFtZQ0Kb2JzX2ZlYXR1cmVzJHRpbWVfcG9pbnQgPC0gIkRheSAxNSINCm9ic19mZWF0dXJlczIkdGltZV9wb2ludCA8LSAiRGF5IDIyIg0KDQoNCmNvbG5hbWVzKG9ic19mZWF0dXJlcykNCmNvbG5hbWVzKG9ic19mZWF0dXJlczIpDQoNCiMgUmVuYW1lIGNvbHVtbnMgaW4gb2JzX2ZlYXR1cmVzMiB0byBtYXRjaCBvYnNfZmVhdHVyZXMNCmNvbG5hbWVzKG9ic19mZWF0dXJlczIpIDwtIGMoInRyZWF0bWVudCIsICJtZWFuX29ic19mZWF0dXJlcyIsICJzZF9vYnNfZmVhdHVyZXMiLCAibiIsICJzZV9vYnNfZmVhdHVyZXMiLCAidGltZV9wb2ludCIpDQoNCiMgQ29tYmluZSB0aGUgZGF0YSBmcmFtZXMNCmNvbWJpbmVkX2RhdGEgPC0gcmJpbmQob2JzX2ZlYXR1cmVzLCBvYnNfZmVhdHVyZXMyKQ0KDQojIERlZmluZSBjdXN0b20gY29sb3JzIGZvciB0cmVhdG1lbnRzDQpjdXN0b21fY29sb3JzIDwtIGMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKQ0KDQojIENyZWF0ZSB0aGUgcGxvdA0Kb2JzZXJ2ZV9wbG90cyA8LSBnZ3Bsb3QoY29tYmluZWRfZGF0YSwgYWVzKHggPSB0cmVhdG1lbnQsIHkgPSBtZWFuX29ic19mZWF0dXJlcywgZmlsbCA9IHRyZWF0bWVudCkpICsNCiAgZ2VvbV9jb2woYWxwaGEgPSAwLjcpICsNCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbiA9IG1lYW5fb2JzX2ZlYXR1cmVzIC0gc2Vfb2JzX2ZlYXR1cmVzLCB5bWF4ID0gbWVhbl9vYnNfZmVhdHVyZXMgKyBzZV9vYnNfZmVhdHVyZXMpLCB3aWR0aCA9IDAuMikgKw0KICBsYWJzKHRpdGxlID0gIk9ic2VydmVkIEZlYXR1cmVzIiwgeCA9ICJUcmVhdG1lbnQiLCB5ID0gIk1lYW4gT2JzZXJ2ZWQgRmVhdHVyZXMiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGN1c3RvbV9jb2xvcnMsIG5hbWUgPSAiVHJlYXRtZW50IikgKw0KICBmYWNldF93cmFwKH50aW1lX3BvaW50LCBzY2FsZXMgPSAiZnJlZV95IikgKw0KICB0aGVtZV9taW5pbWFsKCkgKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoY29sb3IgPSAiYmxhY2siLCBmaWxsID0gTkEpLA0KICAgICAgICBzdHJpcC5iYWNrZ3JvdW5kID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5zcGFjaW5nID0gdW5pdCgxLCAibGluZXMiKSwNCiAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGZpbGwgPSAid2hpdGUiKSkNCnByaW50KG9ic2VydmVfcGxvdHMpDQpnZ3NhdmUoIk1lYW5fT2JzZXJ2ZWRfRmVhdHVyZXNfQ29tYmluZWQucG5nIiwgb2JzZXJ2ZV9wbG90cywgcGF0aCA9ICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMiLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1KQ0KDQoNCg0KDQoNCiNDb21iaW5pbmcgYWxsIGJveHBsb3RzDQpsaWJyYXJ5KGdncHVicikNCmZpZ3VyZSA8LSBnZ2FycmFuZ2UoY29tYmluZWRfcGxvdCwgc2hhbm5vbl9wbG90LCBvYnNfcGxvdCwgDQogICAgICAgICAgICAgICAgICAgIEV2ZW5lc3NfcGxvdCwNCiAgICAgICAgICAgICAgICAgICAgbGFiZWxzID0gYygiQSIsICJCIiwgIkMiLCAiRCIpLGNvbW1vbi5sZWdlbmQgPSBUUlVFLA0KICAgICAgICAgICAgICAgICAgICBsZWdlbmQgPSAiYm90dG9tIiwgbmNvbCA9IDIsIG5yb3cgPSAyKQ0KZmlndXJlDQpwYXRoIDwtICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvYWxwaGEgZGl2ZXJzaXR5LnBuZyINCmdnc2F2ZShmaWxlbmFtZSA9IHBhdGgsIHBsb3QgPSBmaWd1cmUsIHdpZHRoID0gMTAsIGhlaWdodCA9IDUpDQoNCiNDb21iaW5pbmcgYWxsIGJhciBwbG90cw0KZmlndXJlMiA8LSBnZ2FycmFuZ2Uob2JzZXJ2ZV9wbG90cywgcGllY29tYl9wbG90cywgU2hhY29tYl9wbG90cywgDQogICAgICAgICAgICAgICAgICAgICBmcGRjb21iX3Bsb3RzLA0KICAgICAgICAgICAgICAgICAgICBsYWJlbHMgPSBjKCJBIiwgIkIiLCAiQyIsICJEIiksY29tbW9uLmxlZ2VuZCA9IFRSVUUsDQogICAgICAgICAgICAgICAgICAgIGxlZ2VuZCA9ICJib3R0b20iLCBuY29sID0gMiwgbnJvdyA9IDIpDQpmaWd1cmUyDQpwYXRoMiA8LSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL2FscGhhIGRpdmVyc2l0eTIucG5nIg0KZ2dzYXZlKGZpbGVuYW1lID0gcGF0aDIsIHBsb3QgPSBmaWd1cmUyLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1KQ0KDQojIENvbWJpbmUgYWxsIHBsb3RzIGludG8gYSBzaW5nbGUgcGljdHVyZQ0KI2xpYnJhcnkoY293cGxvdCkNCiNjb21iaW5lZF9wbG90cyA8LSBwbG90X2dyaWQoY29tYmluZWRfcGxvdCwgc2hhbm5vbl9wbG90LEV2ZW5lc3NfcGxvdCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICMgRXZlbmVzc19wbG90LCBucm93ID0gMywgcmVsX2hlaWdodHMgPSBjKDIsIDIsIDIpKQ0KI3ByaW50KGNvbWJpbmVkX3Bsb3RzKQ0KIyBzYXZpbmcgdGhlIHBsb3QgYXMgcG5nICANCiNnZ3NhdmUoIkZhaXRoIFBELnBuZyIsIGNvbWJpbmVkX3Bsb3QsIHBhdGggPSAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzIikgDQpgYGANCmltcG9ydGFudCB3ZWJzaXRlOiBodHRwczovL21pY3JvYmlvbWUuZ2l0aHViLmlvL2NvdXJzZV8yMDIyX3R1cmt1L2JldGEtZGl2ZXJzaXR5Lmh0bWwNCg0KQmV0YSBEaXZlcnNpdHkgQmVsb3cNCmBgYHtyfQ0KI0JFVEEgRElWRVJTSVRZDQpsaWJyYXJ5KHRpZHl2ZXJzZSkNCmxpYnJhcnkodmVnYW4pDQpsaWJyYXJ5KHFpaW1lMlIpDQoNCm1ldGFkYXRhMiA8LSByZWFkLmRlbGltKCJwcm9qZWN0X21ldGFkYXRhLnR4dCIsIHNlcCA9ICJcdCIsIGhlYWRlciA9IFQsIHF1b3RlID0gIiIsIHN0cmluZ3NBc0ZhY3RvcnMgPSBGKQ0KbWV0YWRhdGEyWzEsXQ0KbWV0YWRhdGEyWywxXQ0KIyBXaGVuIHN1YnNldHRpbmcsIHRoZSBmaXJzdCBudW1iZXIgaXMgdGhlIHJvdyBhbmQgYWZ0ZXIgdGhlIGNvbW1hIGlzIHRoZSBjb2x1bW4NCm1ldGFkYXRhMiA8LSBtZXRhZGF0YTJbLTEsXQ0Kc3RyKG1ldGFkYXRhMikNCiNOb3cgdGhlIHFpaW1lMlIgbWV0aG9kDQptZXRhZGF0YTwtcmVhZF9xMm1ldGFkYXRhKCJwcm9qZWN0X21ldGFkYXRhLnR4dCIpDQpzdHIobWV0YWRhdGEpDQpsZXZlbHMobWV0YWRhdGEkYGJvZHktc2l0ZWApDQpjb2xuYW1lcyhtZXRhZGF0YSlbMl0gPC0gInRpbWUtcG9pbnQiDQpjb2xuYW1lcyhtZXRhZGF0YSlbNl0gPC0gInRyZWF0bWVudCINCnN0cihtZXRhZGF0YSkNCg0Kcm93Lm5hbWVzKG1ldGFkYXRhKSA8LSBtZXRhZGF0YVssMV0NCnJvdy5uYW1lcyhtZXRhZGF0YSkgPC0gbWV0YWRhdGEkU2FtcGxlSUQNCiNtZXRhZGF0YSA8LSBtZXRhZGF0YVssLTFdDQpyb3cubmFtZXMobWV0YWRhdGEpDQoNCmJjX1BDb0E8LXJlYWRfcXphKCJicmF5X2N1cnRpc19wY29hX3Jlc3VsdHMucXphIikNCg0KdHJ0X2NvbG9ycyA8LSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikNCg0KI0JyYXktQ3VydGlzDQpiY19tZXRhIDwtIGJjX1BDb0EkZGF0YSRWZWN0b3JzICU+JQ0KICBzZWxlY3QoU2FtcGxlSUQsIFBDMSwgUEMyLCBQQzMpICU+JQ0KICBpbm5lcl9qb2luKG1ldGFkYXRhLCBieSA9IGMoIlNhbXBsZUlEIiA9ICJTYW1wbGVJRCIpKQ0KDQojIE5vdyB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBhbiBvcmRpbmF0aW9uIHBsb3QNCmdncGxvdChiY19tZXRhLCBhZXMoeD1QQzEsIHk9UEMyLCBjb2xvcj10cmVhdG1lbnQpKSArDQogIGdlb21fcG9pbnQoKSArICNhbHBoYSBjb250cm9scyB0cmFuc3BhcmVuY3kgYW5kIGhlbHBzIHdoZW4gcG9pbnRzIGFyZSBvdmVybGFwcGluZw0KICB0aGVtZV9xMnIoKSArDQogIHhsYWIoIlBDMSAoMzIuMjclKSIpICsNCiAgeWxhYigiUEMyICgyMi4yOCUpIikgKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzPWMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKSwgbmFtZSA9ICJUcmVhdG1lbnQiKQ0KDQojIE5vdyB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBvdXIgY29kZSBhIGxpdHRsZSBtb3JlIHJlLXVzYWJsZQ0KbXlfY29sdW1uIDwtICJ0cmVhdG1lbnQiDQoNCmdncGxvdChiY19tZXRhLCBhZXMoeD1QQzEsIHk9UEMyLCBjb2xvcj1nZXQobXlfY29sdW1uKSkpICsNCiAgZ2VvbV9wb2ludCgpICsgI2FscGhhIGNvbnRyb2xzIHRyYW5zcGFyZW5jeSBhbmQgaGVscHMgd2hlbiBwb2ludHMgYXJlIG92ZXJsYXBwaW5nDQogIHRoZW1lX3EycigpICsNCiAgZmFjZXRfZ3JpZCh+YHRpbWUtcG9pbnRgKSArDQogIHhsYWIocGFzdGUwKCJQQzEgKCIsIHJvdW5kKDEwMCpiY19QQ29BJGRhdGEkUHJvcG9ydGlvbkV4cGxhaW5lZFsxXSwgZGlnaXRzID0gMiksICIlKSIpKSArDQogIHlsYWIocGFzdGUwKCJQQzIgKCIsIHJvdW5kKDEwMCpiY19QQ29BJGRhdGEkUHJvcG9ydGlvbkV4cGxhaW5lZFsyXSwgZGlnaXRzID0gMiksICIlKSIpKSArDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXM9dHJ0X2NvbG9ycywgbmFtZSA9IG15X2NvbHVtbikNCg0KI2FwcGx5IGNlbnRyb2lkcw0KDQpjZW50cm9pZHMgPC0gYWdncmVnYXRlKGNiaW5kKFBDMSxQQzIpfmdldChteV9jb2x1bW4pLGJjX21ldGEsbWVhbikNCmNvbG5hbWVzKGNlbnRyb2lkcylbMV0gPC0gInRyZWF0bWVudCINCg0KcGJyYXkgPC0gZ2dwbG90KGJjX21ldGEsIGFlcyh4ID0gUEMxLCB5ID0gUEMyLCBjb2xvciA9IGdldChteV9jb2x1bW4pKSkgKw0KICBnZW9tX3BvaW50KGFscGhhID0gMC42LCBzaXplID0gMikgKyAgIyBQb2ludHMgd2l0aCB0cmFuc3BhcmVuY3kNCiAgc3RhdF9lbGxpcHNlKHR5cGUgPSAidCIsIGxldmVsID0gMC45NSkgKyAgIyBTdGF0aXN0aWNhbCBlbGxpcHNlLCA5NSUgY29uZmlkZW5jZQ0KICBnZW9tX3RleHQoZGF0YSA9IGNlbnRyb2lkcywgYWVzKGxhYmVsID0gdHJlYXRtZW50LCB4ID0gUEMxLCB5ID0gUEMyKSwgdmp1c3QgPSAtMSwgaGp1c3QgPSAtMC4xKSArICAjIEFkZCBjZW50cm9pZHMgbGFiZWxzDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSB0cnRfY29sb3JzLCBuYW1lID0gbXlfY29sdW1uKSArDQogIGZhY2V0X2dyaWQofmB0aW1lLXBvaW50YCkgKyAgIyBGYWNldCBieSB0aW1lIHBvaW50DQogIHhsYWIocGFzdGUwKCJQQzEgKCIsIHJvdW5kKDEwMCAqIGJjX1BDb0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzFdLCAyKSwgIiUpIikpICsNCiAgeWxhYihwYXN0ZTAoIlBDMiAoIiwgcm91bmQoMTAwICogYmNfUENvQSRkYXRhJFByb3BvcnRpb25FeHBsYWluZWRbMl0sIDIpLCAiJSkiKSkgKw0KICB0aGVtZV9xMnIoKSArICAjIEN1c3RvbSB0aGVtZQ0KICBsYWJzKHRpdGxlID0gIkJyYXktQ3VydGlzIEJldGEgRGl2ZXJzaXR5IiwgICMgU2V0dGluZyB0aGUgdGl0bGUNCiAgICAgICBzdWJ0aXRsZSA9ICJBbmFseXNpcyBieSB0cmVhdG1lbnQgYW5kIHRpbWUgcG9pbnRzIikrDQogIHRoZW1lKA0KICAgIHBsb3QudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE2KSwgICMgSW5jcmVhc2UgdGl0bGUgZm9udCBzaXplDQogICAgcGxvdC5zdWJ0aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTYpLCAgIyBJbmNyZWFzZSBzdWJ0aXRsZSBmb250IHNpemUNCiAgICBheGlzLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNSksICAjIEluY3JlYXNlIGF4aXMgdGl0bGVzIGZvbnQgc2l6ZQ0KICAgIGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNCksICAjIEluY3JlYXNlIHggYXhpcyB0ZXh0IGZvbnQgc2l6ZQ0KICAgIGF4aXMudGV4dC55ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNCksICAjIEluY3JlYXNlIHkgYXhpcyB0ZXh0IGZvbnQgc2l6ZQ0KICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTQpLCAgIyBJbmNyZWFzZSBsZWdlbmQgdGl0bGUgZm9udCBzaXplDQogICAgbGVnZW5kLnRleHQgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDEyKSApICAjIEluY3JlYXNlIGxlZ2VuZCB0ZXh0IGZvbnQgc2l6ZQ0KcGJyYXkNCmdnc2F2ZSgiLi9hbHBoYV9kaXZlcnNpdHlfcGxvdHMvcGJyYXkucG5nIiwgaGVpZ2h0ID0gNywgd2lkdGggPSAxMCkNCg0KYmNfZGlzdF9tYXQ8LXJlYWRfcXphKCJicmF5X2N1cnRpc19kaXN0YW5jZV9tYXRyaXgucXphIikNCmJjX2RtIDwtIGFzLm1hdHJpeChiY19kaXN0X21hdCRkYXRhKSANCnJvd25hbWVzKGJjX2RtKSA9PSBtZXRhZGF0YSRTYW1wbGVJRCAjIyBhbGwgdGhlc2UgdmFsdWVzIG5lZWQgdG8gYmUgIlRSVUUiDQptZXRhZGF0YV9zdWIgPC0gbWV0YWRhdGFbbWF0Y2gocm93bmFtZXMoYmNfZG0pLG1ldGFkYXRhJFNhbXBsZUlEKSxdDQpyb3duYW1lcyhiY19kbSkgPT0gbWV0YWRhdGFfc3ViJFNhbXBsZUlEICMjIGFsbCB0aGVzZSB2YWx1ZXMgbmVlZCB0byBiZSAiVFJVRSINCg0KUEVSTUFOT1ZBX291dCA8LSBhZG9uaXMyKGJjX2RtIH4gdHJlYXRtZW50LCBkYXRhID0gbWV0YWRhdGFfc3ViKQ0KUEVSTUFOT1ZBX291dCANClBFUk1BTk9WQWJyYXl0aW1lIDwtIGFkb25pczIoYmNfZG0gfiBgdGltZS1wb2ludGAsIGRhdGEgPSBtZXRhZGF0YV9zdWIpDQpQRVJNQU5PVkFicmF5dGltZQ0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyMgIFBhaXJ3aXNlIGFkb25pcyBmdW5jdGlvbg0KIyMgIHdlIGNhbiBhbHNvIHBlcmZvcm0gYSBwYWlyd2lzZSBjb21wYXJpc29uIHdpdGggdGhlIGZ1bmN0aW9uIA0KIyMgIFBhaXJ3aXNlIEFkb25pcyBmdW5jdGlvbiBieSBlZHJvIE1hcnRpbmV6IEFyYml6dSAmIFN5bHZhaW4gTW9udGV1eA0KIyMgIGh0dHBzOi8vZ2l0aHViLmNvbS9wbWFydGluZXphcmJpenUvcGFpcndpc2VBZG9uaXMvYmxvYi9tYXN0ZXIvcGFpcndpc2VBZG9uaXMvUi9wYWlyd2lzZS5hZG9uaXMuUg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQoNCnBhaXJ3aXNlLmFkb25pczIgPC0gZnVuY3Rpb24oeCwgZGF0YSwgc3RyYXRhID0gTlVMTCwgbnBlcm09OTk5LCAuLi4gKSB7DQogIA0KICAjZGVzY3JpYmUgcGFyZW50IGNhbGwgZnVuY3Rpb24gDQogIHN0c3RyaSA8LSBpZmVsc2UoaXMubnVsbChzdHJhdGEpLCdOdWxsJyxzdHJhdGEpDQogIGZvc3RyaSA8LSBhcy5jaGFyYWN0ZXIoeCkNCiAgI2xpc3QgdG8gc3RvcmUgcmVzdWx0cw0KICANCiAgI2NvcHkgbW9kZWwgZm9ybXVsYQ0KICB4MSA8LSB4DQogICMgZXh0cmFjdCBsZWZ0IGhhbmQgc2lkZSBvZiBmb3JtdWxhDQogIGxocyA8LSB4MVtbMl1dDQogICMgZXh0cmFjdCBmYWN0b3JzIG9uIHJpZ2h0IGhhbmQgc2lkZSBvZiBmb3JtdWxhIA0KICByaHMgPC0geDFbWzNdXQ0KICAjIGNyZWF0ZSBtb2RlbC5mcmFtZSBtYXRyaXggIA0KICB4MVtbMl1dIDwtIE5VTEwgICANCiAgcmhzLmZyYW1lIDwtIG1vZGVsLmZyYW1lKHgxLCBkYXRhLCBkcm9wLnVudXNlZC5sZXZlbHMgPSBUUlVFKSANCiAgDQogICMgY3JlYXRlIHVuaXF1ZSBwYWlyd2lzZSBjb21iaW5hdGlvbiBvZiBmYWN0b3JzIA0KICBjbyA8LSBjb21ibih1bmlxdWUoYXMuY2hhcmFjdGVyKHJocy5mcmFtZVssMV0pKSwyKQ0KICANCiAgIyBjcmVhdGUgbmFtZXMgdmVjdG9yICAgDQogIG5hbWVyZXMgPC0gYygncGFyZW50X2NhbGwnKQ0KICBmb3IgKGVsZW0gaW4gMTpuY29sKGNvKSl7DQogICAgbmFtZXJlcyA8LSBjKG5hbWVyZXMscGFzdGUoY29bMSxlbGVtXSxjb1syLGVsZW1dLHNlcD0nX3ZzXycpKQ0KICB9DQogICNjcmVhdGUgcmVzdWx0cyBsaXN0ICANCiAgcmVzIDwtIHZlY3Rvcihtb2RlPSJsaXN0IiwgbGVuZ3RoPWxlbmd0aChuYW1lcmVzKSkNCiAgbmFtZXMocmVzKSA8LSBuYW1lcmVzDQogIA0KICAjYWRkIHBhcmVudCBjYWxsIHRvIHJlcyANCiAgcmVzWydwYXJlbnRfY2FsbCddIDwtIGxpc3QocGFzdGUoZm9zdHJpWzJdLGZvc3RyaVsxXSxmb3N0cmlbM10sJywgc3RyYXRhID0nLHN0c3RyaSwgJywgcGVybXV0YXRpb25zJyxucGVybSApKQ0KICANCiAgDQogICNzdGFydCBpdGVyYXRpb24gdHJvdWdoIHBhaXJ3aXNlIGNvbWJpbmF0aW9uIG9mIGZhY3RvcnMgIA0KICBmb3IoZWxlbSBpbiAxOm5jb2woY28pKXsNCiAgICANCiAgICAjcmVkdWNlIG1vZGVsIGVsZW1lbnRzICANCiAgICBpZihpbmhlcml0cyhldmFsKGxocyksJ2Rpc3QnKSl7CQ0KICAgICAgeHJlZCA8LSBhcy5kaXN0KGFzLm1hdHJpeChldmFsKGxocykpW3Jocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmhzLmZyYW1lWywxXSAlaW4lIGMoY29bMSxlbGVtXSxjb1syLGVsZW1dKV0pDQogICAgfWVsc2V7DQogICAgICB4cmVkIDwtIGV2YWwobGhzKVtyaHMuZnJhbWVbLDFdICVpbiUgYyhjb1sxLGVsZW1dLGNvWzIsZWxlbV0pLF0NCiAgICB9DQogICAgDQogICAgbWRhdDEgPC0gIGRhdGFbcmhzLmZyYW1lWywxXSAlaW4lIGMoY29bMSxlbGVtXSxjb1syLGVsZW1dKSxdIA0KICAgIA0KICAgICMgcmVkZWZpbmUgZm9ybXVsYQ0KICAgIGlmKGxlbmd0aChyaHMpID09IDEpew0KICAgICAgeG5ldyA8LSBhcy5mb3JtdWxhKHBhc3RlKCd4cmVkJyxhcy5jaGFyYWN0ZXIocmhzKSxzZXA9J34nKSkJDQogICAgfWVsc2V7DQogICAgICB4bmV3IDwtIGFzLmZvcm11bGEocGFzdGUoJ3hyZWQnICwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGUocmhzWy0xXSxjb2xsYXBzZT0gYXMuY2hhcmFjdGVyKHJoc1sxXSkpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcD0nficpKX0NCiAgICANCiAgICAjcGFzcyBuZXcgZm9ybXVsYSB0byBhZG9uaXMNCiAgICBpZihpcy5udWxsKHN0cmF0YSkpew0KICAgICAgYWQgPC0gYWRvbmlzMih4bmV3LGRhdGE9bWRhdDEsIC4uLiApDQogICAgfWVsc2V7DQogICAgICBwZXJtIDwtIGhvdyhucGVybSA9IG5wZXJtKQ0KICAgICAgc2V0QmxvY2tzKHBlcm0pIDwtIHdpdGgobWRhdDEsIG1kYXQxWyxzdHN0cmldKQ0KICAgICAgYWQgPC0gYWRvbmlzMih4bmV3LGRhdGE9bWRhdDEscGVybXV0YXRpb25zID0gcGVybSwgLi4uICl9DQogICAgDQogICAgcmVzW25hbWVyZXNbZWxlbSsxXV0gPC0gbGlzdChhZFsxOjVdKQ0KICB9DQogICNuYW1lcyhyZXMpIDwtIG5hbWVzICANCiAgY2xhc3MocmVzKSA8LSBjKCJwd2Fkc3RyYXRhIiwgImxpc3QiKQ0KICByZXR1cm4ocmVzKQ0KfSANCg0KdHJ0X1BhaXIgPC0gcGFpcndpc2UuYWRvbmlzMihiY19kbSB+IHRyZWF0bWVudCwgZGF0YSA9IG1ldGFkYXRhX3N1YikNCnRydF9QYWlyDQp3cml0ZS50YWJsZSh0cnRfUGFpciwiLi9hbHBoYV9kaXZlcnNpdHlfcGxvdHMvQnJheUN1cnRpc19BZG9uaXNfcGFpcndpc2UuY3N2IixzZXA9IiwiLCByb3cubmFtZXMgPSBUUlVFKSANCg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KIyN3ZWlnaHRlZCBVbmlGcmFjDQp3VUZfUENPQSA8LSByZWFkX3F6YSgid2VpZ2h0ZWRfdW5pZnJhY19wY29hX3Jlc3VsdHMucXphIikNCld1bmlfbWV0YSA8LSB3VUZfUENPQSRkYXRhJFZlY3RvcnMgJT4lDQogIHNlbGVjdChTYW1wbGVJRCwgUEMxLCBQQzIsIFBDMykgJT4lDQogIGlubmVyX2pvaW4obWV0YWRhdGEsIGJ5ID0gYygiU2FtcGxlSUQiID0gIlNhbXBsZUlEIikpDQoNCm15X2NvbHVtbiA8LSAidHJlYXRtZW50Ig0KDQojb3ZlcmFsbCBXZWlnaHRlZCB1bmlGcmFjDQpnZ3Bsb3QoV3VuaV9tZXRhLCBhZXMoeD1QQzEsIHk9UEMyLCBjb2xvcj1nZXQobXlfY29sdW1uKSkpICsNCiAgZ2VvbV9wb2ludChhZXMoc2hhcGU9IGB0aW1lLXBvaW50YCksIHNpemUgPSAzKSArICNhbHBoYSBjb250cm9scyB0cmFuc3BhcmVuY3kgYW5kIGhlbHBzIHdoZW4gcG9pbnRzIGFyZSBvdmVybGFwcGluZw0KICAjZ2VvbV9wb2ludChkYXRhPWNlbnRyb2lkcywgc2l6ZSA9IDMpICsNCiAgdGhlbWVfcTJyKCkgKw0KICBzdGF0X2VsbGlwc2UobGV2ZWwgPSAwLjk1LCB0eXBlID0gInQiKSArDQogIHhsYWIocGFzdGUwKCJQQzEgKCIsIHJvdW5kKDEwMCp3VUZfUENPQSRkYXRhJFByb3BvcnRpb25FeHBsYWluZWRbMV0sIGRpZ2l0cyA9IDIpLCAiJSkiKSkgKw0KICB5bGFiKHBhc3RlMCgiUEMyICgiLCByb3VuZCgxMDAqd1VGX1BDT0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzJdLCBkaWdpdHMgPSAyKSwgIiUpIikpICsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcz10cnRfY29sb3JzLCBuYW1lID0gInRyZWF0bWVudCIpDQoNCmNlbnRyb2lkMiA8LSBhZ2dyZWdhdGUoY2JpbmQoUEMxLFBDMil+Z2V0KG15X2NvbHVtbiksV3VuaV9tZXRhLG1lYW4pDQpjb2xuYW1lcyhjZW50cm9pZDIpWzFdIDwtICJ0cmVhdG1lbnQiDQoNCndfVW5pRnJhYzIgPC0gZ2dwbG90KFd1bmlfbWV0YSwgYWVzKHg9UEMxLCB5PVBDMiwgY29sb3I9Z2V0KG15X2NvbHVtbikpKSArDQogIGdlb21fcG9pbnQoYWxwaGEgPSAwLjYsIHNpemUgPSAyKSArICAjIFBvaW50cyB3aXRoIHRyYW5zcGFyZW5jeQ0KICBzdGF0X2VsbGlwc2UodHlwZSA9ICJ0IiwgbGV2ZWwgPSAwLjk1KSArICAjIFN0YXRpc3RpY2FsIGVsbGlwc2UsIDk1JSBjb25maWRlbmNlDQogIGdlb21fdGV4dChkYXRhID0gY2VudHJvaWRzLCBhZXMobGFiZWwgPSB0cmVhdG1lbnQsIHggPSBQQzEsIHkgPSBQQzIpLCB2anVzdCA9IC0xLCBoanVzdCA9IC0wLjEpICsgICMgQWRkIGNlbnRyb2lkcyBsYWJlbHMNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IHRydF9jb2xvcnMsIG5hbWUgPSBteV9jb2x1bW4pICsNCiAgZmFjZXRfZ3JpZCh+YHRpbWUtcG9pbnRgKSArICAjIEZhY2V0IGJ5IHRpbWUgcG9pbnQNCiAgeGxhYihwYXN0ZTAoIlBDMSAoIiwgcm91bmQoMTAwKndVRl9QQ09BJGRhdGEkUHJvcG9ydGlvbkV4cGxhaW5lZFsxXSwgZGlnaXRzID0gMiksICIlKSIpKSArDQogIHlsYWIocGFzdGUwKCJQQzIgKCIsIHJvdW5kKDEwMCp3VUZfUENPQSRkYXRhJFByb3BvcnRpb25FeHBsYWluZWRbMl0sIGRpZ2l0cyA9IDIpLCAiJSkiKSkgKw0KICB0aGVtZV9xMnIoKSArICAjIEN1c3RvbSB0aGVtZQ0KICBsYWJzKHRpdGxlID0gIndlaWdodGVkIFVuaUZyYWMgQmV0YSBEaXZlcnNpdHkiLCAgIyBTZXR0aW5nIHRoZSB0aXRsZQ0KICAgICAgIHN1YnRpdGxlID0gIkFuYWx5c2lzIGJ5IHRyZWF0bWVudCBhbmQgdGltZSBwb2ludHMiKSsNCiAgdGhlbWUoDQogICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTYpLCAgIyBJbmNyZWFzZSB0aXRsZSBmb250IHNpemUNCiAgICBwbG90LnN1YnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNiksICAjIEluY3JlYXNlIHN1YnRpdGxlIGZvbnQgc2l6ZQ0KICAgIGF4aXMudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE1KSwgICMgSW5jcmVhc2UgYXhpcyB0aXRsZXMgZm9udCBzaXplDQogICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE0KSwgICMgSW5jcmVhc2UgeCBheGlzIHRleHQgZm9udCBzaXplDQogICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE0KSwgICMgSW5jcmVhc2UgeSBheGlzIHRleHQgZm9udCBzaXplDQogICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNCksICAjIEluY3JlYXNlIGxlZ2VuZCB0aXRsZSBmb250IHNpemUNCiAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTIpICAgIyBJbmNyZWFzZSBsZWdlbmQgdGV4dCBmb250IHNpemUNCiAgKQ0Kd19VbmlGcmFjMg0KZ2dzYXZlKCIuL2FscGhhX2RpdmVyc2l0eV9wbG90cy93X1VuaUZyYWMyLnBuZyIsIGhlaWdodCA9IDcsIHdpZHRoID0gMTApDQoNCiNQRVJNT1ZBDQoNCnd1X2Rpc3RfbWF0PC1yZWFkX3F6YSgid2VpZ2h0ZWRfdW5pZnJhY19kaXN0YW5jZV9tYXRyaXgucXphIikNCnd1X2RtIDwtIGFzLm1hdHJpeCh3dV9kaXN0X21hdCRkYXRhKSANCnJvd25hbWVzKHd1X2RtKSA9PSBtZXRhZGF0YSRTYW1wbGVJRCAjIyBhbGwgdGhlc2UgdmFsdWVzIG5lZWQgdG8gYmUgIlRSVUUiDQptZXRhZGF0YV9zdWIgPC0gbWV0YWRhdGFbbWF0Y2gocm93bmFtZXMod3VfZG0pLG1ldGFkYXRhJFNhbXBsZUlEKSxdDQpyb3duYW1lcyh3dV9kbSkgPT0gbWV0YWRhdGFfc3ViJFNhbXBsZUlEICMjIGFsbCB0aGVzZSB2YWx1ZXMgbmVlZCB0byBiZSAiVFJVRSINCg0KUEVSTUFOT1ZBX291dDIgPC0gYWRvbmlzMih3dV9kbSAgfiB0cmVhdG1lbnQsIGRhdGEgPSBtZXRhZGF0YV9zdWIpDQpQRVJNQU5PVkFfb3V0MiANCg0KI3BhaXJ3aXNlIEFOT1ZBDQpwYWlyd2lzZS5hZG9uaXMzIDwtIGZ1bmN0aW9uKHgsIGRhdGEsIHN0cmF0YSA9IE5VTEwsIG5wZXJtPTk5OSwgLi4uICkgew0KICANCiAgI2Rlc2NyaWJlIHBhcmVudCBjYWxsIGZ1bmN0aW9uIA0KICBzdHN0cmkgPC0gaWZlbHNlKGlzLm51bGwoc3RyYXRhKSwnTnVsbCcsc3RyYXRhKQ0KICBmb3N0cmkgPC0gYXMuY2hhcmFjdGVyKHgpDQogICNsaXN0IHRvIHN0b3JlIHJlc3VsdHMNCiAgDQogICNjb3B5IG1vZGVsIGZvcm11bGENCiAgeDEgPC0geA0KICAjIGV4dHJhY3QgbGVmdCBoYW5kIHNpZGUgb2YgZm9ybXVsYQ0KICBsaHMgPC0geDFbWzJdXQ0KICAjIGV4dHJhY3QgZmFjdG9ycyBvbiByaWdodCBoYW5kIHNpZGUgb2YgZm9ybXVsYSANCiAgcmhzIDwtIHgxW1szXV0NCiAgIyBjcmVhdGUgbW9kZWwuZnJhbWUgbWF0cml4ICANCiAgeDFbWzJdXSA8LSBOVUxMICAgDQogIHJocy5mcmFtZSA8LSBtb2RlbC5mcmFtZSh4MSwgZGF0YSwgZHJvcC51bnVzZWQubGV2ZWxzID0gVFJVRSkgDQogIA0KICAjIGNyZWF0ZSB1bmlxdWUgcGFpcndpc2UgY29tYmluYXRpb24gb2YgZmFjdG9ycyANCiAgY28gPC0gY29tYm4odW5pcXVlKGFzLmNoYXJhY3RlcihyaHMuZnJhbWVbLDFdKSksMikNCiAgDQogICMgY3JlYXRlIG5hbWVzIHZlY3RvciAgIA0KICBuYW1lcmVzIDwtIGMoJ3BhcmVudF9jYWxsJykNCiAgZm9yIChlbGVtIGluIDE6bmNvbChjbykpew0KICAgIG5hbWVyZXMgPC0gYyhuYW1lcmVzLHBhc3RlKGNvWzEsZWxlbV0sY29bMixlbGVtXSxzZXA9J192c18nKSkNCiAgfQ0KICAjY3JlYXRlIHJlc3VsdHMgbGlzdCAgDQogIHJlcyA8LSB2ZWN0b3IobW9kZT0ibGlzdCIsIGxlbmd0aD1sZW5ndGgobmFtZXJlcykpDQogIG5hbWVzKHJlcykgPC0gbmFtZXJlcw0KICANCiAgI2FkZCBwYXJlbnQgY2FsbCB0byByZXMgDQogIHJlc1sncGFyZW50X2NhbGwnXSA8LSBsaXN0KHBhc3RlKGZvc3RyaVsyXSxmb3N0cmlbMV0sZm9zdHJpWzNdLCcsIHN0cmF0YSA9JyxzdHN0cmksICcsIHBlcm11dGF0aW9ucycsbnBlcm0gKSkNCiAgDQogIA0KICAjc3RhcnQgaXRlcmF0aW9uIHRyb3VnaCBwYWlyd2lzZSBjb21iaW5hdGlvbiBvZiBmYWN0b3JzICANCiAgZm9yKGVsZW0gaW4gMTpuY29sKGNvKSl7DQogICAgDQogICAgI3JlZHVjZSBtb2RlbCBlbGVtZW50cyAgDQogICAgaWYoaW5oZXJpdHMoZXZhbChsaHMpLCdkaXN0JykpewkNCiAgICAgIHhyZWQgPC0gYXMuZGlzdChhcy5tYXRyaXgoZXZhbChsaHMpKVtyaHMuZnJhbWVbLDFdICVpbiUgYyhjb1sxLGVsZW1dLGNvWzIsZWxlbV0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSldKQ0KICAgIH1lbHNlew0KICAgICAgeHJlZCA8LSBldmFsKGxocylbcmhzLmZyYW1lWywxXSAlaW4lIGMoY29bMSxlbGVtXSxjb1syLGVsZW1dKSxdDQogICAgfQ0KICAgIA0KICAgIG1kYXQxIDwtICBkYXRhW3Jocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSksXSANCiAgICANCiAgICAjIHJlZGVmaW5lIGZvcm11bGENCiAgICBpZihsZW5ndGgocmhzKSA9PSAxKXsNCiAgICAgIHhuZXcgPC0gYXMuZm9ybXVsYShwYXN0ZSgneHJlZCcsYXMuY2hhcmFjdGVyKHJocyksc2VwPSd+JykpCQ0KICAgIH1lbHNlew0KICAgICAgeG5ldyA8LSBhcy5mb3JtdWxhKHBhc3RlKCd4cmVkJyAsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlKHJoc1stMV0sY29sbGFwc2U9IGFzLmNoYXJhY3RlcihyaHNbMV0pKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXA9J34nKSl9DQogICAgDQogICAgI3Bhc3MgbmV3IGZvcm11bGEgdG8gYWRvbmlzDQogICAgaWYoaXMubnVsbChzdHJhdGEpKXsNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLCAuLi4gKQ0KICAgIH1lbHNlew0KICAgICAgcGVybSA8LSBob3cobnBlcm0gPSBucGVybSkNCiAgICAgIHNldEJsb2NrcyhwZXJtKSA8LSB3aXRoKG1kYXQxLCBtZGF0MVssc3RzdHJpXSkNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLHBlcm11dGF0aW9ucyA9IHBlcm0sIC4uLiApfQ0KICAgIA0KICAgIHJlc1tuYW1lcmVzW2VsZW0rMV1dIDwtIGxpc3QoYWRbMTo1XSkNCiAgfQ0KICAjbmFtZXMocmVzKSA8LSBuYW1lcyAgDQogIGNsYXNzKHJlcykgPC0gYygicHdhZHN0cmF0YSIsICJsaXN0IikNCiAgcmV0dXJuKHJlcykNCn0gDQoNCnRydF9QYWlyMiA8LSBwYWlyd2lzZS5hZG9uaXMzKHd1X2RtIH4gdHJlYXRtZW50LCBkYXRhID0gbWV0YWRhdGFfc3ViKQ0KdHJ0X1BhaXIyDQp3cml0ZS50YWJsZSh0cnRfUGFpcjIsIi4vYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL1dlaWdodGVkVW5pRnJhY19wYWlyd2lzZS5jc3YiLHNlcD0iLCIsIHJvdy5uYW1lcyA9IFRSVUUpIA0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQoNCiN1bldlaWdodGVkIFVOSUZSQUMNCnVud3VmX1BDT0EgPC0gcmVhZF9xemEoInVud2VpZ2h0ZWRfdW5pZnJhY19wY29hX3Jlc3VsdHMucXphIikNClVuV3VGX21ldGEgPC0gdW53dWZfUENPQSRkYXRhJFZlY3RvcnMgJT4lDQogIHNlbGVjdChTYW1wbGVJRCwgUEMxLCBQQzIsIFBDMykgJT4lDQogIGlubmVyX2pvaW4obWV0YWRhdGEsIGJ5ID0gYygiU2FtcGxlSUQiID0gIlNhbXBsZUlEIikpDQoNCiNvdmVyYWxsIHVuV2VpZ2h0ZWQgdW5pRnJhYw0KZ2dwbG90KFVuV3VGX21ldGEsIGFlcyh4PVBDMSwgeT1QQzIsIGNvbG9yPWdldChteV9jb2x1bW4pKSkgKw0KICBnZW9tX3BvaW50KGFlcyhzaGFwZT0gYHRpbWUtcG9pbnRgKSwgc2l6ZSA9IDMpICsgI2FscGhhIGNvbnRyb2xzIHRyYW5zcGFyZW5jeSBhbmQgaGVscHMgd2hlbiBwb2ludHMgYXJlIG92ZXJsYXBwaW5nDQogICNnZW9tX3BvaW50KGRhdGE9Y2VudHJvaWRzLCBzaXplID0gMykgKw0KICB0aGVtZV9xMnIoKSArDQogIHN0YXRfZWxsaXBzZShsZXZlbCA9IDAuOTUsIHR5cGUgPSAidCIpICsNCiAgeGxhYihwYXN0ZTAoIlBDMSAoIiwgcm91bmQoMTAwKnVud3VmX1BDT0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzFdLCBkaWdpdHMgPSAyKSwgIiUpIikpICsNCiAgeWxhYihwYXN0ZTAoIlBDMiAoIiwgcm91bmQoMTAwKnVud3VmX1BDT0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzJdLCBkaWdpdHMgPSAyKSwgIiUpIikpICsNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcz10cnRfY29sb3JzLCBuYW1lID0gInRyZWF0bWVudCIpDQoNCg0KY2VudHJvaWQzIDwtIGFnZ3JlZ2F0ZShjYmluZChQQzEsUEMyKX5nZXQobXlfY29sdW1uKSxVbld1Rl9tZXRhICxtZWFuKQ0KY29sbmFtZXMoY2VudHJvaWQzKVsxXSA8LSAidHJlYXRtZW50Ig0KDQp1d19VbmlGcmFjIDwtIGdncGxvdChVbld1Rl9tZXRhICwgYWVzKHg9UEMxLCB5PVBDMiwgY29sb3I9Z2V0KG15X2NvbHVtbikpKSArDQogIGdlb21fcG9pbnQoYWxwaGEgPSAwLjYsIHNpemUgPSAyKSArICAjIFBvaW50cyB3aXRoIHRyYW5zcGFyZW5jeQ0KICBzdGF0X2VsbGlwc2UodHlwZSA9ICJ0IiwgbGV2ZWwgPSAwLjk1KSArICAjIFN0YXRpc3RpY2FsIGVsbGlwc2UsIDk1JSBjb25maWRlbmNlDQogIGdlb21fdGV4dChkYXRhID0gY2VudHJvaWQzLCBhZXMobGFiZWwgPSB0cmVhdG1lbnQsIHggPSBQQzEsIHkgPSBQQzIpLCB2anVzdCA9IC0xLCBoanVzdCA9IC0wLjEpICsgICMgQWRkIGNlbnRyb2lkcyBsYWJlbHMNCiAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IHRydF9jb2xvcnMsIG5hbWUgPSBteV9jb2x1bW4pICsNCiAgZmFjZXRfZ3JpZCh+YHRpbWUtcG9pbnRgKSArICAjIEZhY2V0IGJ5IHRpbWUgcG9pbnQNCiAgeGxhYihwYXN0ZTAoIlBDMSAoIiwgcm91bmQoMTAwKnVud3VmX1BDT0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzFdLCBkaWdpdHMgPSAyKSwgIiUpIikpICsNCiAgeWxhYihwYXN0ZTAoIlBDMiAoIiwgcm91bmQoMTAwKnVud3VmX1BDT0EkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzJdLCBkaWdpdHMgPSAyKSwgIiUpIikpICsNCiAgdGhlbWVfcTJyKCkgKyAgIyBDdXN0b20gdGhlbWUNCiAgbGFicyh0aXRsZSA9ICJVbndlaWdodGVkIFVuaUZyYWMgQmV0YSBEaXZlcnNpdHkiLCAgIyBTZXR0aW5nIHRoZSB0aXRsZQ0KICAgICAgIHN1YnRpdGxlID0gIkFuYWx5c2lzIGJ5IHRyZWF0bWVudCBhbmQgdGltZSBwb2ludHMiKSsNCiAgdGhlbWUoDQogICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTYpLCAgIyBJbmNyZWFzZSB0aXRsZSBmb250IHNpemUNCiAgICBwbG90LnN1YnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNiksICAjIEluY3JlYXNlIHN1YnRpdGxlIGZvbnQgc2l6ZQ0KICAgIGF4aXMudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE1KSwgICMgSW5jcmVhc2UgYXhpcyB0aXRsZXMgZm9udCBzaXplDQogICAgYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE0KSwgICMgSW5jcmVhc2UgeCBheGlzIHRleHQgZm9udCBzaXplDQogICAgYXhpcy50ZXh0LnkgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE0KSwgICMgSW5jcmVhc2UgeSBheGlzIHRleHQgZm9udCBzaXplDQogICAgbGVnZW5kLnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNCksICAjIEluY3JlYXNlIGxlZ2VuZCB0aXRsZSBmb250IHNpemUNCiAgICBsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTIpICAgIyBJbmNyZWFzZSBsZWdlbmQgdGV4dCBmb250IHNpemUNCiAgKQ0KdXdfVW5pRnJhYyANCmdnc2F2ZSgiLi9hbHBoYV9kaXZlcnNpdHlfcGxvdHMvdXdfVW5pRnJhYzIucG5nIiwgaGVpZ2h0ID0gNywgd2lkdGggPSAxMCkNCg0KI1BFUk1PVkENCg0KdW53dV9kaXN0X21hdDwtcmVhZF9xemEoInVud2VpZ2h0ZWRfdW5pZnJhY19kaXN0YW5jZV9tYXRyaXgucXphIikNCnVud3VfZG0gPC0gYXMubWF0cml4KHVud3VfZGlzdF9tYXQkZGF0YSkgDQpyb3duYW1lcyh1bnd1X2RtKSA9PSBtZXRhZGF0YSRTYW1wbGVJRCAjIyBhbGwgdGhlc2UgdmFsdWVzIG5lZWQgdG8gYmUgIlRSVUUiDQptZXRhZGF0YV9zdWIzIDwtIG1ldGFkYXRhW21hdGNoKHJvd25hbWVzKHVud3VfZG0pLG1ldGFkYXRhJFNhbXBsZUlEKSxdDQpyb3duYW1lcyh1bnd1X2RtKSA9PSBtZXRhZGF0YV9zdWIzJFNhbXBsZUlEICMjIGFsbCB0aGVzZSB2YWx1ZXMgbmVlZCB0byBiZSAiVFJVRSINCg0KUEVSTV91biA8LSBhZG9uaXMyKHVud3VfZG0gIH4gdHJlYXRtZW50LCBkYXRhID0gbWV0YWRhdGFfc3ViMykNClBFUk1fdW4NCg0KI3BhaXJ3aXNlIEFOT1ZBDQpwYWlyd2lzZS5hZG9uaXM0IDwtIGZ1bmN0aW9uKHgsIGRhdGEsIHN0cmF0YSA9IE5VTEwsIG5wZXJtPTk5OSwgLi4uICkgew0KICANCiAgI2Rlc2NyaWJlIHBhcmVudCBjYWxsIGZ1bmN0aW9uIA0KICBzdHN0cmkgPC0gaWZlbHNlKGlzLm51bGwoc3RyYXRhKSwnTnVsbCcsc3RyYXRhKQ0KICBmb3N0cmkgPC0gYXMuY2hhcmFjdGVyKHgpDQogICNsaXN0IHRvIHN0b3JlIHJlc3VsdHMNCiAgDQogICNjb3B5IG1vZGVsIGZvcm11bGENCiAgeDEgPC0geA0KICAjIGV4dHJhY3QgbGVmdCBoYW5kIHNpZGUgb2YgZm9ybXVsYQ0KICBsaHMgPC0geDFbWzJdXQ0KICAjIGV4dHJhY3QgZmFjdG9ycyBvbiByaWdodCBoYW5kIHNpZGUgb2YgZm9ybXVsYSANCiAgcmhzIDwtIHgxW1szXV0NCiAgIyBjcmVhdGUgbW9kZWwuZnJhbWUgbWF0cml4ICANCiAgeDFbWzJdXSA8LSBOVUxMICAgDQogIHJocy5mcmFtZSA8LSBtb2RlbC5mcmFtZSh4MSwgZGF0YSwgZHJvcC51bnVzZWQubGV2ZWxzID0gVFJVRSkgDQogIA0KICAjIGNyZWF0ZSB1bmlxdWUgcGFpcndpc2UgY29tYmluYXRpb24gb2YgZmFjdG9ycyANCiAgY28gPC0gY29tYm4odW5pcXVlKGFzLmNoYXJhY3RlcihyaHMuZnJhbWVbLDFdKSksMikNCiAgDQogICMgY3JlYXRlIG5hbWVzIHZlY3RvciAgIA0KICBuYW1lcmVzIDwtIGMoJ3BhcmVudF9jYWxsJykNCiAgZm9yIChlbGVtIGluIDE6bmNvbChjbykpew0KICAgIG5hbWVyZXMgPC0gYyhuYW1lcmVzLHBhc3RlKGNvWzEsZWxlbV0sY29bMixlbGVtXSxzZXA9J192c18nKSkNCiAgfQ0KICAjY3JlYXRlIHJlc3VsdHMgbGlzdCAgDQogIHJlcyA8LSB2ZWN0b3IobW9kZT0ibGlzdCIsIGxlbmd0aD1sZW5ndGgobmFtZXJlcykpDQogIG5hbWVzKHJlcykgPC0gbmFtZXJlcw0KICANCiAgI2FkZCBwYXJlbnQgY2FsbCB0byByZXMgDQogIHJlc1sncGFyZW50X2NhbGwnXSA8LSBsaXN0KHBhc3RlKGZvc3RyaVsyXSxmb3N0cmlbMV0sZm9zdHJpWzNdLCcsIHN0cmF0YSA9JyxzdHN0cmksICcsIHBlcm11dGF0aW9ucycsbnBlcm0gKSkNCiAgDQogIA0KICAjc3RhcnQgaXRlcmF0aW9uIHRyb3VnaCBwYWlyd2lzZSBjb21iaW5hdGlvbiBvZiBmYWN0b3JzICANCiAgZm9yKGVsZW0gaW4gMTpuY29sKGNvKSl7DQogICAgDQogICAgI3JlZHVjZSBtb2RlbCBlbGVtZW50cyAgDQogICAgaWYoaW5oZXJpdHMoZXZhbChsaHMpLCdkaXN0JykpewkNCiAgICAgIHhyZWQgPC0gYXMuZGlzdChhcy5tYXRyaXgoZXZhbChsaHMpKVtyaHMuZnJhbWVbLDFdICVpbiUgYyhjb1sxLGVsZW1dLGNvWzIsZWxlbV0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSldKQ0KICAgIH1lbHNlew0KICAgICAgeHJlZCA8LSBldmFsKGxocylbcmhzLmZyYW1lWywxXSAlaW4lIGMoY29bMSxlbGVtXSxjb1syLGVsZW1dKSxdDQogICAgfQ0KICAgIA0KICAgIG1kYXQxIDwtICBkYXRhW3Jocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSksXSANCiAgICANCiAgICAjIHJlZGVmaW5lIGZvcm11bGENCiAgICBpZihsZW5ndGgocmhzKSA9PSAxKXsNCiAgICAgIHhuZXcgPC0gYXMuZm9ybXVsYShwYXN0ZSgneHJlZCcsYXMuY2hhcmFjdGVyKHJocyksc2VwPSd+JykpCQ0KICAgIH1lbHNlew0KICAgICAgeG5ldyA8LSBhcy5mb3JtdWxhKHBhc3RlKCd4cmVkJyAsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlKHJoc1stMV0sY29sbGFwc2U9IGFzLmNoYXJhY3RlcihyaHNbMV0pKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXA9J34nKSl9DQogICAgDQogICAgI3Bhc3MgbmV3IGZvcm11bGEgdG8gYWRvbmlzDQogICAgaWYoaXMubnVsbChzdHJhdGEpKXsNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLCAuLi4gKQ0KICAgIH1lbHNlew0KICAgICAgcGVybSA8LSBob3cobnBlcm0gPSBucGVybSkNCiAgICAgIHNldEJsb2NrcyhwZXJtKSA8LSB3aXRoKG1kYXQxLCBtZGF0MVssc3RzdHJpXSkNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLHBlcm11dGF0aW9ucyA9IHBlcm0sIC4uLiApfQ0KICAgIA0KICAgIHJlc1tuYW1lcmVzW2VsZW0rMV1dIDwtIGxpc3QoYWRbMTo1XSkNCiAgfQ0KICAjbmFtZXMocmVzKSA8LSBuYW1lcyAgDQogIGNsYXNzKHJlcykgPC0gYygicHdhZHN0cmF0YSIsICJsaXN0IikNCiAgcmV0dXJuKHJlcykNCn0gDQoNCnRydF9QYWlyMyA8LSBwYWlyd2lzZS5hZG9uaXM0KHVud3VfZG0gfiB0cmVhdG1lbnQsIGRhdGEgPSBtZXRhZGF0YV9zdWIzKQ0KdHJ0X1BhaXIzDQp3cml0ZS50YWJsZSh0cnRfUGFpcjMsIi4vYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL3VuV2VpZ2h0ZWRVbmlGcmFjX3BhaXJ3aXNlLmNzdiIsc2VwPSIsIiwgcm93Lm5hbWVzID0gVFJVRSkgDQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KI2phY2NhcmQNCmphY19QQ29BIDwtIHJlYWRfcXphKCJqYWNjYXJkX3Bjb2FfcmVzdWx0cy5xemEiKQ0KamFjX21ldGEgIDwtIGphY19QQ29BJGRhdGEkVmVjdG9ycyAlPiUNCiAgc2VsZWN0KFNhbXBsZUlELCBQQzEsIFBDMiwgUEMzKSAlPiUNCiAgaW5uZXJfam9pbihtZXRhZGF0YSwgYnkgPSBjKCJTYW1wbGVJRCIgPSAiU2FtcGxlSUQiKSkNCg0KIyBOb3cgd2UgYXJlIGdvaW5nIHRvIG1ha2UgYW4gb3JkaW5hdGlvbiBwbG90DQpnZ3Bsb3QoamFjX21ldGEgLCBhZXMoeD1QQzEsIHk9UEMyLCBjb2xvcj10cmVhdG1lbnQpKSArDQogIGdlb21fcG9pbnQoKSArICNhbHBoYSBjb250cm9scyB0cmFuc3BhcmVuY3kgYW5kIGhlbHBzIHdoZW4gcG9pbnRzIGFyZSBvdmVybGFwcGluZw0KICB0aGVtZV9xMnIoKSArDQogIHhsYWIoIlBDMSAoMzIuMjclKSIpICsNCiAgeWxhYigiUEMyICgyMi4yOCUpIikgKw0KICBzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzPWMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKSwgbmFtZSA9ICJUcmVhdG1lbnQiKQ0KDQojIE5vdyB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBvdXIgY29kZSBhIGxpdHRsZSBtb3JlIHJlLXVzYWJsZQ0KbXlfY29sdW1uIDwtICJ0cmVhdG1lbnQiDQoNCmdncGxvdChqYWNfbWV0YSAsIGFlcyh4PVBDMSwgeT1QQzIsIGNvbG9yPWdldChteV9jb2x1bW4pKSkgKw0KICBnZW9tX3BvaW50KCkgKyAjYWxwaGEgY29udHJvbHMgdHJhbnNwYXJlbmN5IGFuZCBoZWxwcyB3aGVuIHBvaW50cyBhcmUgb3ZlcmxhcHBpbmcNCiAgdGhlbWVfcTJyKCkgKw0KICBmYWNldF9ncmlkKH5gdGltZS1wb2ludGApICsNCiAgeGxhYihwYXN0ZTAoIlBDMSAoIiwgcm91bmQoMTAwKmphY19QQ29BICRkYXRhJFByb3BvcnRpb25FeHBsYWluZWRbMV0sIGRpZ2l0cyA9IDIpLCAiJSkiKSkgKw0KICB5bGFiKHBhc3RlMCgiUEMyICgiLCByb3VuZCgxMDAqamFjX1BDb0EgJGRhdGEkUHJvcG9ydGlvbkV4cGxhaW5lZFsyXSwgZGlnaXRzID0gMiksICIlKSIpKSArDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXM9dHJ0X2NvbG9ycywgbmFtZSA9IG15X2NvbHVtbikNCg0KI2FwcGx5IGNlbnRyb2lkcw0KDQpjZW50cm9pZGogPC0gYWdncmVnYXRlKGNiaW5kKFBDMSxQQzIpfmdldChteV9jb2x1bW4pLGphY19tZXRhICxtZWFuKQ0KY29sbmFtZXMoY2VudHJvaWRqKVsxXSA8LSAidHJlYXRtZW50Ig0KDQpwbG90amFjIDwtIGdncGxvdChqYWNfbWV0YSAsIGFlcyh4ID0gUEMxLCB5ID0gUEMyLCBjb2xvciA9IGdldChteV9jb2x1bW4pKSkgKw0KICBnZW9tX3BvaW50KGFscGhhID0gMC42LCBzaXplID0gMikgKyAgIyBQb2ludHMgd2l0aCB0cmFuc3BhcmVuY3kNCiAgc3RhdF9lbGxpcHNlKHR5cGUgPSAidCIsIGxldmVsID0gMC45NSkgKyAgIyBTdGF0aXN0aWNhbCBlbGxpcHNlLCA5NSUgY29uZmlkZW5jZQ0KICBnZW9tX3RleHQoZGF0YSA9IGNlbnRyb2lkaiwgYWVzKGxhYmVsID0gdHJlYXRtZW50LCB4ID0gUEMxLCB5ID0gUEMyKSwgdmp1c3QgPSAtMSwgaGp1c3QgPSAtMC4xKSArICAjIEFkZCBjZW50cm9pZGogbGFiZWxzDQogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSB0cnRfY29sb3JzLCBuYW1lID0gbXlfY29sdW1uKSArDQogIGZhY2V0X2dyaWQofmB0aW1lLXBvaW50YCkgKyAgIyBGYWNldCBieSB0aW1lIHBvaW50DQogIHhsYWIocGFzdGUwKCJQQzEgKCIsIHJvdW5kKDEwMCAqIGphY19QQ29BICRkYXRhJFByb3BvcnRpb25FeHBsYWluZWRbMV0sIDIpLCAiJSkiKSkgKw0KICB5bGFiKHBhc3RlMCgiUEMyICgiLCByb3VuZCgxMDAgKiBqYWNfUENvQSAkZGF0YSRQcm9wb3J0aW9uRXhwbGFpbmVkWzJdLCAyKSwgIiUpIikpICsNCiAgdGhlbWVfcTJyKCkgKyAgIyBDdXN0b20gdGhlbWUNCiAgbGFicyh0aXRsZSA9ICIgSmFjY2FyZCBTaW1pbGFyaXR5ICIsICAjIFNldHRpbmcgdGhlIHRpdGxlDQogICAgICAgc3VidGl0bGUgPSAiQW5hbHlzaXMgYnkgdHJlYXRtZW50IGFuZCB0aW1lIHBvaW50cyIpKw0KICB0aGVtZSgNCiAgICBwbG90LnRpdGxlID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNiksICAjIEluY3JlYXNlIHRpdGxlIGZvbnQgc2l6ZQ0KICAgIHBsb3Quc3VidGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE2KSwgICMgSW5jcmVhc2Ugc3VidGl0bGUgZm9udCBzaXplDQogICAgYXhpcy50aXRsZSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTUpLCAgIyBJbmNyZWFzZSBheGlzIHRpdGxlcyBmb250IHNpemUNCiAgICBheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChzaXplID0gMTQpLCAgIyBJbmNyZWFzZSB4IGF4aXMgdGV4dCBmb250IHNpemUNCiAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfdGV4dChzaXplID0gMTQpLCAgIyBJbmNyZWFzZSB5IGF4aXMgdGV4dCBmb250IHNpemUNCiAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X3RleHQoc2l6ZSA9IDE0KSwgICMgSW5jcmVhc2UgbGVnZW5kIHRpdGxlIGZvbnQgc2l6ZQ0KICAgIGxlZ2VuZC50ZXh0ID0gZWxlbWVudF90ZXh0KHNpemUgPSAxNCkgICAjIEluY3JlYXNlIGxlZ2VuZCB0ZXh0IGZvbnQgc2l6ZQ0KICApDQpwbG90amFjDQpnZ3NhdmUoIi4vYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL3Bsb3RqYWMucG5nIiwgaGVpZ2h0ID0gNywgd2lkdGggPSAxMCkNCg0KamFjY19kaXN0X21hdDwtcmVhZF9xemEoImphY2NhcmRfZGlzdGFuY2VfbWF0cml4LnF6YSIpDQpqYWNjX2RtIDwtIGFzLm1hdHJpeChqYWNjX2Rpc3RfbWF0JGRhdGEpIA0Kcm93bmFtZXMoamFjY19kbSkgPT0gbWV0YWRhdGEkU2FtcGxlSUQgIyMgYWxsIHRoZXNlIHZhbHVlcyBuZWVkIHRvIGJlICJUUlVFIg0KbWV0YWRhdGFfc3ViaiA8LSBtZXRhZGF0YVttYXRjaChyb3duYW1lcyhqYWNjX2RtKSxtZXRhZGF0YSRTYW1wbGVJRCksXQ0Kcm93bmFtZXMoamFjY19kbSkgPT0gbWV0YWRhdGFfc3ViaiRTYW1wbGVJRCAjIyBhbGwgdGhlc2UgdmFsdWVzIG5lZWQgdG8gYmUgIlRSVUUiDQoNClBFUk1qYWMgPC0gYWRvbmlzMihqYWNjX2RtIH4gdHJlYXRtZW50LCBkYXRhID0gbWV0YWRhdGFfc3ViaikNClBFUk1qYWMgDQojIyAgUGFpcndpc2UgYWRvbmlzIGZ1bmN0aW9uDQpwYWlyd2lzZS5hZG9uaXMyIDwtIGZ1bmN0aW9uKHgsIGRhdGEsIHN0cmF0YSA9IE5VTEwsIG5wZXJtPTk5OSwgLi4uICkgew0KICANCiAgI2Rlc2NyaWJlIHBhcmVudCBjYWxsIGZ1bmN0aW9uIA0KICBzdHN0cmkgPC0gaWZlbHNlKGlzLm51bGwoc3RyYXRhKSwnTnVsbCcsc3RyYXRhKQ0KICBmb3N0cmkgPC0gYXMuY2hhcmFjdGVyKHgpDQogICNsaXN0IHRvIHN0b3JlIHJlc3VsdHMNCiAgDQogICNjb3B5IG1vZGVsIGZvcm11bGENCiAgeDEgPC0geA0KICAjIGV4dHJhY3QgbGVmdCBoYW5kIHNpZGUgb2YgZm9ybXVsYQ0KICBsaHMgPC0geDFbWzJdXQ0KICAjIGV4dHJhY3QgZmFjdG9ycyBvbiByaWdodCBoYW5kIHNpZGUgb2YgZm9ybXVsYSANCiAgcmhzIDwtIHgxW1szXV0NCiAgIyBjcmVhdGUgbW9kZWwuZnJhbWUgbWF0cml4ICANCiAgeDFbWzJdXSA8LSBOVUxMICAgDQogIHJocy5mcmFtZSA8LSBtb2RlbC5mcmFtZSh4MSwgZGF0YSwgZHJvcC51bnVzZWQubGV2ZWxzID0gVFJVRSkgDQogIA0KICAjIGNyZWF0ZSB1bmlxdWUgcGFpcndpc2UgY29tYmluYXRpb24gb2YgZmFjdG9ycyANCiAgY28gPC0gY29tYm4odW5pcXVlKGFzLmNoYXJhY3RlcihyaHMuZnJhbWVbLDFdKSksMikNCiAgDQogICMgY3JlYXRlIG5hbWVzIHZlY3RvciAgIA0KICBuYW1lcmVzIDwtIGMoJ3BhcmVudF9jYWxsJykNCiAgZm9yIChlbGVtIGluIDE6bmNvbChjbykpew0KICAgIG5hbWVyZXMgPC0gYyhuYW1lcmVzLHBhc3RlKGNvWzEsZWxlbV0sY29bMixlbGVtXSxzZXA9J192c18nKSkNCiAgfQ0KICAjY3JlYXRlIHJlc3VsdHMgbGlzdCAgDQogIHJlcyA8LSB2ZWN0b3IobW9kZT0ibGlzdCIsIGxlbmd0aD1sZW5ndGgobmFtZXJlcykpDQogIG5hbWVzKHJlcykgPC0gbmFtZXJlcw0KICANCiAgI2FkZCBwYXJlbnQgY2FsbCB0byByZXMgDQogIHJlc1sncGFyZW50X2NhbGwnXSA8LSBsaXN0KHBhc3RlKGZvc3RyaVsyXSxmb3N0cmlbMV0sZm9zdHJpWzNdLCcsIHN0cmF0YSA9JyxzdHN0cmksICcsIHBlcm11dGF0aW9ucycsbnBlcm0gKSkNCiAgDQogIA0KICAjc3RhcnQgaXRlcmF0aW9uIHRyb3VnaCBwYWlyd2lzZSBjb21iaW5hdGlvbiBvZiBmYWN0b3JzICANCiAgZm9yKGVsZW0gaW4gMTpuY29sKGNvKSl7DQogICAgDQogICAgI3JlZHVjZSBtb2RlbCBlbGVtZW50cyAgDQogICAgaWYoaW5oZXJpdHMoZXZhbChsaHMpLCdkaXN0JykpewkNCiAgICAgIHhyZWQgPC0gYXMuZGlzdChhcy5tYXRyaXgoZXZhbChsaHMpKVtyaHMuZnJhbWVbLDFdICVpbiUgYyhjb1sxLGVsZW1dLGNvWzIsZWxlbV0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSldKQ0KICAgIH1lbHNlew0KICAgICAgeHJlZCA8LSBldmFsKGxocylbcmhzLmZyYW1lWywxXSAlaW4lIGMoY29bMSxlbGVtXSxjb1syLGVsZW1dKSxdDQogICAgfQ0KICAgIA0KICAgIG1kYXQxIDwtICBkYXRhW3Jocy5mcmFtZVssMV0gJWluJSBjKGNvWzEsZWxlbV0sY29bMixlbGVtXSksXSANCiAgICANCiAgICAjIHJlZGVmaW5lIGZvcm11bGENCiAgICBpZihsZW5ndGgocmhzKSA9PSAxKXsNCiAgICAgIHhuZXcgPC0gYXMuZm9ybXVsYShwYXN0ZSgneHJlZCcsYXMuY2hhcmFjdGVyKHJocyksc2VwPSd+JykpCQ0KICAgIH1lbHNlew0KICAgICAgeG5ldyA8LSBhcy5mb3JtdWxhKHBhc3RlKCd4cmVkJyAsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlKHJoc1stMV0sY29sbGFwc2U9IGFzLmNoYXJhY3RlcihyaHNbMV0pKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXA9J34nKSl9DQogICAgDQogICAgI3Bhc3MgbmV3IGZvcm11bGEgdG8gYWRvbmlzDQogICAgaWYoaXMubnVsbChzdHJhdGEpKXsNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLCAuLi4gKQ0KICAgIH1lbHNlew0KICAgICAgcGVybSA8LSBob3cobnBlcm0gPSBucGVybSkNCiAgICAgIHNldEJsb2NrcyhwZXJtKSA8LSB3aXRoKG1kYXQxLCBtZGF0MVssc3RzdHJpXSkNCiAgICAgIGFkIDwtIGFkb25pczIoeG5ldyxkYXRhPW1kYXQxLHBlcm11dGF0aW9ucyA9IHBlcm0sIC4uLiApfQ0KICAgIA0KICAgIHJlc1tuYW1lcmVzW2VsZW0rMV1dIDwtIGxpc3QoYWRbMTo1XSkNCiAgfQ0KICAjbmFtZXMocmVzKSA8LSBuYW1lcyAgDQogIGNsYXNzKHJlcykgPC0gYygicHdhZHN0cmF0YSIsICJsaXN0IikNCiAgcmV0dXJuKHJlcykNCn0gDQoNCnRydF9QYWlyNCA8LSBwYWlyd2lzZS5hZG9uaXMyKGphY2NfZG0gfiB0cmVhdG1lbnQsIGRhdGEgPSBtZXRhZGF0YV9zdWJqKQ0KdHJ0X1BhaXI0DQp3cml0ZS50YWJsZSh0cnRfUGFpcjQsIi4vYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL0JKYWNjYXJkX0Fkb25pc19wYWlyd2lzZS5jc3YiLHNlcD0iLCIsIHJvdy5uYW1lcyA9IFRSVUUpDQpgYGANCg0KRGlmZmVyZW50IGRpZmZlcmVudGlhbCBhYnVuZGFuY2UgbWV0aG9kDQpgYGB7cn0NCiNjaGVjayBoZXJlIGZvciBiZXR0ZXIgY29kZSB0byB0cmFpbiA6IGh0dHBzOi8vcnB1YnMuY29tL2tqb2plc3MvMTAxMzUyNw0KbWV0YWRhdGE8LXJlYWRfcTJtZXRhZGF0YSgicHJvamVjdF9tZXRhZGF0YS50eHQiKQ0Kc3RyKG1ldGFkYXRhKQ0KbGV2ZWxzKG1ldGFkYXRhJGBib2R5LXNpdGVgKQ0KY29sbmFtZXMobWV0YWRhdGEpWzJdIDwtICJ0aW1lLXBvaW50Ig0KY29sbmFtZXMobWV0YWRhdGEpWzZdIDwtICJ0cmVhdG1lbnQiDQpzdHIobWV0YWRhdGEpDQoNCiNCRUxPVyBJUyBGT1IgR0VUVElORyBUSEUgTEVGU0UgVEFCTEUNCg0KIyMgU2VsZWN0IGFuZCBrZWVwIHRoZSBjb2x1bW5zIHlvdSBuZWVkIHRvIHVzZSBhczoNCiMjICAgIGNsYXNzLCBzdWJjbGFzcyAob3B0aW9uYWwpIGFuZCBzdWJqZWN0DQptZXRhZGF0YV9maWx0ZXJlZCA8LSBtZXRhZGF0YSAlPiUNCiAgc2VsZWN0KFNhbXBsZUlELCB0cmVhdG1lbnQsIGB0aW1lLXBvaW50YCkNCnN0cihtZXRhZGF0YV9maWx0ZXJlZCkNCg0KIyBSZWFkIGluIG91cHV0IGZyb20gcWlpbWUyDQp0YXhvbm9teSA8LSByZWFkLmRlbGltKCJmcmVxdWVuY3ktdGFibGUtbDYudHh0Iiwgc2tpcCA9IDEpDQpoZWFkKHRheG9ub215KQ0Kc3RyKHRheG9ub215KQ0KIyBTb21lIHJlZm9ybWF0dGluZw0KY29sbmFtZXModGF4b25vbXkpWzFdIDwtICJUYXhvbiINCnRheG9ub215IDwtIHRheG9ub215WywtKG5jb2wodGF4b25vbXkpKV0NCnRheG9ub215JEZlYXR1cmUuSUQgPC0gcGFzdGUwKCJBU1YiLCAxOm5yb3codGF4b25vbXkpKQ0KDQojIHNwbGl0IHRoZSB0YXhvbm9teSBpbnRvIG9uZSBsZXZlbCBwZXIgY29sdW1uIGFuZCByZW1vdmUgdGhlICJLX18iIHN0dWZmDQp0YXguY2xlYW48LXBhcnNlX3RheG9ub215KHRheG9ub215ID0gdGF4b25vbXksIHRheF9zZXAgPSAiOyIpDQp0YXguY2xlYW4gPC0gdGF4LmNsZWFuWywtN10NCmhlYWQodGF4LmNsZWFuKQ0KDQojIE1ha2UgdGhlIHVuY2xhc3NpZmllZCBjZWxscyBiZSBlbXB0eSBzbyB0aGF0IHdlIGNhbiBlZGl0IHRoZW0gDQp0YXguY2xlYW5bdGF4LmNsZWFuPT0iX18iXSA8LSAiIg0KdGF4LmNsZWFuW2lzLm5hKHRheC5jbGVhbildIDwtICIiDQoNCm5jb2wodGF4LmNsZWFuKSAjI1RoaXMgc2hvdWxkIGVxdWFsIDYuIElmIG5vdCB0aGUgY29kZSB3aWxsIG5lZWQgdG8gYmUgbW9kaWZpZWQuDQoNCiMgQ2hhbmdlIGVtcHR5IGNlbGxzIHRvIHNheSAidW5jbGFzc2lmaWVkIiB3aXRoIHRoZSBsYXN0IGFzc2lnbmVkIHRheG9ub21pYyBsZXZlbA0KZm9yIChpIGluIDE6bnJvdyh0YXguY2xlYW4pKXsNCiAgaWYgKHRheC5jbGVhbltpLDJdID09ICIiKXsNCiAgICBraW5nZG9tIDwtIHBhc3RlKCJ1bmNsYXNzaWZpZWRfIiwgdGF4LmNsZWFuW2ksMV0sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCAyOm5jb2wodGF4LmNsZWFuKV0gPC0ga2luZ2RvbQ0KICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDNdID09ICIiKXsNCiAgICBwaHlsdW0gPC0gcGFzdGUoInVuY2xhc3NpZmllZF8iLCB0YXguY2xlYW5baSwyXSwgc2VwID0gIiIpDQogICAgdGF4LmNsZWFuW2ksIDM6bmNvbCh0YXguY2xlYW4pXSA8LSBwaHlsdW0NCiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw0XSA9PSAiIil7DQogICAgY2xhc3MgPC0gcGFzdGUoInVuY2xhc3NpZmllZF8iLCB0YXguY2xlYW5baSwzXSwgc2VwID0gIiIpDQogICAgdGF4LmNsZWFuW2ksIDQ6bmNvbCh0YXguY2xlYW4pXSA8LSBjbGFzcw0KICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDVdID09ICIiKXsNCiAgICBvcmRlciA8LSBwYXN0ZSgidW5jbGFzc2lmaWVkXyIsIHRheC5jbGVhbltpLDRdLCBzZXAgPSAiIikNCiAgICB0YXguY2xlYW5baSwgNTpuY29sKHRheC5jbGVhbildIDwtIG9yZGVyDQogIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNl0gPT0gIiIpew0KICAgIGZhbWlseSA8LSBwYXN0ZSgidW5jbGFzc2lmaWVkXyIsIHRheC5jbGVhbltpLDVdLCBzZXAgPSAiIikNCiAgICB0YXguY2xlYW5baSwgNjpuY29sKHRheC5jbGVhbildIDwtIGZhbWlseQ0KICB9IA0KfQ0KDQojIE5vdyBmaW5pc2ggdXAgZm9ybWF0dGluZyBpbnRvIHRoZSBmb3JtYXQgcmVxdWlyZWQgYnkgbGVmc2UNCg0KIyBHZXQgdGF4b25vbXkgaW50byBvbmUgY2VsbCBzZXBhcmF0ZWQgYnkgInwiDQp0YXguY2xlYW5fbGVmc2UgPC0gdGF4LmNsZWFuICU+JQ0KICB1bml0ZSgibGVmc2UiLCBLaW5nZG9tOkdlbnVzLCBzZXA9ICJ8IiwgDQogICAgICAgIHJlbW92ZSA9IEZBTFNFKQ0KDQojIE1lcmdlIHRheG9ub215IHdpdGggcmVsYXRpdmUgYWJ1bmRhbmNlIGZvciBlYWNoIHNhbXBsZQ0KdGF4LmNsZWFuX2xlZnNlIDwtIG1lcmdlKHRheC5jbGVhbl9sZWZzZSwgdGF4b25vbXksIGJ5LnggPSAwLCBieS55ID0gIkZlYXR1cmUuSUQiKQ0KdGF4LmNsZWFuX2xlZnNlIDwtIHRheC5jbGVhbl9sZWZzZVssLTM6LTldDQoNCiMgQ29udmVydCB0LnRheCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBmb3JtIGFuZCBwcmVwYXJlIGl0IGZvciBtZXJnaW5nDQp0YXhfZGYgPC0gYXMuZGF0YS5mcmFtZSh0KHQudGF4KSkgICMgVHJhbnNwb3NlIGl0IGJhY2sNCmNvbG5hbWVzKHRheF9kZikgPC0gdGF4X2RmWzEsIF0gICMgQXNzdW1pbmcgdGhlIGZpcnN0IHJvdyBjb250YWlucyBjb2x1bW4gbmFtZXMgKHNhbXBsZSBJRHMpDQp0YXhfZGYgPC0gdGF4X2RmWy0xLCBdICAjIFJlbW92ZSB0aGUgZmlyc3Qgcm93IG5vdyB0aGF0IGl0J3MgdXNlZCBhcyBjb2x1bW4gbmFtZXMNCg0KIyBBZGQgcm93IG5hbWVzIGFzIGEgY29sdW1uIGZvciBtZXJnaW5nIChBU1YgaWRlbnRpZmllcnMpDQp0YXhfZGYkQVNWIDwtIHJvd25hbWVzKHRheF9kZikNCg0KIyBBZGp1c3QgU2FtcGxlIElEIGZvcm1hdHMgaW4gbWV0YWRhdGFfZmlsdGVyZWQgaWYgbmVjZXNzYXJ5DQptZXRhZGF0YV9maWx0ZXJlZCRTYW1wbGVJRCA8LSBhcy5jaGFyYWN0ZXIobWV0YWRhdGFfZmlsdGVyZWQkU2FtcGxlSUQpICAjIE1ha2Ugc3VyZSBpdCdzIGNoYXJhY3Rlcg0KbWV0YWRhdGFfZmlsdGVyZWQkU2FtcGxlSUQgPC0gZ3N1YigiLSIsICIuIiwgbWV0YWRhdGFfZmlsdGVyZWQkU2FtcGxlSUQpICAjIFJlcGxhY2UgZGFzaGVzIHdpdGggZG90cyBpZiBuZWNlc3NhcnkNCg0KIyBNZXJnZSB0aGUgZGF0YSBmcmFtZXMNCiMgQXNzdW1pbmcgdGhhdCBzYW1wbGUgSURzIGluIHRheF9kZiBhcmUgbm93IGNvcnJlY3RseSBmb3JtYXR0ZWQgdG8gbWF0Y2ggdGhvc2UgaW4gbWV0YWRhdGFfZmlsdGVyZWQNCiMgVGhlIG1lcmdpbmcga2V5IGluIHRheF9kZiBuZWVkcyB0byBiZSBjaGVja2VkIGlmIGl0J3MgaW4gY29sdW1uIG5hbWVzIG9yIG5lZWRzIHRvIGJlIGNvbnN0cnVjdGVkIGZyb20gcm93IG5hbWVzDQptZXJnZWRfZGF0YSA8LSBtZXJnZShtZXRhZGF0YV9maWx0ZXJlZCwgdGF4X2RmLCBieS54ID0gIlNhbXBsZUlEIiwgYnkueSA9ICJBU1YiLCBhbGwgPSBUUlVFKQ0KDQojIENoZWNrIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG1lcmdlZCBkYXRhDQpzdHIobWVyZ2VkX2RhdGEpDQoNCiMgU2F2ZSBmaW5hbF9kYXRhIHRvIGEgQ1NWIGZpbGUNCndyaXRlLmNzdihtZXJnZWRfZGF0YSwgIkM6L1VzZXJzL09MVU1JREUvRGVza3RvcC9QdXJkdWUvU3ByaW5nIDIwMjQvTW9sZWN1bGFyIE1pY3JvYmlvbWUgQW5hbHlzaXMgQU5TQzUxNi9wcm9qZWN0L1Byb2plY3Qgb3V0cHV0L2ZlbHNlZmluYWxfZGF0YS5jc3YiLCByb3cubmFtZXMgPSBGQUxTRSkNCg0KDQojbWFrZSBhIHBoeWxvc2VxIA0KDQpsaWJyYXJ5KHBoeWxvc2VxKQ0KbGlicmFyeShyZW1vdGVzKQ0KbGlicmFyeShxaWltZTJSKQ0KbGlicmFyeShtaWNyb2Jpb21lTWFya2VyKQ0KU2Vhd2VlZCA8LSBxemFfdG9fcGh5bG9zZXEgKCJyYXJlZmllZF90YWJsZS5xemEiLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAicm9vdGVkLXRyZWUucXphIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgInRheG9ub215LnF6YSIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICJwcm9qZWN0X21ldGFkYXRhLnR4dCIpDQoNClNlYXdlZWQNCiNGaWx0ZXIgb3V0IE5BIFBoeWxhDQpTZWF3ZWVkIDwtIHN1YnNldF90YXhhKFNlYXdlZWQsICFpcy5uYShQaHlsdW0pICYgIVBoeWx1bSAlaW4lIGMoIiIpKQ0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIlBoeWx1bSJdLCBleGNsdWRlID0gTlVMTCkNCg0KI2NoZWNrIGZvciBOQSBvciBsb3cgYWJ1bmRhbnQgQ2xhc3Nlcw0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIkNsYXNzIl0sIGV4Y2x1ZGUgPSBOVUxMKQ0KDQojUmVtb3ZlIE5BIENsYXNzZXMNClNlYXdlZWQgPC0gc3Vic2V0X3RheGEoU2Vhd2VlZCwgIWlzLm5hKENsYXNzKSAmICFDbGFzcyAlaW4lIGMoIiIpKQ0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIkNsYXNzIl0sIGV4Y2x1ZGUgPSBOVUxMKQ0KDQojUmVtb3ZlIE5BIENsYXNzZXMNClNlYXdlZWQgPC0gc3Vic2V0X3RheGEoU2Vhd2VlZCwgIWlzLm5hKENsYXNzKSAmICFDbGFzcyAlaW4lIGMoIiIpKQ0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIkNsYXNzIl0sIGV4Y2x1ZGUgPSBOVUxMKQ0KDQojQ2hlY2sgTkEgRmFtaWx5DQp0YWJsZSh0YXhfdGFibGUoU2Vhd2VlZClbLCAiRmFtaWx5Il0sIGV4Y2x1ZGUgPSBOVUxMKQ0KDQojRmlsdGVyIG91dCBOQSBGYW1pbHkNClNlYXdlZWQgPC0gc3Vic2V0X3RheGEoU2Vhd2VlZCwgIWlzLm5hKEZhbWlseSkgJiAhRmFtaWx5ICVpbiUgYygiIikpDQp0YWJsZSh0YXhfdGFibGUoU2Vhd2VlZClbLCAiRmFtaWx5Il0sIGV4Y2x1ZGUgPSBOVUxMKQ0KDQojQ2hlY2sgTkEgR2VudXMNCnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssICJHZW51cyJdLCBleGNsdWRlID0gTlVMTCkNCg0KI0ZpbHRlciBvdXQgTkEgR2VudXMNClNlYXdlZWQgPC0gc3Vic2V0X3RheGEoU2Vhd2VlZCwgIWlzLm5hKEdlbnVzKSAmICFHZW51cyAlaW4lIGMoIiIpKQ0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIkdlbnVzIl0sIGV4Y2x1ZGUgPSBOVUxMKQ0KVmlldyhTZWF3ZWVkQHRheF90YWJsZSkNCg0KI0NoZWNrIFNwZWNpZXMNCnRhYmxlKHRheF90YWJsZShTZWF3ZWVkKVssICJTcGVjaWVzIl0sIGV4Y2x1ZGUgPSBOVUxMKQ0KI0ZpbHRlciBvdXQgTkEgU3BlY2llcw0KU2Vhd2VlZCA8LSBzdWJzZXRfdGF4YShTZWF3ZWVkLCAhaXMubmEoU3BlY2llcykgJiAhU3BlY2llcyAlaW4lIGMoIiIpKQ0KdGFibGUodGF4X3RhYmxlKFNlYXdlZWQpWywgIlNwZWNpZXMiXSwgZXhjbHVkZSA9IE5VTEwpDQoNCiNSTkEtc2VxIGJhc2VkIERBIG1ldGhvZHMNCiNWb29tIChMYXcgZXQgYWwuIDIwMTQpIA0KI2ZvciB0aGUgZml2ZSBsaW5lYXIgbW9kZWxzLWJhc2VkIG1ldGhvZHMsIGluY2x1ZGluZyBlZGdlUiwgREVTZXEyLCBtZXRhZ2Vub1NlcSwgbGltbWEtdm9vbSwgYW5kIEFOQ09NQkMsIHVzZXJzIGNhbiBwZXJmb3JtIHBhaXItd2lzZSBjb21wYXJpc29ucyBieSBzZXR0aW5nIHRoZSBhcmd1bWVudCBjb250cmFzdCwgYSB0d28gbGVuZ3RoIGNoYXJhY3RlciBpbiB3aGljaCB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcmVmZXJlbmNlIGxldmVsIChkb25vbWluYXRvciBvZiB0aGUgbG9nRkMpIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdXNlZCBhcyBiYXNlbGluZSAobnVtZXJhdG9yIGZvciBmb2xkIGNoYW5nZSkuDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyBEYXkgMTUNCmNpZF9kYXkxNSA8LSBzdWJzZXRfc2FtcGxlcyhTZWF3ZWVkLCB0aW1lLnBvaW50ID09ICJEYXkxNSIpDQpjaWRfZGF5MTUgPC0gcGh5bG9zZXE6OnN1YnNldF9zYW1wbGVzKGNpZF9kYXkxNSwgdHJlYXRtZW50ICVpbiUgYygiQmFzYWwiLCAiQlNlYTA1IiwgIkJTZWExMCIsICJCU2VhMTUiKSkNCg0KbW1fQmFzYWxfQlNlYTA1X2RheTE1IDwtIHJ1bl9saW1tYV92b29tKA0KICBjaWRfZGF5MTUsDQogICJ0cmVhdG1lbnQiLA0KICBjb250cmFzdCA9IGMoIkJhc2FsIiwgIkJTZWEwNSIpLA0KICBwdmFsdWVfY3V0b2ZmID0gMC4wMSwNCiAgcF9hZGp1c3QgPSAibm9uZSINCikNCnBsb3RfZWZfYmFyKG1tX0Jhc2FsX0JTZWEwNV9kYXkxNSkNCg0KDQptbV9CYXNhbF9CU2VhMTVfZGF5MTUgPC0gcnVuX2xpbW1hX3Zvb20oDQogIGNpZF9kYXkxNSwNCiAgInRyZWF0bWVudCIsDQogIGNvbnRyYXN0ID0gYygiQmFzYWwiLCAiQlNlYTE1IiksDQogIHB2YWx1ZV9jdXRvZmYgPSAwLjAxLA0KICBwX2FkanVzdCA9ICJub25lIg0KKQ0KcGxvdF9lZl9iYXIobW1fQmFzYWxfQlNlYTE1X2RheTE1KQ0KDQptbV9CYXNhbF9CU2VhMTBfZGF5MTUgPC0gcnVuX2xpbW1hX3Zvb20oDQogIGNpZF9kYXkxNSwNCiAgInRyZWF0bWVudCIsDQogIGNvbnRyYXN0ID0gYygiQmFzYWwiLCAiQlNlYTEwIiksDQogIHB2YWx1ZV9jdXRvZmYgPSAwLjAxLA0KICBwX2FkanVzdCA9ICJub25lIg0KKQ0KcGxvdF9lZl9iYXIobW1fQmFzYWxfQlNlYTEwX2RheTE1KQ0KDQoNCg0KIyBEYXkgMjINCmNpZF9kYXkyMiA8LSBzdWJzZXRfc2FtcGxlcyhTZWF3ZWVkLCB0aW1lLnBvaW50ID09ICJEYXkyMiIpDQpjaWRfZGF5MjIgPC0gcGh5bG9zZXE6OnN1YnNldF9zYW1wbGVzKGNpZF9kYXkyMiwgdHJlYXRtZW50ICVpbiUgYygiQmFzYWwiLCAiQlNlYTA1IiwgIkJTZWExMCIsICJCU2VhMTUiKSkNCg0KbW1fQmFzYWxfQlNlYTA1X2RheTIyIDwtIHJ1bl9saW1tYV92b29tKA0KICBjaWRfZGF5MjIsDQogICJ0cmVhdG1lbnQiLA0KICBjb250cmFzdCA9IGMoIkJhc2FsIiwgIkJTZWEwNSIpLA0KICBwdmFsdWVfY3V0b2ZmID0gMC4wMSwNCiAgcF9hZGp1c3QgPSAibm9uZSINCikNCnBsb3RfZWZfYmFyKG1tbV9CYXNhbF9CU2VhMDVfZGF5MjIpDQoNCm1tX0Jhc2FsX0JTZWExNV9kYXkyMiA8LSBydW5fbGltbWFfdm9vbSgNCiAgY2lkX2RheTIyLA0KICAidHJlYXRtZW50IiwNCiAgY29udHJhc3QgPSBjKCJCYXNhbCIsICJCU2VhMTUiKSwNCiAgcHZhbHVlX2N1dG9mZiA9IDAuMDEsDQogIHBfYWRqdXN0ID0gIm5vbmUiDQopDQpwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTVfZGF5MjIpDQoNCm1tX0Jhc2FsX0JTZWExMF9kYXkyMiA8LSBydW5fbGltbWFfdm9vbSgNCiAgY2lkX2RheTIyLA0KICAidHJlYXRtZW50IiwNCiAgY29udHJhc3QgPSBjKCJCYXNhbCIsICJCU2VhMTAiKSwNCiAgcHZhbHVlX2N1dG9mZiA9IDAuMDEsDQogIHBfYWRqdXN0ID0gIm5vbmUiDQopDQpwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTBfZGF5MjIpDQoNCg0KIyBFbnN1cmUgZWFjaCBwbG90IGhhcyBhIHRpdGxlIHNldCB3aXRoIGdndGl0bGUoKQ0KbGlicmFyeShncmlkRXh0cmEpDQpwbG90MSA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTVfZGF5MTUpICsgZ2d0aXRsZSgiQmFzYWwgdnMgQlNlYTE1IERheSAxNSIpDQpwbG90MiA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTBfZGF5MTUpICsgZ2d0aXRsZSgiQmFzYWwgdnMgQlNlYTEwIERheSAxNSIpDQpwbG90MyA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMDVfZGF5MTUpICsgZ2d0aXRsZSgiQmFzYWwgdnMgQlNlYTA1IERheSAxNSIpDQpwbG90NCA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTVfZGF5MjIpICsgZ2d0aXRsZSgiQmFzYWwgdnMgQlNlYTE1IERheSAyMiIpDQpwbG90NSA8LSBwbG90X2VmX2JhcihtbV9CYXNhbF9CU2VhMTBfZGF5MjIpICsgZ2d0aXRsZSgiQmFzYWwgdnMgQlNlYTEwIERheSAyMiIpDQoNCiMgVXNlIGdyaWQuYXJyYW5nZSB0byBhcnJhbmdlIHRoZSBwbG90cyB3aXRoIHRpdGxlcw0KYWxsbGltYSA8LSBncmlkLmFycmFuZ2UoDQogIHBsb3QxLCBwbG90MiwgcGxvdDMsIHBsb3Q0LCBwbG90NSwNCiAgbmNvbCA9IDMNCikNCg0KDQojIFNhdmUgdGhlIGNvbWJpbmVkIHBsb3QNCmdnc2F2ZSgiTGlpbWEgVm9vbSBEQS5wbmciLCBhbGxsaW1hLCB3aWR0aCA9IDEyLCBoZWlnaHQgPSA4KQ0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KI2xlZnNlDQojdGhlIGNvZGUgYmVsb3cgdXNlcyBMZWZzZSBhbmQgaXQgY29tYmluZWQgdGhlIHBsb3QgZm9yIHRoZSBkaWZmZXJudGlhbCBhYnVuZGFuY2UgZm9yIGFsbCB0cmVhdG1lbnRzLg0KI29ubHkgdGhlIG9uZXMgZGlmZmVyZW50aWFsbHkgZGlmZmVyZW50IGZyb20gQmFzYWwgYXJlIGRpc3BsYWNlZC4gSXQgcHJvZHVjZXMgYWxtb3N0IGlkZW50aWNhbCB0byB2b29tIGJ1dCBpdHMgbm9ybWFsaXNlZCwgcHJvYmFibHkgYmV0dGVyDQoNCmExNTwtIHJ1bl9sZWZzZShjaWRfZGF5MTUsZ3JvdXAgPSJ0cmVhdG1lbnQiLA0KICBub3JtID0gIkNQTSIsICNgQ1BNYDogcHJlLXNhbXBsZSBub3JtYWxpemF0aW9uIG9mIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyB0byAxZSswNi4NCiAgbm9ybV9wYXJhID0gbGlzdCgpLA0KICBrd19jdXRvZmYgPSAwLjA1LA0KICBsZGFfY3V0b2ZmID0gMiwNCiAgYm9vdHN0cmFwX24gPSAzMCwNCiAgYm9vdHN0cmFwX2ZyYWN0aW9uID0gMi8zLA0KICB3aWxjb3hvbl9jdXRvZmYgPSAwLjA1LA0KICBtdWx0aWdycF9zdHJhdCA9IFRSVUUsDQogIHN0cmljdCA9IGMoIjAiLCAiMSIsICIyIiksDQogIHNhbXBsZV9taW4gPSAxMCwNCiAgb25seV9zYW1lX3N1YmdycCA9IEZBTFNFLA0KICBjdXJ2ID0gRkFMU0UNCikNCnBsb3RfZWZfYmFyKGExNSkgKyBnZ3RpdGxlKCJCYXNhbCB2cyBCYXNhbCBwbHVzIFNlYXdlZWQgRGF5IDE1IikNCg0KDQoNCmEyMjwtIHJ1bl9sZWZzZShjaWRfZGF5MjIsZ3JvdXAgPSJ0cmVhdG1lbnQiLA0KICBub3JtID0gIkNQTSIsICNgQ1BNYDogcHJlLXNhbXBsZSBub3JtYWxpemF0aW9uIG9mIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyB0byAxZSswNi4NCiAgbm9ybV9wYXJhID0gbGlzdCgpLA0KICBrd19jdXRvZmYgPSAwLjAxLA0KICBsZGFfY3V0b2ZmID0gMiwNCiAgYm9vdHN0cmFwX24gPSAzMCwNCiAgYm9vdHN0cmFwX2ZyYWN0aW9uID0gMi8zLA0KICB3aWxjb3hvbl9jdXRvZmYgPSAwLjA1LA0KICBtdWx0aWdycF9zdHJhdCA9IFRSVUUsDQogIHN0cmljdCA9IGMoIjAiLCAiMSIsICIyIiksDQogIHNhbXBsZV9taW4gPSAxMCwNCiAgb25seV9zYW1lX3N1YmdycCA9IEZBTFNFLA0KICBjdXJ2ID0gRkFMU0UNCikNCnBsb3RfZWZfYmFyKGEyMikgKyBnZ3RpdGxlKCJCYXNhbCB2cyBCYXNhbCBwbHVzIFNlYXdlZWQgRGF5IDIyIikNCg0KcGxvdDYgPC0gcGxvdF9lZl9iYXIoYTIyKSArIGdndGl0bGUoIkJhc2FsIHZzIEJhc2FsIHBsdXMgU2Vhd2VlZCBEYXkgMjIiKQ0KcGxvdDcgPC0gcGxvdF9lZl9iYXIoYTE1KSArIGdndGl0bGUoIkJhc2FsIHZzIEJhc2FsIHBsdXMgU2Vhd2VlZCBEYXkgMTUiKQ0KDQojIFVzZSBncmlkLmFycmFuZ2UgdG8gYXJyYW5nZSB0aGUgcGxvdHMgd2l0aCB0aXRsZXMNCmFsbGxlZnNlIDwtIGdyaWQuYXJyYW5nZSgNCiAgcGxvdDYsIHBsb3Q3LA0KICBuY29sID0gMg0KKQ0KDQojIFNhdmUgdGhlIGNvbWJpbmVkIHBsb3QNCmdnc2F2ZSgiTGVmc2UgREEucG5nIiwgYWxsbGVmc2UsIHdpZHRoID0gMTIsIGhlaWdodCA9IDgpDQoNCg0KDQojQWJ1bmRhbmNlIGJveCBwbG90OiAgZ3JvdXAgcGFyYSBmb3IgcGxvdF9hYnVuYW5jZSgpIG11c3QgYmUga2VlcCBzYW1lIHdpdGggdGhlIGdyb3VwIHBhcmEgaW4gdGhlIGRpZmZlcmVudGlhbCBhbmFseXNpcyBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgcGxvdF9hYnVuZGFuY2UoKSB3aWxsIHBsb3QgYWxsIHRoZSBtYXJrZXJzLCB1c2VycyBjYW4gcGxvdCB0aGUgc3BlY2lmaWNpdHkgbWFya2VycyB1c2luZyBwYXJhIG1hcmtlcnMuDQoNCmxpYnJhcnkoZ2dwbG90MikNCmxpYnJhcnkoZ3JpZEV4dHJhKQ0KDQojIENyZWF0aW5nIHRoZSBhYnVuZGFuY2UgcGxvdHMgZm9yIERheSAxNSBhbmQgRGF5IDIyDQpwX2FiZDE1IDwtIHBsb3RfYWJ1bmRhbmNlKGExNSwgZ3JvdXAgPSAidHJlYXRtZW50IikgKw0KICBnZ3RpdGxlKCJMZWZzZSBEQSBhYnVuZGFuY2Ugb24gRGF5IDE1IikgKw0KICBzY2FsZV9maWxsX21hbnVhbCh2YWx1ZXMgPSBjKCIjMDA3MkIyIiwgIiNENTVFMDAiLCAiIzAwOUU3MyIsICIjRjBFNDQyIikpICMgQ3VzdG9tIGZpbGwgY29sb3JzDQoNCnBfYWJkMjIgPC0gcGxvdF9hYnVuZGFuY2UoYTIyLCBncm91cCA9ICJ0cmVhdG1lbnQiKSArDQogIGdndGl0bGUoIkxlZnNlIERBIGFidW5kYW5jZSBvbiBEYXkgMjIiKSArDQogIHNjYWxlX2ZpbGxfbWFudWFsKHZhbHVlcyA9IGMoIiMwMDcyQjIiLCAiI0Q1NUUwMCIsICIjMDA5RTczIiwgIiNGMEU0NDIiKSkgIyBVc2UgdGhlIHNhbWUgY29sb3JzIGZvciBjb25zaXN0ZW5jeQ0KDQojIEFycmFuZ2UgdGhlIHBsb3RzIGluIGEgc2luZ2xlIGltYWdlDQpjb21iaW5lZF9sZWZzZWFiZCA8LSBncmlkLmFycmFuZ2UocF9hYmQxNSwgcF9hYmQyMiwgbmNvbCA9IDEpICMgQXJyYW5nZWQgdmVydGljYWxseTsgY2hhbmdlIGBuY29sYCB0byAyIGZvciBob3Jpem9udGFsDQoNCiMgU2F2ZSB0aGUgY29tYmluZWQgaW1hZ2UgdG8gZmlsZQ0KZ2dzYXZlKCJjb21iaW5lZF9sZWZzZWFidW5kYW5jZV9wbG90cy5wbmciLCBjb21iaW5lZF9sZWZzZWFiZCwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gMTQpDQoNCg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KI1JOQS1zZXEgYmFzZWQgREEgbWV0aG9kcyAoaHR0cHM6Ly95aWx1aGVpaGVpLmdpdGh1Yi5pby9taWNyb2Jpb21lTWFya2VyL2FydGljbGVzL21pY3JvYmlvbWVNYXJrZXItdmlnbmV0dGUuaHRtbCkNCiNlZGdlUiAoUm9iaW5zb24sIE1jQ2FydGh5LCBhbmQgU215dGggMjAxMCkNCiMgbXVsdGlwbGUgZ3JvdXBzDQojU3Vic2V0IHRyZWF0bWVudCBiYXNlZCBvbiBkYXkxNQ0KbW1fZWRnZXJfbWcgPC0gcnVuX2VkZ2VyKA0KICAgIGNpZF9kYXkxNSwNCiAgICBncm91cCA9ICJ0cmVhdG1lbnQiLA0KICAgIG1ldGhvZCAgPSAiUUxGVCIsDQogICAgcHZhbHVlX2N1dG9mZiA9IDAuMDUsDQogICAgcF9hZGp1c3QgPSAiZmRyIg0KKQ0KbW1fZWRnZXJfbWcNCkVkZ2VyMTUgPC1wbG90X2VmX2JhcihtbV9lZGdlcl9tZykNCkVkZ2VyMTUNCg0KI0RheSAyMg0KbW1fZWRnZXIgPC0gcnVuX2VkZ2VyKA0KICAgIGNpZF9kYXkyMiwNCiAgICBncm91cCA9ICJ0cmVhdG1lbnQiLA0KICAgIG1ldGhvZCAgPSAiUUxGVCIsDQogICAgcHZhbHVlX2N1dG9mZiA9IDAuMDUsDQogICAgcF9hZGp1c3QgPSAiZmRyIg0KKQ0KbW1fZWRnZXINCkVkZ2VyMjIgPC1wbG90X2VmX2JhcihtbV9lZGdlcikNCkVkZ2VyMjINCg0KbGlicmFyeShnZ3Bsb3QyKQ0KbGlicmFyeShnZ3B1YnIpDQpFZGdlUmNvbTwtIGdnYXJyYW5nZShFZGdlcjE1ICwgRWRnZXIyMiAsIG5jb2wgPSAyLCBucm93ID0gMSkNCkVkZ2VSY29tDQpnZ3NhdmUoIkVkZ2VSY29tIERBX3Bsb3QucG5nIiwgRWRnZVJjb20sIHdpZHRoID0gMTAsIGhlaWdodCA9IDUpDQoNCg0KRWRnZVJjb20gPC0gZ2dhcnJhbmdlKEVkZ2VyMTUgKyBsYWJzKHRpdGxlID0gIkRheSAxNSIpLCBFZGdlcjIyICsgbGFicyh0aXRsZSA9ICJEYXkgMjIiKSwgbmNvbCA9IDIsIG5yb3cgPSAxKQ0KRWRnZVJjb20gPC0gRWRnZVJjb20gKyBsYWJzKHRpdGxlID0gIkVkZ2VSIENvbXBhcmlzb24iKQ0KRWRnZVJjb20NCmdnc2F2ZSgiRWRnZVJjb21fREFfcGxvdC5wbmciLCBFZGdlUmNvbSwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSkNCg0KYGBgDQogIA0KICBDb29jY3VycmVuY2UNCmBgYHtyfQ0KI2Nvb2NjdXJlbmNlDQpsaWJyYXJ5KEhtaXNjKQ0KbGlicmFyeShwbHlyKQ0KbGlicmFyeShyZXNoYXBlMikNCmxpYnJhcnkocWlpbWUyUikNCmxpYnJhcnkoaWdyYXBoKQ0KbGlicmFyeShmZHJ0b29sKQ0KDQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KQVNWcyA8LSByZWFkX3F6YSgicmFyZWZpZWRfdGFibGUucXphIikNCkFTVl90YWJsZSA8LSBhcy5kYXRhLmZyYW1lKEFTVnMkZGF0YSkNCg0KQVNWX3RhYmxlJEFTVm5vcyA8LSBwYXN0ZTAoIkFTViIsIDE6bnJvdyhBU1ZfdGFibGUpKQ0KQVNWX3RhYmxlJEFTVnN0cmluZyA8LSByb3duYW1lcyhBU1ZfdGFibGUpDQpyb3duYW1lcyhBU1ZfdGFibGUpIDwtIEFTVl90YWJsZSRBU1Zub3MNCkFTVmtleSA8LSBBU1ZfdGFibGVbLCAobmNvbChBU1ZfdGFibGUpLTEpOm5jb2woQVNWX3RhYmxlKV0NCkFTVl90YWJsZSA8LSBBU1ZfdGFibGVbLC0obmNvbChBU1ZfdGFibGUpLTEpOi1uY29sKEFTVl90YWJsZSldDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQoNCmRhdGFzZXQgPC0gYXMuZGF0YS5mcmFtZSh0KEFTVl90YWJsZSkpDQoNCg0KIyB3ZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV0d29yayBwZXIgdHJlYXRtZW50DQpoZWFkKGRhdGFzZXRbLDE6MTBdKQ0KDQptZXRhZGF0YTwtcmVhZF9xMm1ldGFkYXRhKCJwcm9qZWN0X21ldGFkYXRhLnR4dCIpDQpzdHIobWV0YWRhdGEpDQpjb2xuYW1lcyhtZXRhZGF0YSlbMl0gPSAidGltZS1wb2ludCINCmNvbG5hbWVzKG1ldGFkYXRhKVs2XSA9ICJ0cmVhdG1lbnQiDQoNCmRhdGFzZXQgPC0gbWVyZ2UobWV0YWRhdGEsIGRhdGFzZXQsIGJ5LnggPSAiU2FtcGxlSUQiLCBieS55ID0gMCkNCnRyZWF0bWVudHM8LWFzLnZlY3Rvcih1bmlxdWUoZGF0YXNldCR0cmVhdG1lbnQpKQ0KZGF0YXNldG48LWRhdGFzZXQNCmRhdGFzZXRuW2RhdGFzZXRuPT0wXTwtTkENCg0KI2kgPSAxDQoNCnN1bW1hcnkobWV0YWRhdGEkdHJlYXRtZW50KQ0KDQpteV9jb2x1bW4gPC0gInRyZWF0bWVudCINCm4xIDwtIDgNCm4yIDwtIDgNCm4zIDwtIDgNCm40IDwtIDgNCg0KbnVtX21ldGFkYXRhX2NvbHVtbnMgPC0gbmNvbChtZXRhZGF0YSkNCg0KcV9jdXRvZmYgPC0gMC4wNQ0KDQpmaW5hbF9yZXN1bHRzPC1kYXRhLmZyYW1lKCkNCg0KZm9yKGkgaW4gMTpsZW5ndGgodHJlYXRtZW50cykpew0KICANCiAgI3N1YnNldCB0aGUgZGF0YSBmb3IgYSBwYXJ0aWN1bGFyIHRyZWF0bWVudCBZT1UgTVVTVCBFTlRFUiBUSEUgSEVBREVSIE9GIFRIRSBDT0xVTU4gVEhBVCBIQVMgVEhFIERJRkZFUkVOVCBUUkVBVE1FTlRTIElOIFRISVMgQ0FTRSDigJx0cmVhdG1lbnTigJ0NCiAgDQogIHByaW50KHBhc3RlKCJyZWFkaW5nICIsdHJlYXRtZW50c1tpXSxzZXA9IiIpKQ0KICB0ZW1wPC1zdWJzZXQoZGF0YXNldCwgZ2V0KG15X2NvbHVtbik9PXRyZWF0bWVudHNbaV0pDQogIHRlbXBuPC1zdWJzZXQoZGF0YXNldG4sIGdldChteV9jb2x1bW4pPT10cmVhdG1lbnRzW2ldKQ0KICBwcmludChwYXN0ZSgiZmluaXNoZWQgcmVhZGluZyAiLHRyZWF0bWVudHNbaV0sc2VwPSIiKSkNCiAgIyBtYWtpbmcgYW4gb2JqZWN0IHRoYXQgaGFzIGFsbCB0aGUgcmVzdWx0cyBpbiBpdCAoYm90aCByaG8gYW5kIFAgdmFsdWVzKQ0KICByZXN1bHRzPC1yY29ycihhcy5tYXRyaXgodGVtcFssLWMoMTpudW1fbWV0YWRhdGFfY29sdW1ucyldKSx0eXBlPSJzcGVhcm1hbiIpICMjIHVzZSB0aGUgIi1jIiBwYXJhbWV0ZXIgdG8gcmVtb3ZlIG1ldGFkYXRhIGNvbHVtbnMNCiAgcmVzdWx0c248LXJjb3JyKGFzLm1hdHJpeCh0ZW1wblssLWMoMTpudW1fbWV0YWRhdGFfY29sdW1ucyldKSx0eXBlPSJzcGVhcm1hbiIpDQogIA0KICAjbWFrZSB0d28gc2VwZXJhdGUgb2JqZWN0cyBmb3IgcC12YWx1ZSBhbmQgY29ycmVsYXRpb24gY29lZmZpY2llbnRzDQogIHJob3M8LXJlc3VsdHMkcg0KICBwczwtcmVzdWx0cyRQDQogIG5zPC1yZXN1bHRzbiRuDQogICMgZ29pbmcgdG8gbWVsdCB0aGVzZSBvYmplY3RzIHRvICdsb25nIGZvcm0nIHdoZXJlIHRoZSBmaXJzdCB0d28gY29sdW1ucyBtYWtlIHVwIHRoZSBwYWlycyBvZiBPVFVzLCBJIGFtIGFsc28gcmVtb3ZpbmcgTkEncyBhcyB0aGV5IGFyZSBzZWxmLWNvbXBhcmlzb25zLCBub3QgZW5vdWdoIGRhdGEsIG90aGVyIGJhZCBzdHVmZg0KICBwc19tZWx0PC1uYS5vbWl0KG1lbHQocHMpKQ0KICAjY3JlYXRpbmcgYSBxdmFsdWUgYmFzZWQgb24gRkRSDQogIHBzX21lbHQkcXZhbDwtcC5hZGp1c3QocHNfbWVsdCR2YWx1ZSwgbWV0aG9kID0gIkJIIikNCiAgI21ha2luZyBjb2x1bW4gbmFtZXMgbW9yZSByZWxldmFudA0KICANCiAgbmFtZXMocHNfbWVsdClbM108LSJwdmFsIg0KICAjIGlmIHlvdSBhcmUgb2YgdGhlIG9waW5pb24gdGhhdCBpdCBpcyBhIGdvb2QgaWRlYSB0byBzdWJzZXQgeW91ciBuZXR3b3JrIGJhc2VkIG9uIGFkanVzdGVkIFAtdmFsdWVzIChxdmFsIGluIHRoaXMgY2FzZSksIHlvdSBjYW4gdGhlbiBzdWJzZXQgaGVyZQ0KICBwc19zdWI8LXN1YnNldChwc19tZWx0LCBxdmFsIDwgcV9jdXRvZmYpDQogIA0KICAjIG5vdyBtZWx0aW5nIHRoZSByaG9zLCBub3RlIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gcHNfbWVsdCBhbmQgcmhvc19tZWx0DQogIHJob3NfbWVsdDwtbmEub21pdChtZWx0KHJob3MpKQ0KICBuYW1lcyhyaG9zX21lbHQpWzNdPC0icmhvIg0KICANCiAgIyBub3cgbWVsdGluZyB0aGUgbnMNCiAgbnNfbWVsdDwtKG1lbHQobnMpKQ0KICBuYW1lcyhuc19tZWx0KVszXTwtIm4iDQogIA0KICAjbWVyZ2luZyB0b2dldGhlciBhbmQgcmVtb3ZlIG5lZ2F0aXZlIHJob3MNCiAgbWVyZ2VkPC1tZXJnZShwc19zdWIscmhvc19tZWx0LGJ5PWMoIlZhcjEiLCJWYXIyIikpDQogIGlmICh0cmVhdG1lbnRzW2ldPT10cmVhdG1lbnRzWzFdKSB7DQogICAgbWVyZ2VkPC1tZXJnZShtZXJnZWQsc3Vic2V0KG5zX21lbHQsIG4gPiBuMSksYnk9YygiVmFyMSIsIlZhcjIiKSkNCiAgfSAgIGVsc2UgaWYgKHRyZWF0bWVudHNbaV09PXRyZWF0bWVudHNbMl0pIHsNCiAgICBtZXJnZWQ8LW1lcmdlKG1lcmdlZCxzdWJzZXQobnNfbWVsdCwgbiA+IG4yKSxieT1jKCJWYXIxIiwiVmFyMiIpKQ0KICB9ICAgZWxzZSBpZiAodHJlYXRtZW50c1tpXT09dHJlYXRtZW50c1szXSkgew0KICAgIG1lcmdlZDwtbWVyZ2UobWVyZ2VkLHN1YnNldChuc19tZWx0LCBuID4gbjMpLGJ5PWMoIlZhcjEiLCJWYXIyIikpDQogIH0gICBlbHNlIGlmICh0cmVhdG1lbnRzW2ldPT10cmVhdG1lbnRzWzRdKSB7DQogICAgbWVyZ2VkPC1tZXJnZShtZXJnZWQsc3Vic2V0KG5zX21lbHQsIG4gPiBuNCksYnk9YygiVmFyMSIsIlZhcjIiKSkNCiAgfSAgIGVsc2UNCiAgICBwcmludCgiU29tZXRoaW5ncyB3cm9uZyB3aXRoIHlvdXIgdHJlYXRtZW50IGRlc2lnbmF0aW9ucy4gUGxlYXNlIENoZWNrISEiKQ0KICANCiAgaWYgKG5yb3cobWVyZ2VkKSA+IDApIHsNCiAgICBtZXJnZWQkdHJ0PC10cmVhdG1lbnRzW2ldDQogICAgZmluYWxfcmVzdWx0czwtcmJpbmQoZmluYWxfcmVzdWx0cywgbWVyZ2VkKQ0KICB9ICAgZWxzZSB7DQogICAgcHJpbnQoIm5vIGNvcnJlbGF0aW9ucyBmb3IgdGhpcyB2YXJpYWJsZSIpDQogIH0NCiAgDQogIHByaW50KHBhc3RlKCJmaW5pc2hlZCAiLHRyZWF0bWVudHNbaV0sc2VwPSIiKSkNCn0NCg0KIyBJbiB0aGUgZm9sbG93aW5nIGxpbmUsIHlvdSBkb24ndCBoYXZlIHRvIHVzZSB1c2UgcmhvID49IDAuOS4gDQojIElmIHlvdXIgZmluYWxfcmVzdWx0cyB0YWJsZSBoYXMgbGVzcyB0aGFuIDUwMCByb3dzLCANCiMgdGhlbiBJIGNvbnNpZGVyIHRoYXQgbm90IHRvbyBtYW55IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy4NCiMgSWYgeW91IGRvbid0IHdhbnQgdG8gZmlsdGVyLCBqdXN0IHVzZSANCnN0cm9uZ19yZXN1bHRzIDwtIGZpbmFsX3Jlc3VsdHMNCg0KIyBJZiB5b3UgaGF2ZSB0b28gbWFueSBjb3JyZWxhdGlvbnMgYW5kIG5lZWQgdG8gc2ltcGxpZnksIA0KIyBjb25zaWRlciBydW5uaW5nIHRoZSBmb2xsb3dpbmcgbGluZSwgYW5kIGNob29zZSBhbiBhcHByb3ByaWF0ZSBjdXRvZmYgZm9yIHJoby4NCiMgVGhpcyBsaW5lIHdpbGwga2VlcCBib3RoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb3JyZWxhdGlvbnMuIGFicygpIG1lYW5zIGFic29sdXRlIHZhbHVlDQojc3Ryb25nX3Jlc3VsdHM8LXN1YnNldChmaW5hbF9yZXN1bHRzLCBhYnMocmhvKSA+PSAwLjkpDQoNCg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQojIElmIHlvdSB3YW50IHRvIHNlZSB0aGUgY29ycmVsYXRpb24gc2NhdHRlcnBsb3Qgb2YgDQojIHR3byBzaWduaWZpY2FudCBBU1ZzDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KDQp0cnRfQVNWczwtc3Vic2V0KGRhdGFzZXQsIGdldChteV9jb2x1bW4pPT10cmVhdG1lbnRzWzFdKQ0KDQpjb2xuYW1lcyh0cnRfQVNWc1sxOjEwXSkNCmhlYWQoZmluYWxfcmVzdWx0cykNCmdncGxvdCh0cnRfQVNWcywgYWVzKHggPSBBU1YyLCB5ID0gQVNWNCkpICsNCiAgZ2VvbV9wb2ludCgpDQoNCg0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCiMgSWYgeW91IHdhbnQgdG8gc2VlIHRoZSB0aGUgdGF4b25vbWljIGFzc2lnbm1lbnQgb2YgIA0KIyB0aGVzZSBzaWduaWZpY2FudCBBU1ZzDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KdGF4b25vbXk8LXJlYWRfcXphKCJ0YXhvbm9teS5xemEiKQ0KaGVhZCh0YXhvbm9teSRkYXRhKQ0KDQp0YXguY2xlYW48LXBhcnNlX3RheG9ub215KHRheG9ub215JGRhdGEpDQpoZWFkKHRheC5jbGVhbikNCg0KI0FsbCB0aGlzIGlzIE9LIGV4Y2VwdCB0aGF0IGluIGZ1dHVyZSB1c2Ugb2YgdGhlIHRheG9ub215IHRhYmxlLCANCiN0aGVzZSBBU1ZzIHdpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBjbGFzc2lmaWVkLiBXaHkgDQojYXJlIEFTVnMgbm90IGNsYXNzaWZpZWQ/IEl0cyBiZWNhdXNlIHRoZXJlIGlzIG5vdCBhIGNsb3NlIGVub3VnaCANCiNtYXRjaCBpbiB0aGUgZGF0YWJhc2UuIEp1c3QgYmVjYXVzZSB0aGVyZSBpcyBub3QgYSBnb29kIG1hdGNoIGluIA0KI3RoZSBkYXRhYmFzZSBkb2VzIG5vdCBtZWFuIHRoZXkgZG9u4oCZdCBleGlzdCwgc28gSSB3YW50ZWQgdG8gbWFrZSANCiNzdXJlIHRoaXMgZGF0YSB3YXMgbm90IGxvc3QuIFNvIGluIG15IG5ldyBjb2RlLCAgDQojSSBtYWtlIGl0IHNvIHRoYXQgQVNWcyB0aGF0IGFyZSB1bmNsYXNzaWZpZWQgYXQgYW55IGxldmVsIGFyZSANCiNjbGFzc2lmaWVkIGFzIHRoZSBsb3dlc3QgdGF4b25vbWljIGxldmVsIGZvciB3aGljaCB0aGVyZSBpcyBhIA0KI2NsYXNzaWZpY2F0aW9uLg0KI05leHQsIGFsbCB0aGVzZSBgTkFgIGNsYXNzaWZpY2F0aW9ucyB3aXRoIHRoZSBsYXN0IGxldmVsIHRoYXQgd2FzIA0KI2NsYXNzaWZpZWQNCg0KdGF4LmNsZWFuW2lzLm5hKHRheC5jbGVhbildIDwtICIiDQpmb3IgKGkgaW4gMTpucm93KHRheC5jbGVhbikpew0KICBpZiAodGF4LmNsZWFuW2ksMl0gPT0gIiIpew0KICAgIGtpbmdkb20gPC0gcGFzdGUoInVuY2xhc3NpZmllZF8iLCB0YXguY2xlYW5baSwxXSwgc2VwID0gIiIpDQogICAgdGF4LmNsZWFuW2ksIDI6N10gPC0ga2luZ2RvbQ0KICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDNdID09ICIiKXsNCiAgICBwaHlsdW0gPC0gcGFzdGUoInVuY2xhc3NpZmllZF8iLCB0YXguY2xlYW5baSwyXSwgc2VwID0gIiIpDQogICAgdGF4LmNsZWFuW2ksIDM6N10gPC0gcGh5bHVtDQogIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNF0gPT0gIiIpew0KICAgIGNsYXNzIDwtIHBhc3RlKCJ1bmNsYXNzaWZpZWRfIiwgdGF4LmNsZWFuW2ksM10sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCA0OjddIDwtIGNsYXNzDQogIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNV0gPT0gIiIpew0KICAgIG9yZGVyIDwtIHBhc3RlKCJ1bmNsYXNzaWZpZWRfIiwgdGF4LmNsZWFuW2ksNF0sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCA1OjddIDwtIG9yZGVyDQogIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNl0gPT0gIiIpew0KICAgIGZhbWlseSA8LSBwYXN0ZSgidW5jbGFzc2lmaWVkXyIsIHRheC5jbGVhbltpLDVdLCBzZXAgPSAiIikNCiAgICB0YXguY2xlYW5baSwgNjo3XSA8LSBmYW1pbHkNCiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw3XSA9PSAiIil7DQogICAgdGF4LmNsZWFuJFNwZWNpZXNbaV0gPC0gcGFzdGUoInVuY2xhc3NpZmllZF8iLHRheC5jbGVhbiRHZW51c1tpXSwgc2VwID0gIl8iKQ0KICB9DQp9DQoNCnN0cm9uZ19yZXN1bHRzX3RheGEgPC0gbWVyZ2Uoc3Ryb25nX3Jlc3VsdHMsIEFTVmtleSwgYnkueCA9ICJWYXIxIiwgYnkueSA9ICJBU1Zub3MiKQ0Kc3Ryb25nX3Jlc3VsdHNfdGF4YSA8LSBtZXJnZShzdHJvbmdfcmVzdWx0c190YXhhLCBBU1ZrZXksIGJ5LnggPSAiVmFyMiIsIGJ5LnkgPSAiQVNWbm9zIikNCnN0cm9uZ19yZXN1bHRzX3RheGEgPC0gbWVyZ2Uoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgdGF4LmNsZWFuLCBieS54ID0gIkFTVnN0cmluZy54IiwgYnkueSA9IDApDQpzdHJvbmdfcmVzdWx0c190YXhhIDwtIG1lcmdlKHN0cm9uZ19yZXN1bHRzX3RheGEsIHRheC5jbGVhbiwgYnkueCA9ICJBU1ZzdHJpbmcueSIsIGJ5LnkgPSAwKQ0KDQp3cml0ZS5jc3Yoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgImFscGhhX2RpdmVyc2l0eV9wbG90cy9jb29jY3VyZW5jZS1zdHJvbmctcmVzdWx0cy10YXhhLmNzdiIsIHJvdy5uYW1lcyA9IEYpDQp3cml0ZS5jc3Yoc3Vic2V0KHN0cm9uZ19yZXN1bHRzX3RheGEsIHRydD09InRyZWF0bWVudCIpLCAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL2NvY2N1cmVuY2VzdHJvbmctcmVzdWx0cy10YXhhLXRyZWF0bWVudC5jc3YiLCByb3cubmFtZXMgPSBGKQ0Kd3JpdGUuY3N2KHN1YnNldChzdHJvbmdfcmVzdWx0c190YXhhLCB0cnQ9PSJCYXNhbCIpLCAiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL3N0cm9uZy1yZXN1bHRzLXRheGEtQmFzYWwuY3N2Iiwgcm93Lm5hbWVzID0gRikNCndyaXRlLmNzdihzdWJzZXQoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgdHJ0PT0iQlNlYTA1IiksICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvc3Ryb25nLXJlc3VsdHMtdGF4YS1CU2VhMDUuY3N2Iiwgcm93Lm5hbWVzID0gRikNCndyaXRlLmNzdihzdWJzZXQoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgdHJ0PT0iQlNlYTEwIiksICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvc3Ryb25nLXJlc3VsdHMtdGF4YS1CU2VhMTAuY3N2Iiwgcm93Lm5hbWVzID0gRikNCndyaXRlLmNzdihzdWJzZXQoc3Ryb25nX3Jlc3VsdHNfdGF4YSwgdHJ0PT0iQlNlYTE1IiksICJhbHBoYV9kaXZlcnNpdHlfcGxvdHMvc3Ryb25nLXJlc3VsdHMtdGF4YS1CU2VhMTUuY3N2Iiwgcm93Lm5hbWVzID0gRikNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyBOb3cgeW91IGNhbiBpbXBvcnQgdGhlc2UgaW50byBjeXRvc2NhcGUgdG8gdmlzdWFsaXplIHRoZSBuZXR3b3JrDQojT3BlbiBDeXRvc2NhcGUNCiNJbXBvcnQgTmV0d29yayBmcm9tIEZpbGUgc3lzdGVtDQojQW55dGhpbmcgd2l0aCBhIC54IGluZGljYXRlIGFzIGEgInNvdXJjZSBub2RlIGF0dHJpYnV0ZSINCiNBbnl0aGluZyB3aXRoIGEgLnkgaW5kaWNhdGUgYXMgYSAidGFyZ2V0IG5vZGUgYXR0cmlidXRlIg0KIyJWYXIyIiBpbmRpY2F0ZSBhcyAiVGFyZ2V0IE5vZGUiDQojIlZhcjEiIGluZGljYXRlIGFzICJTb3VyY2UgTm9kZSINCiN0aGUgcmVzdCBsZWF2ZSBhcyAiZWRnZSBhdHRyaWJ1dGUiDQojRWRpdD5SZW1vdmUgRHVwbGljYXRlZCBFZGdlcywgY2xpY2sgIklnbm9yZSBlZGdlIGRpcmVjdGlvbiINCiNUbyBtYW51YWxseSBhc3NpZ24gYWVzdGhldGljcywgdXNlICJEaXNjcmV0ZSBNYXBwaW5nIg0KIw0KIw0KIw0KIw0KIw0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KYGBgDQoNClRheGEgUGxvdA0KYGBge3J9DQojVEFYQSBQTE9UIA0KDQojIyBUaGlzIHNjcmlwdCBnb2VzIHRocm91Z2ggbWFraW5nIGEgdGF4YSBiYXIgcGxvdCBhbmQgdGhlbiBydW5uaW5nDQojIyBERVNlcTIgdG8gZmluZCBkaWZmZXJlbnRpYWxseSBhYnVuZGFudCBBU1ZzDQoNCmxpYnJhcnkocWlpbWUyUikNCmxpYnJhcnkocGh5bG9zZXEpDQpsaWJyYXJ5KHpvbykNCmxpYnJhcnkodGlkeXZlcnNlKQ0KbGlicmFyeShERVNlcTIpDQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KIyNRaWltZTJSIG1ldGhvZCBvZiBjcmVhdGluZyBhIHBoeWxvc2VxIG9iamVjdA0KcHMgPC0gcXphX3RvX3BoeWxvc2VxKA0KICBmZWF0dXJlcz0icmFyZWZpZWRfdGFibGUucXphIiwNCiAgdHJlZT0icm9vdGVkLXRyZWUucXphIiwNCiAgdGF4b25vbXkgPSAidGF4b25vbXkucXphIiwNCiAgbWV0YWRhdGEgPSAicHJvamVjdF9tZXRhZGF0YS50eHQiDQopDQoNCmFzdl90YWJsZSA8LSBkYXRhLmZyYW1lKG90dV90YWJsZShwcyksIGNoZWNrLm5hbWVzID0gRikNCm1ldGFkYXRhIDwtIGRhdGEuZnJhbWUoc2FtcGxlX2RhdGEocHMpLCBjaGVjay5uYW1lcyA9IEYpDQp0YXhvbm9teSA8LSBkYXRhLmZyYW1lKHRheF90YWJsZShwcyksIGNoZWNrLm5hbWVzID0gRikNCg0KI0NsZWFuIHVwIG1ldGFkYXRhLCBzbGlnaHRseQ0KbGV2ZWxzKG1ldGFkYXRhJHRyZWF0bWVudCkgI2NoZWNraW5nIGlmIGl0cyBvcmRlcmVkDQoNCiNDbGVhbiB1cCB0YXhvbm9teQ0KaGVhZCh0YXhvbm9teSkNCnRheC5jbGVhbiA8LSB0YXhvbm9teQ0KDQojQWxsIHRoaXMgaXMgT0sgZXhjZXB0IHRoYXQgaW4gZnV0dXJlIHVzZSBvZiB0aGUgdGF4b25vbXkgdGFibGUsIA0KI3RoZXNlIEFTVnMgZGVzaWduYXRlZCBhcyBOQSB3aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGV5IGFyZSBub3QgY2xhc3NpZmllZC4gDQojV2h5IGFyZSBBU1ZzIG5vdCBjbGFzc2lmaWVkPyBJdHMgYmVjYXVzZSB0aGVyZSBpcyBub3QgYSBjbG9zZSBlbm91Z2ggDQojbWF0Y2ggaW4gdGhlIGRhdGFiYXNlLiBKdXN0IGJlY2F1c2UgdGhlcmUgaXMgbm90IGEgZ29vZCBtYXRjaCBpbiANCiN0aGUgZGF0YWJhc2UgZG9lcyBub3QgbWVhbiB0aGV5IGRvbuKAmXQgZXhpc3QsIHNvIEkgd2FudGVkIHRvIG1ha2UgDQojc3VyZSB0aGlzIGRhdGEgd2FzIG5vdCBsb3N0LiBTbyBpbiBteSBuZXcgY29kZSwgZnJvbSBsaW5lcyAyMDAg4oCTIDIyNCANCiNJIG1ha2UgaXQgc28gdGhhdCBBU1ZzIHRoYXQgYXJlIHVuY2xhc3NpZmllZCBhdCBhbnkgbGV2ZWwgYXJlIA0KI2NsYXNzaWZpZWQgYXMgdGhlIGxvd2VzdCB0YXhvbm9taWMgbGV2ZWwgZm9yIHdoaWNoIHRoZXJlIGlzIGEgDQojY2xhc3NpZmljYXRpb24uDQoNCg0KdGF4LmNsZWFuW2lzLm5hKHRheC5jbGVhbildIDwtICIiDQpmb3IgKGkgaW4gMTpucm93KHRheC5jbGVhbikpew0KICBpZiAodGF4LmNsZWFuW2ksMl0gPT0gIiIpew0KICAgIGtpbmdkb20gPC0gcGFzdGUoInVuY2xfIiwgdGF4LmNsZWFuW2ksMV0sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCAyOjddIDwtIGtpbmdkb20NCiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSwzXSA9PSAiIil7DQogICAgcGh5bHVtIDwtIHBhc3RlKCJ1bmNsXyIsIHRheC5jbGVhbltpLDJdLCBzZXAgPSAiIikNCiAgICB0YXguY2xlYW5baSwgMzo3XSA8LSBwaHlsdW0NCiAgfSBlbHNlIGlmICh0YXguY2xlYW5baSw0XSA9PSAiIil7DQogICAgY2xhc3MgPC0gcGFzdGUoInVuY2xfIiwgdGF4LmNsZWFuW2ksM10sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCA0OjddIDwtIGNsYXNzDQogIH0gZWxzZSBpZiAodGF4LmNsZWFuW2ksNV0gPT0gIiIpew0KICAgIG9yZGVyIDwtIHBhc3RlKCJ1bmNsXyIsIHRheC5jbGVhbltpLDRdLCBzZXAgPSAiIikNCiAgICB0YXguY2xlYW5baSwgNTo3XSA8LSBvcmRlcg0KICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDZdID09ICIiKXsNCiAgICBmYW1pbHkgPC0gcGFzdGUoInVuY2xfIiwgdGF4LmNsZWFuW2ksNV0sIHNlcCA9ICIiKQ0KICAgIHRheC5jbGVhbltpLCA2OjddIDwtIGZhbWlseQ0KICB9IGVsc2UgaWYgKHRheC5jbGVhbltpLDddID09ICIiKXsNCiAgICB0YXguY2xlYW4kU3BlY2llc1tpXSA8LSBwYXN0ZSgidW5jbF8iLHRheC5jbGVhbiRHZW51c1tpXSwgc2VwID0gIl8iKQ0KICB9DQp9DQoNCg0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyNUYXhhIGJhcnBsb3QNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQoNCg0KI0Fzc2lnbiBvdXIgZWRpdGVkIGFuZCBmb3JtYXR0ZWQgdGFibGVzIGFzIHZhcmlhYmxlcyB0byBiZSBmZWVkIGludG8gcGh5bG9zZXENCk9UVS5wcyA9IG90dV90YWJsZShhcy5tYXRyaXgoYXN2X3RhYmxlKSwgdGF4YV9hcmVfcm93cz1UUlVFKQ0KdGF4LnBzID0gdGF4X3RhYmxlKGFzLm1hdHJpeCh0YXguY2xlYW4pKSAgICANCm1ldGEucHMgPSBzYW1wbGVfZGF0YShtZXRhZGF0YSkNCg0KI1dlIHRoZW4gbWVyZ2UgdGhlc2UgaW50byBhbiBvYmplY3Qgb2YgY2xhc3MgcGh5bG9zZXEuDQpwc19iYXJfcGxvdCA9IHBoeWxvc2VxKE9UVS5wcywgdGF4LnBzLCBtZXRhLnBzKQ0KcHNfYmFyX3Bsb3QNCg0KIyBTZXQgY29sb3JzIGZvciBwbG90dGluZw0KbXlfY29sb3JzIDwtIGMoDQogICcjYTZjZWUzJywnIzFmNzhiNCcsJyNiMmRmOGEnLCcjMzNhMDJjJywnI2ZiOWE5OScsJyNlMzFhMWMnLA0KICAnI2ZkYmY2ZicsJyNmZjdmMDAnLCcjY2FiMmQ2JywnIzZhM2Q5YScsJyNmZmZmOTknLCcjYjE1OTI4JywgDQogICIjQ0JENTg4IiwgIiM1RjdGQzciLCAib3JhbmdlIiwiI0RBNTcyNCIsICIjNTA4NTc4IiwgIiNDRDlCQ0QiLA0KICAiI0FENkYzQiIsICIjNjczNzcwIiwiI0QxNDI4NSIsICIjNjUyOTI2IiwgIiNDODQyNDgiLCANCiAgIiM4NTY5RDUiLCAiIzVFNzM4RiIsIiNEMUEzM0QiLCAiIzhBN0M2NCIsICIjNTk5ODYxIiwgIiMwMDk5OTkiLCAiIzAwMDBGRiINCikNCg0KIyBJZiB5b3Ugd2FudCBkaWZmZXJlbnQgdGF4b25vbWljIGxldmVsLCBmaW5kIGFuZCByZXBsYWNlIHRoZSB0YXhvbm9taWMgbGV2ZWwgbGlzdGVkIGhlcmUNCm15X2xldmVsIDwtIGMoIlBoeWx1bSIsICJGYW1pbHkiLCAiR2VudXMiKQ0KbXlfY29sdW1uIDwtICJ0cmVhdG1lbnQiICAjIFRoaXMgaXMgdGhlIG1ldGFkYXRhIGNvbHVtbiB0aGF0IHdlIHdpbGwgdXNlIGluIHRoZSB0YXhhIGJhcnBsb3QNCg0Kcm0odGF4YS5zdW1tYXJ5KQ0KDQphYnVuZF9maWx0ZXIgPC0gMC4wNSAgIyBPdXIgYWJ1bmRhbmNlIHRocmVzaG9sZA0KDQpmb3IobWwgaW4gbXlfbGV2ZWwpew0KICBwcmludChtbCkNCiAgDQogIHRheGEuc3VtbWFyeSA8LSBwc19iYXJfcGxvdCAlPiUNCiAgICB0YXhfZ2xvbSh0YXhyYW5rID0gbWwsIE5Bcm0gPSBGQUxTRSkgJT4lICAjIGFnZ2xvbWVyYXRlIGF0IGBtbGAgbGV2ZWwNCiAgICB0cmFuc2Zvcm1fc2FtcGxlX2NvdW50cyhmdW5jdGlvbih4KSB7eC9zdW0oeCl9ICkgJT4lICMgVHJhbnNmb3JtIHRvIHJlbC4gYWJ1bmRhbmNlDQogICAgcHNtZWx0KCkgICU+JSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIE1lbHQgdG8gbG9uZyBmb3JtYXQNCiAgICBncm91cF9ieShnZXQobXlfY29sdW1uKSwgZ2V0KG1sKSwgdGltZS5wb2ludCkgJT4lDQogICAgc3VtbWFyaXNlKEFidW5kYW5jZS5hdmVydHJlYXRtZW50ID0gbWVhbihBYnVuZGFuY2UpKSANCiAgDQogIHRheGEuc3VtbWFyeSA8LSBhcy5kYXRhLmZyYW1lKHRheGEuc3VtbWFyeSkNCiAgY29sbmFtZXModGF4YS5zdW1tYXJ5KVsxXSA8LSBteV9jb2x1bW4NCiAgY29sbmFtZXModGF4YS5zdW1tYXJ5KVsyXSA8LSBtbA0KICANCiAgcHMudGF4YS5tYXggPC0gdGF4YS5zdW1tYXJ5ICU+JSANCiAgICBncm91cF9ieShnZXQobWwpKSAlPiUNCiAgICBzdW1tYXJpc2Uob3ZlcmFsbC5tYXggPSBtYXgoQWJ1bmRhbmNlLmF2ZXJ0cmVhdG1lbnQpKQ0KICANCiAgcHMudGF4YS5tYXggPC0gYXMuZGF0YS5mcmFtZShwcy50YXhhLm1heCkNCiAgY29sbmFtZXMocHMudGF4YS5tYXgpWzFdIDwtIG1sDQogIA0KICBwcy50YXhhLm1lYW4gPC0gdGF4YS5zdW1tYXJ5ICU+JSANCiAgICBncm91cF9ieShnZXQobWwpKSAlPiUNCiAgICBzdW1tYXJpc2Uob3ZlcmFsbC5tZWFuID0gbWVhbihBYnVuZGFuY2UuYXZlcnRyZWF0bWVudCkpDQogIA0KICBwcy50YXhhLm1lYW4gPC0gYXMuZGF0YS5mcmFtZShwcy50YXhhLm1lYW4pDQogIGNvbG5hbWVzKHBzLnRheGEubWVhbilbMV0gPC0gbWwNCiAgDQogICMgTWVyZ2luZyB0aGUgcGh5bGEgbWVhbnMgd2l0aCB0aGUgbWV0YWRhdGENCiAgcHNfbWV0YSA8LSBtZXJnZSh0YXhhLnN1bW1hcnksIHBzLnRheGEubWF4KQ0KICBwc19tZXRhIDwtIG1lcmdlKHBzX21ldGEsIHBzLnRheGEubWVhbikNCiAgDQogIHBzX21ldGFfZmlsdGVyZWQgPC0gZmlsdGVyKHBzX21ldGEsIG92ZXJhbGwubWF4ID4gYWJ1bmRfZmlsdGVyKQ0KICANCiAgcHNfbWV0YV9maWx0ZXJlZCRteV9jb2x1bW4gPC0gZmFjdG9yKHBzX21ldGFfZmlsdGVyZWRbW215X2NvbHVtbl1dLCBsZXZlbHMgPSB1bmlxdWUocHNfbWV0YV9maWx0ZXJlZFtbbXlfY29sdW1uXV0pKQ0KICANCiAgcHNfbWV0YV9maWx0ZXJlZFtbbWxdXSA8LSBmYWN0b3IocHNfbWV0YV9maWx0ZXJlZFtbbWxdXSwgbGV2ZWxzID0gdW5pcXVlKHBzX21ldGFfZmlsdGVyZWRbW21sXV0pKQ0KICANCiAgIyBQbG90IA0KICBnZ3Bsb3QocHNfbWV0YV9maWx0ZXJlZCwgYWVzKHggPSBteV9jb2x1bW4sIHkgPSBBYnVuZGFuY2UuYXZlcnRyZWF0bWVudCwgZmlsbCA9IGdldChtbCkpKSArIA0KICAgIGZhY2V0X2dyaWQoLn50aW1lLnBvaW50KSArKw0KICB0aGVtZV9jbGFzc2ljKCkgKw0KICAgIGdlb21fYmFyKHN0YXQgPSAiaWRlbnRpdHkiKSArDQogICAgc2NhbGVfZmlsbF9tYW51YWwodmFsdWVzID0gbXlfY29sb3JzKSArDQogICAgeWxpbShjKDAsIDEpKSArDQogICAgZ3VpZGVzKGZpbGwgPSBndWlkZV9sZWdlbmQocmV2ZXJzZSA9IEZBTFNFLCBrZXl3aWR0aCA9IDAuNSwga2V5aGVpZ2h0ID0gMC41LCBuY29sID0gMSkpICsNCiAgICB0aGVtZShsZWdlbmQudGV4dCA9IGVsZW1lbnRfdGV4dChzaXplID0gOCkpICsNCiAgICB0aGVtZShsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiKSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSA5MCwgaGp1c3QgPSAxLCB2anVzdCA9IDAuNSkpICsNCiAgICB0aGVtZShsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpICsNCiAgICB5bGFiKCJSZWxhdGl2ZSBBYnVuZGFuY2UiKSArDQogICAgeGxhYihteV9jb2x1bW4pICsNCiAgICBnZ3RpdGxlKHBhc3RlMChtbCwgIiAoPiIsIGFidW5kX2ZpbHRlciAqIDEwMCwiJSkgaW4gYXQgbGVhc3QgMSBzYW1wbGUiKSkgDQogIGdnc2F2ZShwYXN0ZTAoImFscGhhX2RpdmVyc2l0eV9wbG90cy90YXhhLyIsIG1sLCAiQmFyUGxvdF8iLCBteV9jb2x1bW4sICIucG5nIiksIGhlaWdodCA9IDUsIHdpZHRoID0gNCwgY3JlYXRlLmRpciA9IFRSVUUpDQp9DQoNCmBgYA0KDQpERVNlcQ0KYGBge3J9DQojRGVzZXEgY29ycmVjdGVkDQoNCmxpYnJhcnkoIkRFU2VxMiIpDQpsaWJyYXJ5KERFU2VxMikNCg0KI3BzIDwtIHF6YV90b19waHlsb3NlcSgNCiAgI2ZlYXR1cmVzPSJyYXJlZmllZF90YWJsZS5xemEiLA0KICMgdHJlZT0icm9vdGVkLXRyZWUucXphIiwNCiAgI3RheG9ub215ID0gInRheG9ub215LnF6YSIsDQogICNtZXRhZGF0YSA9ICJwcm9qZWN0X21ldGFkYXRhLnR4dCINCiMpDQojbWV0YWRhdGE8LXJlYWRfcTJtZXRhZGF0YSgicHJvamVjdF9tZXRhZGF0YS50eHQiKQ0KIyBGaXJzdCBnZXQgdGhlIE9UVSB0YWJsZSBmcm9tIHBoeXNlcQ0KDQpwaHlzZXFfb3R1X3RhYmxlIDwtIGRhdGEuZnJhbWUob3R1X3RhYmxlKHBzKSwgY2hlY2submFtZXMgPSBGQUxTRSkNCk9UVS5jbGVhbjIgPC0gcGh5c2VxX290dV90YWJsZSArIDENCg0KT1RVLnBoeXNlcSA8LSBvdHVfdGFibGUoYXMubWF0cml4KE9UVS5jbGVhbjIpLCB0YXhhX2FyZV9yb3dzPVRSVUUpDQp0YXgucGh5c2VxIDwtIHRheF90YWJsZShhcy5tYXRyaXgodGF4LmNsZWFuKSkNCm1ldGEucGh5c2VxIDwtIHNhbXBsZV9kYXRhKG1ldGFkYXRhKQ0KDQpwaHlzZXFfZGVzZXEgPSBwaHlsb3NlcShPVFUucGh5c2VxLCB0YXgucGh5c2VxLCBtZXRhLnBoeXNlcSkNCg0KZGlhZ2RkcyA8LSBwaHlsb3NlcV90b19kZXNlcTIocGh5c2VxX2Rlc2VxICwgfiB0cmVhdG1lbnQpDQpkaWFnZGRzIDwtIERFU2VxKGRpYWdkZHMsIHRlc3Q9IldhbGQiLCBmaXRUeXBlPSJwYXJhbWV0cmljIikNCg0KYWxwaGEgPC0gMC4wNQ0KDQpydW5fZGVzZXEyIDwtIGZ1bmN0aW9uKHRyZWF0bWVudCwgQmFzYWwsIEJTZWEwNSwgQlNlYTEwLCBCU2VhMTUpIHsNCiAgbXlfY29udHJhc3QgPC0gYygidHJlYXRtZW50IiwgQmFzYWwsIEJTZWEwNSkgDQogIHJlcyA8LSByZXN1bHRzKGRpYWdkZHMsIGNvbnRyYXN0ID0gbXlfY29udHJhc3QsIGNvb2tzQ3V0b2ZmID0gRkFMU0UpDQogIHNpZ3RhYiA8LSByZXNbd2hpY2gocmVzJHBhZGogPCBhbHBoYSksIF0NCiAgc2lndGFiIDwtIGNiaW5kKGFzKHNpZ3RhYiwgImRhdGEuZnJhbWUiKSwgYXModGF4X3RhYmxlKHBoeXNlcV9kZXNlcSlbcm93bmFtZXMoc2lndGFiKSwgXSwgIm1hdHJpeCIpKQ0KDQogIHRoZW1lX3NldCh0aGVtZV9idygpKQ0KICBzY2FsZV9maWxsX2Rpc2NyZXRlIDwtIGZ1bmN0aW9uKHBhbG5hbWUgPSAiU2V0MSIsIC4uLikgew0KICAgIHNjYWxlX2ZpbGxfYnJld2VyKHBhbGV0dGUgPSBwYWxuYW1lLCAuLi4pDQogIH0NCiAgDQogIHggPC0gdGFwcGx5KHNpZ3RhYiRsb2cyRm9sZENoYW5nZSwgc2lndGFiJEdlbnVzLCBmdW5jdGlvbih4KSBtYXgoeCkpDQogIHggPC0gc29ydCh4LCBUUlVFKQ0KICBzaWd0YWIkR2VudXMgPC0gZmFjdG9yKGFzLmNoYXJhY3RlcihzaWd0YWIkR2VudXMpLCBsZXZlbHM9bmFtZXMoeCkpDQogIA0KICBERVNlcV9maWcgPC0gZ2dwbG90KHNpZ3RhYiwgYWVzKHg9R2VudXMsIHk9bG9nMkZvbGRDaGFuZ2UsIGNvbG9yPVBoeWx1bSkpICsgDQogICAgZ2VvbV9wb2ludChzaXplPTMpICsgDQogICAgeWxhYihwYXN0ZTAoIigiLCBCYXNhbCwgIi8iLCBCU2VhMDUsICIpXG4iLCAibG9nMkZvbGRDaGFuZ2UiKSkgKw0KICAgIGNvb3JkX2ZsaXAoKSArDQogICAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IG15X2NvbG9yc1tjKDQsNiw4LDEwLDEyLDE0LDE2LDE4LDIwKV0pICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IC05MCwgaGp1c3QgPSAwLCB2anVzdD0wLjUpKQ0KICANCiAgZ2dzYXZlKHBhc3RlMCgiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL0RFU2VxMi0iLCBCYXNhbCwgIi0iLCBCU2VhMDUsICItY2hpY2tlbi5wbmciKSwgREVTZXFfZmlnLCBoZWlnaHQgPSAxMCwgd2lkdGggPSA3KQ0KfQ0KDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTA1IikNCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMTAiKQ0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWExNSIpIA0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJTZWEwNSIsICJCU2VhMTAiKSANCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCU2VhMDUiLCAiQlNlYTE1IikgDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQlNlYTEwIiwgIkJTZWExNSIpDQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KI3RoaXMgaXMgYmFzZWQgb24gdGltZSBwb2ludCBkaWZmZXJlbmNlcw0KDQojc3Vic2V0IGJhc2VkIG9uIHRpbWUNCnBzMTUgPC0gc3Vic2V0X3NhbXBsZXMocGh5c2VxX2Rlc2VxLCB0aW1lLnBvaW50ID09ICJEYXkyMiIpDQpwczE1IDwtIHBoeWxvc2VxOjpzdWJzZXRfc2FtcGxlcyhwczE1LCB0cmVhdG1lbnQgJWluJSBjKCJCYXNhbCIsICJCU2VhMDUiLCAiQlNlYTEwIiwgIkJTZWExNSIpKQ0KIA0KDQoNCmRpYWdkZHMxIDwtIHBoeWxvc2VxX3RvX2Rlc2VxMihwczE1ICwgfiB0cmVhdG1lbnQpDQpkaWFnZGRzMSA8LSBERVNlcShkaWFnZGRzMSwgdGVzdD0iV2FsZCIsIGZpdFR5cGU9InBhcmFtZXRyaWMiKQ0KDQphbHBoYSA8LSAwLjA1DQoNCnJ1bl9kZXNlcTIgPC0gZnVuY3Rpb24odHJlYXRtZW50LCBCYXNhbCwgQlNlYTA1LCBCU2VhMTAsIEJTZWExNSkgew0KICBteV9jb250cmFzdCA8LSBjKCJ0cmVhdG1lbnQiLCBCYXNhbCwgQlNlYTA1KSANCiAgcmVzIDwtIHJlc3VsdHMoZGlhZ2RkczEsIGNvbnRyYXN0ID0gbXlfY29udHJhc3QsIGNvb2tzQ3V0b2ZmID0gRkFMU0UpDQogIHNpZ3RhYjEgPC0gcmVzW3doaWNoKHJlcyRwYWRqIDwgYWxwaGEpLCBdDQogIHNpZ3RhYjEgPC0gY2JpbmQoYXMoc2lndGFiMSwgImRhdGEuZnJhbWUiKSwgYXModGF4X3RhYmxlKHBzMTUpW3Jvd25hbWVzKHNpZ3RhYjEpLCBdLCAibWF0cml4IikpDQoNCiAgdGhlbWVfc2V0KHRoZW1lX2J3KCkpDQogIHNjYWxlX2ZpbGxfZGlzY3JldGUgPC0gZnVuY3Rpb24ocGFsbmFtZSA9ICJTZXQxIiwgLi4uKSB7DQogICAgc2NhbGVfZmlsbF9icmV3ZXIocGFsZXR0ZSA9IHBhbG5hbWUsIC4uLikNCiAgfQ0KICANCiAgeCA8LSB0YXBwbHkoc2lndGFiMSRsb2cyRm9sZENoYW5nZSwgc2lndGFiMSRHZW51cywgZnVuY3Rpb24oeCkgbWF4KHgpKQ0KICB4IDwtIHNvcnQoeCwgVFJVRSkNCiAgc2lndGFiMSRHZW51cyA8LSBmYWN0b3IoYXMuY2hhcmFjdGVyKHNpZ3RhYjEkR2VudXMpLCBsZXZlbHM9bmFtZXMoeCkpDQogIA0KICBERVNlcV9maWcgPC0gZ2dwbG90KHNpZ3RhYjEsIGFlcyh4PUdlbnVzLCB5PWxvZzJGb2xkQ2hhbmdlLCBjb2xvcj1QaHlsdW0pKSArIA0KICAgIGdlb21fcG9pbnQoc2l6ZT0zKSArIA0KICAgIHlsYWIocGFzdGUwKCIoIiwgQmFzYWwsICIvIiwgQlNlYTA1LCAiKVxuIiwgImxvZzJGb2xkQ2hhbmdlIikpICsNCiAgICBjb29yZF9mbGlwKCkgKw0KICAgIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBteV9jb2xvcnNbYyg0LDYsOCwxMCwxMiwxNCwxNiwxOCwyMCldKSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSAtOTAsIGhqdXN0ID0gMCwgdmp1c3Q9MC41KSkNCiAgDQogIGdnc2F2ZShwYXN0ZTAoIkRlc2VxZGF5L0RFU2VxMi0iLCBCYXNhbCwgIi0iLCBCU2VhMDUsICItZGF5MTUucG5nIiksIERFU2VxX2ZpZywgaGVpZ2h0ID0gMTAsIHdpZHRoID0gNykNCn0NCg0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWEwNSIpDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTEwIikNCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMTUiKSANCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCU2VhMDUiLCAiQlNlYTEwIikgDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQlNlYTA1IiwgIkJTZWExNSIpIA0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJTZWExMCIsICJCU2VhMTUiKQ0KDQojIyMjIyMjIyMjIyNEYXkyMg0KcHMyMiA8LSBzdWJzZXRfc2FtcGxlcyhwaHlzZXFfZGVzZXEsIHRpbWUucG9pbnQgPT0gIkRheTIyIikNCnBzMjIgPC0gcGh5bG9zZXE6OnN1YnNldF9zYW1wbGVzKHBzMjIsIHRyZWF0bWVudCAlaW4lIGMoIkJhc2FsIiwgIkJTZWEwNSIsICJCU2VhMTAiLCAiQlNlYTE1IikpDQpkaWFnZGRzMiA8LSBwaHlsb3NlcV90b19kZXNlcTIocHMyMiAsIH4gdHJlYXRtZW50KQ0KZGlhZ2RkczIgPC0gREVTZXEoZGlhZ2RkczIsIHRlc3Q9IldhbGQiLCBmaXRUeXBlPSJwYXJhbWV0cmljIikNCmFscGhhIDwtIDAuMDUNCnJ1bl9kZXNlcTIgPC0gZnVuY3Rpb24odHJlYXRtZW50LCBCYXNhbCwgQlNlYTA1LCBCU2VhMTAsIEJTZWExNSkgew0KbXlfY29udHJhc3QgPC0gYygidHJlYXRtZW50IiwgQmFzYWwsIEJTZWEwNSkgDQogcmVzIDwtIHJlc3VsdHMoZGlhZ2RkczIsIGNvbnRyYXN0ID0gbXlfY29udHJhc3QsIGNvb2tzQ3V0b2ZmID0gRkFMU0UpDQogc2lndGFiMiA8LSByZXNbd2hpY2gocmVzJHBhZGogPCBhbHBoYSksIF0NCiAgc2lndGFiMiA8LSBjYmluZChhcyhzaWd0YWIyLCAiZGF0YS5mcmFtZSIpLCBhcyh0YXhfdGFibGUocHMyMilbcm93bmFtZXMoc2lndGFiMiksIF0sICJtYXRyaXgiKSkNCg0KICB0aGVtZV9zZXQodGhlbWVfYncoKSkNCiAgc2NhbGVfZmlsbF9kaXNjcmV0ZSA8LSBmdW5jdGlvbihwYWxuYW1lID0gIlNldDEiLCAuLi4pIHsNCiAgICBzY2FsZV9maWxsX2JyZXdlcihwYWxldHRlID0gcGFsbmFtZSwgLi4uKQ0KICB9DQogIA0KICB4IDwtIHRhcHBseShzaWd0YWIyJGxvZzJGb2xkQ2hhbmdlLCBzaWd0YWIyJEdlbnVzLCBmdW5jdGlvbih4KSBtYXgoeCkpDQogIHggPC0gc29ydCh4LCBUUlVFKQ0KICBzaWd0YWIyJEdlbnVzIDwtIGZhY3Rvcihhcy5jaGFyYWN0ZXIoc2lndGFiMiRHZW51cyksIGxldmVscz1uYW1lcyh4KSkNCiAgDQogIERFU2VxX2ZpZyA8LSBnZ3Bsb3Qoc2lndGFiMiwgYWVzKHg9R2VudXMsIHk9bG9nMkZvbGRDaGFuZ2UsIGNvbG9yPVBoeWx1bSkpICsgDQogICAgZ2VvbV9wb2ludChzaXplPTMpICsgDQogICAgeWxhYihwYXN0ZTAoIigiLCBCYXNhbCwgIi8iLCBCU2VhMDUsICIpXG4iLCAibG9nMkZvbGRDaGFuZ2UiKSkgKw0KICAgIGNvb3JkX2ZsaXAoKSArDQogICAgc2NhbGVfY29sb3JfbWFudWFsKHZhbHVlcyA9IG15X2NvbG9yc1tjKDQsNiw4LDEwLDEyLDE0LDE2LDE4LDIwKV0pICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IC05MCwgaGp1c3QgPSAwLCB2anVzdD0wLjUpKQ0KICANCiAgZ2dzYXZlKHBhc3RlMCgiRGVzZXFkYXkvREVTZXEyLSIsIEJhc2FsLCAiLSIsIEJTZWEwNSwgIi1kYXkyMi5wbmciKSwgREVTZXFfZmlnLCBoZWlnaHQgPSAxMCwgd2lkdGggPSA3KQ0KfQ0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWEwNSIpDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTEwIikNCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMTUiKSANCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCU2VhMDUiLCAiQlNlYTEwIikgDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQlNlYTA1IiwgIkJTZWExNSIpIA0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJTZWExMCIsICJCU2VhMTUiKQ0KYGBgDQoNCkNvLWFidW5kYW50IGdyb3VwcyBvZiB0YXhhDQpgYGB7cn0NCiNDby1hYnVuZGFudCBncm91cHMgb2YgdGF4YSoqICAgIA0KI2h0dHBzOi8vZ2l0aHViLmNvbS9taWNyb2Jpb21lL3R1dG9yaWFscy9ibG9iL21hc3Rlci9Db0FidW5kYW50VGF4YS5SbWQNCg0KbGlicmFyeShtaWNyb2Jpb21lKQ0KI2NvbnRpbnVlZCBmcm9tIHRoZSAiUFMiIHBoeWxvc2VxIGFib3ZlDQpwc2VxIDwtIHBzDQpwc2VxIDwtIGFnZ3JlZ2F0ZV9yYXJlKHBzZXEsIGxldmVsID0gIkdlbnVzIiwgZGV0ZWN0aW9uID0gMS8xMDAsIHByZXZhbGVuY2UgPSA1MC8xMDApDQpwc2VxLnJlbCA8LSBtaWNyb2Jpb21lOjp0cmFuc2Zvcm0ocHNlcSwgImNvbXBvc2l0aW9uYWwiKQ0KDQojIGdldCBtZWRpYW4gYWJ1bmRhbmNlcyANCm1lZGlhbl9hYnVuZCA9IGFwcGx5KGFidW5kYW5jZXMocHNlcS5yZWwpLCBNQVJHSU4gPSAxLCBGVU4gPSBtZWRpYW4pDQoNCiMgc2VsZWN0IHRheGEgd2l0aCBtZWRpYW4gYWJ1bmRhbmNlIG9mIG1vcmUgdGhhbiBvciBlcXVhbCB0byAwLjAxDQphYnVuZGFudF90YXhhID0gYWJ1bmRhbmNlcyhwc2VxKVttZWRpYW5fYWJ1bmQgPj0gMC4wMSwgXQ0KIyBjaGVjayBob3cgbWFueSB0YXhhDQpucm93KGFidW5kYW50X3RheGEpDQojIGNoZWNrIHdoaWNoIHRheGENCnJvd25hbWVzKGFidW5kYW50X3RheGEpDQoNCg0KDQojVXNlIFNwZWFybWFuJ3MgY29ycmVsYXRpb24gdG8gaWRlbnRpZnkgd2hpY2ggb2YgdGhlIGNvLWFidW5kYW50IGdyb3VwcyBzaG93IGNvcnJlbGF0aW9uLiAgDQojIGNvcigpIGlzIGZyb20gYHN0YXRzYCBwYWNrdHJlYXRtZW50DQpzcGVhcm1hbl9tYXRyaXggPSBjb3IodChhYnVuZGFudF90YXhhKSwgbWV0aG9kID0gInNwZWFybWFuIikNCiMgaGNsdXN0KCkgaXMgZnJvbSBgc3RhdHNgIHBhY2t0cmVhdG1lbnQNCnNwZWFybWFuX3RyZWUgPSBoY2x1c3QoZGlzdChzcGVhcm1hbl9tYXRyaXgpLCBtZXRob2QgPSAid2FyZC5EMiIpDQpwbG90KHNwZWFybWFuX3RyZWUpDQoNCiNVc2luZyB0aGUgYGhlYXRgIGZ1bmN0aW9uIGluIGBtaWNyb2Jpb21lIHBrZ2Agbm93IGNvbXBhcmUgdGhlIGNvcnJlbGF0aW9uIHdpdGggdGhlIHRyZWUgYWJvdmUuICANCnNwZWFybWFuX2xvbmdfZGYgPC0gcmVzaGFwZTI6Om1lbHQoc3BlYXJtYW5fbWF0cml4KQ0KaGVhZChzcGVhcm1hbl9sb25nX2RmKQ0KDQpjb3JhYnUgPC0gaGVhdChzcGVhcm1hbl9sb25nX2RmLCAiVmFyMSIsIlZhcjIiLCANCiAgICAgb3JkZXIucm93cyA9IFRSVUUsIG9yZGVyLmNvbHMgPSBUUlVFKSArIA0KICB0aGVtZV9idygpICsgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoYW5nbGUgPSA5MCkpICsNCiAgZ2d0aXRsZSgiQ29ycmVsYXRpb24gQWJ1bmRhbmNlIGF0IEdlbnVzIExldmVsIikNCg0KY29yYWJ1DQpnZ3NhdmUoImFscGhhX2RpdmVyc2l0eV9wbG90cy9Db3JyZWxhdGlvbl9hYnVuZGFuY2UucG5nIiwgcGxvdCA9IGNvcmFidSwgaGVpZ2h0ID0gNywgd2lkdGggPSAxNCkNCg0KIyBWYWxpZGF0aW9uIG9mIENBR3MgDQojIFJhbmRvbWx5IHNwbGl0IHRoZSBkYXRhc2V0LCBjb21wdXRlIGEgY29ycmVsYXRpb24gbWF0cml4IGFuZCBydW4gYSBNYW50ZWwgdGVzdA0Kc3Vic2FtcGxlID0gc2FtcGxlKGMoMTo2NCksIHNpemUgPSAyMjAsIHJlcGxhY2UgPSBUKQ0KdHJhaW5fZGF0YSA9IGFidW5kYW50X3RheGFbLHN1YnNhbXBsZV0NCnRlc3RfZGF0YSA9IGFidW5kYW50X3RheGFbLC1zdWJzYW1wbGVdDQp0cmFpbl9zcGVhcm1hbiA9IGNvcih0KHRyYWluX2RhdGEpLCBtZXRob2QgPSAic3BlYXJtYW4iKQ0KdGVzdF9zcGVhcm1hbiA9IGNvcih0KHRlc3RfZGF0YSksIG1ldGhvZCA9ICJzcGVhcm1hbiIpDQp2ZWdhbjo6bWFudGVsKGFzLmRpc3QodHJhaW5fc3BlYXJtYW4pLCBhcy5kaXN0KHRlc3Rfc3BlYXJtYW4pLCBwZXJtdXRhdGlvbnM9OTk5KQ0KDQoNCg0KYGBgDQoNCg0KUmFuZG9tIEZvcmVzdA0KYGBge3J9DQojUmFuZG9tIEZvcmVzdCA6IGh0dHBzOi8vcnB1YnMuY29tL21pY2hiZXJyL3JhbmRvbWZvcmVzdG1pY3JvYmUNCmxpYnJhcnkoZ2dwbG90MikNCmxpYnJhcnkodmVnYW4pDQpsaWJyYXJ5KGRwbHlyKQ0KbGlicmFyeShtYWdyaXR0cikNCmxpYnJhcnkoc2NhbGVzKQ0KbGlicmFyeShncmlkKQ0KbGlicmFyeShyZXNoYXBlMikNCmxpYnJhcnkocGh5bG9zZXEpDQpsaWJyYXJ5KHJhbmRvbUZvcmVzdCkNCmxpYnJhcnkoa25pdHIpDQpsaWJyYXJ5KHZpcmlkaXMpDQoNCg0KI3VzaW5nIHRoZSBQUyBnZW5lcmF0ZWQgYWJvdmUNCnBzZXEgPC0gcHMNCnBzZXEgPC0gYWdncmVnYXRlX3JhcmUocHNlcSwgbGV2ZWwgPSAiR2VudXMiLCBkZXRlY3Rpb24gPSAxLzEwMCwgcHJldmFsZW5jZSA9IDUwLzEwMCkNCg0KIyBHZW5lcmF0ZSA1MCBjb2xvcnMgZnJvbSB0aGUgdmlyaWRpcyBwYWxldHRlDQpwaHkgPC0gdmlyaWRpcyg1MCkNCnBoeSRjb2xvcnMgPC0gY29sb3JzDQoNCm50YXhhKHBzZXEpDQojIFNldCBwcnVuZXNjYWxlIA0KcHJ1bmVzY2FsZSA9IDAuMDAwMQ0KDQojIFNldCBtaW5saWINCm1pbmxpYiA9IDEzOTAwICNncmVhdGVyIHRoYW4gbWluZQ0KDQojIFBydW5lIG91dCByYXJlIE9UVXMgYnkgbWVhbiByZWxhdGl2ZSBhYnVuZGFuY2Ugc2V0IGJ5IHBydW5lc2NhbGUNCnRheC5tZWFuIDwtIHRheGFfc3Vtcyhwc2VxKS9uc2FtcGxlcyhwc2VxKQ0Kc2l0ZXMucHJ1bmUgPC0gcHJ1bmVfdGF4YSh0YXgubWVhbiA+IHBydW5lc2NhbGUqbWlubGliLCBwc2VxKQ0KDQpzaXRlcy5wcnVuZQ0KDQojIE1ha2UgYSBkYXRhZnJhbWUgb2YgdHJhaW5pbmcgcHNhIHdpdGggT1RVcyBhcyBjb2x1bW4gYW5kIHNhbXBsZXMgYXMgcm93cw0KcHJlZGljdG9ycyA8LSB0KG90dV90YWJsZShwc2VxKSkNCmRpbShwcmVkaWN0b3JzKQ0KcHJlZGljdG9ycw0KI1dlIGhhdmUgNjQgc2FtcGxlcyBhbmQgMzI2IE9UVXMNCiMgTWFrZSBvbmUgY29sdW1uIGZvciBvdXIgb3V0Y29tZS9yZXNwb25zZSB2YXJpYWJsZSANCnJlc3BvbnNlIDwtIGFzLmZhY3RvcihzYW1wbGVfZGF0YShzaXRlcy5wcnVuZSkkdHJlYXRtZW50KQ0KDQojIENvbWJpbmUgdGhlbSBpbnRvIDEgcHNhIGZyYW1lDQpyZi5wc2EgPC0gZGF0YS5mcmFtZShyZXNwb25zZSwgcHJlZGljdG9ycykNCg0KI3Jlc3VsdA0Kc2V0LnNlZWQoMCkNCnBzLmNsYXNzaWZ5IDwtIHJhbmRvbUZvcmVzdChyZXNwb25zZX4uLCBkYXRhID0gcmYucHNhLCBudHJlZSA9IDEwMCkNCnByaW50KHBzLmNsYXNzaWZ5KQ0KDQojVGhlIG91dCBvZiBiYWcgZXJyb3IgaXMgNTQuNjklIC4NCiMgV2hhdCB2YXJpYWJsZXMgYXJlIHN0b3JlZCBpbiB0aGUgb3V0cHV0Pw0KbmFtZXMocHMuY2xhc3NpZnkpDQoNCiNwbG90cw0KDQojIE1ha2UgYSBwc2EgZnJhbWUgd2l0aCBwcmVkaWN0b3IgbmFtZXMgYW5kIHRoZWlyIGltcG9ydGFuY2UNCmltcCA8LSBpbXBvcnRhbmNlKHBzLmNsYXNzaWZ5KQ0KaW1wIDwtIGRhdGEuZnJhbWUocHJlZGljdG9ycyA9IHJvd25hbWVzKGltcCksIGltcCkNCg0KIyBPcmRlciB0aGUgcHJlZGljdG9yIGxldmVscyBieSBpbXBvcnRhbmNlDQppbXAuc29ydCA8LSBhcnJhbmdlKGltcCwgZGVzYyhNZWFuRGVjcmVhc2VHaW5pKSkNCmltcC5zb3J0JHByZWRpY3RvcnMgPC0gZmFjdG9yKGltcC5zb3J0JHByZWRpY3RvcnMsIGxldmVscyA9IGltcC5zb3J0JHByZWRpY3RvcnMpDQoNCiMgU2VsZWN0IHRoZSB0b3AgMTAgcHJlZGljdG9ycw0KaW1wLjIwIDwtIGltcC5zb3J0WzE6MzAsIF0NCg0KDQojIGdncGxvdA0KUmFuZG9mb3JlIDwtIGdncGxvdChpbXAuMjAsIGFlcyh4ID0gcHJlZGljdG9ycywgeSA9IE1lYW5EZWNyZWFzZUdpbmkpKSArDQogIGdlb21fYmFyKHN0YXQgPSAiaWRlbnRpdHkiLCBmaWxsID0gImluZGlhbnJlZCIpICsNCiAgY29vcmRfZmxpcCgpICsNCiAgZ2d0aXRsZSgiTW9zdCBpbXBvcnRhbnQgT1RVcyBmb3IgY2xhc3NpZnlpbmcgc2FtcGxlcyBieSB0cmVhdG1lbnQgYW5kIHRpbWUiKQ0KUmFuZG9mb3JlDQoNCmdnc2F2ZSgiYWxwaGFfZGl2ZXJzaXR5X3Bsb3RzL1JhbmRvbSBmb3Jlc3QucG5nIiwgUmFuZG9mb3JlLCB3aWR0aCA9IDEyLCBoZWlnaHQgPSA2LCBiZyA9ICJ3aGl0ZSIpDQpgYGANCg0KUElDUlVTVA0KYGBge3J9DQojcGljcnVzdA0KIyMgVGhpcyBzY3JpcHQgZ29lcyB0aHJvdWdoIHBpY3J1c3Qgb3V0cHV0IGFuZCB0aGVuIHVzZXMNCiMjIERFU2VxMiB0byBmaW5kIGRpZmZlcmVudGlhbGx5IGFidW5kYW50IHBhdGh3YXlzIA0KDQpsaWJyYXJ5KERFU2VxMikNCmxpYnJhcnkocWlpbWUyUikNCmxpYnJhcnkocGh5bG9zZXEpDQpsaWJyYXJ5KHpvbykNCmxpYnJhcnkodGlkeXZlcnNlKQ0KbGlicmFyeShnZ3BpY3J1c3QyKQ0KbGlicmFyeShyZWFkeGwpDQoNCiNTZXQgVVANCiMNCiNUaGVzZSBhcmUgdGhlIHRoaW5ncyB0aGF0ICB3ZSBuZWVkIGZyb20gUWlpbWU6DQojDQojbWV0YQ0KI3BhdGh3YXlfYWJ1bmRhbmNlLnF6YQ0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KIyMjRGlmZmVyZW50aWFsIEFidW5kYW5jZSB3aXRoIERFU2VxMg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCg0KDQojQWRhcHRlZCBmcm9tIGh0dHBzOi8vam9leTcxMS5naXRodWIuaW8vcGh5bG9zZXEtZXh0ZW5zaW9ucy9ERVNlcTIuaHRtbA0KDQojRmlyc3QgbG9hZCBERVNlcTIuDQoNCiNUbyB1c2UgREVTZXEsIHdlIG5lZWQgbm8gemVyb3MgaW4gb3VyIE9UVSB0YWJsZS4gU28gd2Ugd2lsbCBlZGl0IHRoZSB0YWJsZSBieSBtdWx0aXBseWluZyBieSAyIGFuZCArIDENCg0KI0ZpcnN0IGdldCB0aGUgcGF0aHdheSB0YWJsZSBmcm9tIHBoeXNlcQ0KIyBOb3RlIHRoYXQgdGhlIHNhbXBsZXMgaW4gYm90aCB0aGUgbWV0YWRhdGEgYW5kIHRoZSANCiMgcGljcnVzdCBvdXRwdXQgbmVlZCB0byBiZSB0aGUgc2FtZSANCm1ldGFkYXRhPC1yZWFkX3EybWV0YWRhdGEoInByb2plY3RfbWV0YWRhdGEudHh0IikNCnN0cihtZXRhZGF0YSkNCnJvd25hbWVzKG1ldGFkYXRhKSA8LSBtZXRhZGF0YSRTYW1wbGVJRA0KbWV0YWRhdGEgPC0gbWV0YWRhdGFbLC0xXQ0KY29sbmFtZXMobWV0YWRhdGEpWzJdID0gInRpbWUtcG9pbnQiDQpjb2xuYW1lcyhtZXRhZGF0YSlbNV0gPSAidHJlYXRtZW50Ig0KbGV2ZWxzKG1ldGFkYXRhJGB0aW1lLXBvaW50YCkNCmxldmVscyhtZXRhZGF0YSR0cmVhdG1lbnQpDQpzdHIobWV0YWRhdGEpDQoNCiNSZWFkIGluIHRoZSBvdXRwdXQgZnJvbSBwaWNydXN0Mg0KcGljcnVzdF90YWJsZSA8LSByZWFkX3F6YSgicGF0aHdheV9hYnVuZGFuY2UucXphIikNCnBpY3J1c3RfdGFibGUgPC0gcGljcnVzdF90YWJsZSRkYXRhDQpwaWNydXN0X3RhYmxlIDwtIGRhdGEuZnJhbWUocGljcnVzdF90YWJsZSwgY2hlY2submFtZXMgPSBGKQ0KcGljcnVzdF90YWJsZSA8LSBwaWNydXN0X3RhYmxlICsgMQ0Kc3RyKHBpY3J1c3RfdGFibGUpDQoNCiNNYWtlIHN1cmUgdGhlIHNhbWUgc2FtcGxlcyBhcmUgaW4gYm90aCB0aGUgcGljcnVzdCB0YWJsZSBhbmQgdGhlIG1ldGFkYXRhDQptZXRhZGF0YS5maWx0ZXJlZCA9IG1ldGFkYXRhW3Jvd25hbWVzKG1ldGFkYXRhKSAlaW4lIGNvbG5hbWVzKHBpY3J1c3RfdGFibGUpLF0NCg0KI0Fzc2lnbiBhcyB2YXJpYWJsZXMgdG8gYmUgZmVlZCBpbnRvIHBoeWxvc2VxDQpPVFUucGh5c2VxID0gb3R1X3RhYmxlKGFzLm1hdHJpeChwaWNydXN0X3RhYmxlKSwgdGF4YV9hcmVfcm93cz1UUlVFKQ0KDQptZXRhLnBoeXNlcSA9IHNhbXBsZV9kYXRhKG1ldGFkYXRhLmZpbHRlcmVkKQ0KDQojV2UgdGhlbiBtZXJnZSB0aGVzZSBpbnRvIGFuIG9iamVjdCBvZiBjbGFzcyBwaHlsb3NlcS4NCg0KcGh5c2VxX3BpY3J1c3QgPSBwaHlsb3NlcShPVFUucGh5c2VxLCBtZXRhLnBoeXNlcSkNCg0KDQojVGhlIGZvbGxvd2luZyB0d28gbGluZXMgYWN0dWFsbHkgZG8gYWxsIHRoZSBjb21wbGljYXRlZCBERVNlcTIgd29yay4gVGhlIGZ1bmN0aW9uIHBoeWxvc2VxX3RvX2Rlc2VxMiBjb252ZXJ0cyB5b3VyIHBoeWxvc2VxLWZvcm1hdCBtaWNyb2Jpb21lIGRhdGEgaW50byBhIERFU2VxRGF0YVNldCB3aXRoIGRpc3BlcnNpb25zIGVzdGltYXRlZCwgdXNpbmcgdGhlIGV4cGVyaW1lbnRhbCBkZXNpZ24gZm9ybXVsYSwgYWxzbyBzaG93biAodGhlIH5ib2R5LnNpdGUgdGVybSkuIFRoZSBERVNlcSBmdW5jdGlvbiBkb2VzIHRoZSByZXN0IG9mIHRoZSB0ZXN0aW5nLCBpbiB0aGlzIGNhc2Ugd2l0aCBkZWZhdWx0IHRlc3RpbmcgZnJhbWV3b3JrLCBidXQgeW91IGNhbiBhY3R1YWxseSB1c2UgYWx0ZXJuYXRpdmVzLg0KDQojIEVudGVyIHRoZSBzdGF0aXN0aWNhbCBtb2RlbCB5b3Ugd2FudCB0byB0ZXN0LiBFZy4gYH4gZGlldGANCmRpYWdkZHMgPSBwaHlsb3NlcV90b19kZXNlcTIocGh5c2VxX3BpY3J1c3QsIH4gdHJlYXRtZW50KQ0KZGlhZ2RkcyA9IERFU2VxKGRpYWdkZHMsIHRlc3Q9IldhbGQiLCBmaXRUeXBlPSJwYXJhbWV0cmljIikNCg0KI3RoZSB0ZXN0IHR5cGUgb2YgIldhbGQiIHRlc3RzIGZvciBzaWduaWZpY2FuY2Ugb2YgY29lZmZpY2llbnRzIGluIGEgTmVnYXRpdmUgQmlub21pYWwgR0xNLiBUaGlzIGlzIGdlbmVyYWxseSBhIHByZXR0eSBnb29kIGFzc3VtcHRpb24gZm9yIHNlcXVlbmNpbmcgZXhwZXJpbWVudHMuIFRoaXMgd2FzIGRlc2lnbmVkIHdpdGggUk5BLXNlcSBpbiBtaW5kLCBidXQgYWxzbyBwcmV0dHkgZ29vZCBmb3IgMTZTIHNlcXVlbmNpbmcuDQoNCg0KIyMjSW52ZXN0aWdhdGUgdGVzdCByZXN1bHRzIHRhYmxlDQoNCiNUaGUgZm9sbG93aW5nIHJlc3VsdHMgZnVuY3Rpb24gY2FsbCBjcmVhdGVzIGEgdGFibGUgb2YgdGhlIHJlc3VsdHMgb2YgdGhlIHRlc3RzLiBWZXJ5IGZhc3QuIFRoZSBoYXJkIHdvcmsgd2FzIGFscmVhZHkgc3RvcmVkIHdpdGggdGhlIHJlc3Qgb2YgdGhlIERFU2VxMi1yZWxhdGVkIGRhdGEgaW4gb3VyIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBkaWFnZGRzIG9iamVjdCAoc2VlIGFib3ZlKS4gSSB0aGVuIG9yZGVyIGJ5IHRoZSBhZGp1c3RlZCBwLXZhbHVlLCByZW1vdmluZyB0aGUgZW50cmllcyB3aXRoIGFuIE5BIHZhbHVlLiBUaGUgcmVzdCBvZiB0aGlzIGV4YW1wbGUgaXMganVzdCBmb3JtYXR0aW5nIHRoZSByZXN1bHRzIHRhYmxlIHdpdGggdGF4b25vbWljIGluZm9ybWF0aW9uIGZvciBuaWNlKGlzaCkgZGlzcGxheSBpbiB0aGUgSFRNTCBvdXRwdXQuDQoNCiNDb250cmFzdDogdGhpcyBhcmd1bWVudCBzcGVjaWZpZXMgd2hhdCBjb21wYXJpc29uIHRvIGV4dHJhY3QgZnJvbSB0aGUgb2JqZWN0IHRvIGJ1aWxkIGEgcmVzdWx0cyB0YWJsZS4gVGhlcmUgYXJlIGV4YWN0bHkgdGhyZWUgZWxlbWVudHM6DQoNCiMgIDEuIHRoZSBuYW1lIG9mIGEgZmFjdG9yIGluIHRoZSBkZXNpZ24gZm9ybXVsYSwgDQojICAyLiB0aGUgbmFtZSBvZiB0aGUgbnVtZXJhdG9yIGxldmVsIGZvciB0aGUgZm9sZCBjaGFuZ2UsIGFuZCANCiMgIDMuIHRoZSBuYW1lIG9mIHRoZSBkZW5vbWluYXRvciBsZXZlbCBmb3IgdGhlIGZvbGQgY2hhbmdlIChzaW1wbGVzdCBjYXNlKQ0KDQphbHBoYSA9IDAuMDUNCm15X2NvbnRyYXN0ID0gYygidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWEwNSIpIA0KbXlfY29udHJhc3QgPSBjKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTEwIikgDQpteV9jb250cmFzdCA9IGMoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMTUiKQ0KbXlfY29udHJhc3QgPSBjKCJ0cmVhdG1lbnQiLCAiQlNlYTA1IiwgIkJTZWExMCIpIA0KbXlfY29udHJhc3QgPSBjKCJ0cmVhdG1lbnQiLCAiQlNlYTA1IiwgIkJTZWExNSIpDQpteV9jb250cmFzdCA9IGMoInRyZWF0bWVudCIsICJCU2VhMTAiLCAiQlNlYTE1IikgDQoNCg0KbXlfY29udHJhc3QgPC0gYygidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWEwNSIpIA0KcmVzID0gcmVzdWx0cyhkaWFnZGRzLCBjb250cmFzdCA9IG15X2NvbnRyYXN0LCBjb29rc0N1dG9mZiA9IEZBTFNFKQ0KDQpzaWd0YWIgPSByZXNbd2hpY2gocmVzJHBhZGogPCBhbHBoYSksIF0NCnNpZ3RhYiA8LSBhcyhzaWd0YWIsICJkYXRhLmZyYW1lIikNCnNpZ3RhYjIgPC0gc3Vic2V0KHNpZ3RhYiwgYWJzKGxvZzJGb2xkQ2hhbmdlKSA+IDMpDQojc2lndGFiID0gY2JpbmQoYXMoc2lndGFiLCAiZGF0YS5mcmFtZSIpLCBhcyh0YXhfdGFibGUocGh5c2VxX3BpY3J1c3QpW3Jvd25hbWVzKHNpZ3RhYiksIF0sICJtYXRyaXgiKSkNCmhlYWQoc2lndGFiKQ0KDQoNCiNMZXQncyBsb29rIGF0IHRoZSBPVFVzIHRoYXQgd2VyZSBzaWduaWZpY2FudGx5IGRpZmZlcmVudCBiZXR3ZWVuIHRoZSB0d28gdHJlYXRtZW50IGdyb3Vwcy4gVGhlIGZvbGxvd2luZyBtYWtlcyBhIG5pY2UgZ2dwbG90MiBzdW1tYXJ5IG9mIHRoZSByZXN1bHRzLg0KDQojYWRkIGluIHBhdGh3YXkgbmFtZXMNCnNpZ3RhYiRwYXRod2F5IDwtIHJvdy5uYW1lcyhzaWd0YWIpDQpzdHIoc2lndGFiKQ0KcGF0aHdheV9tYXBmaWxlIDwtIHJlYWQuZGVsaW0oIm1ldGFjeWNfcGF0aHdheXNfaW5mby50eHQiLCBzZXAgPSAiXHQiLCBoZWFkZXIgPSBGLCBxdW90ZSA9ICIiLCBzdHJpbmdzQXNGYWN0b3JzID0gRikNCnN0cihwYXRod2F5X21hcGZpbGUpDQpjb2xuYW1lcyhwYXRod2F5X21hcGZpbGUpWzFdIDwtICJhYmJyZXZpYXRpb24iDQpjb2xuYW1lcyhwYXRod2F5X21hcGZpbGUpWzJdIDwtICJwYXRod2F5X25hbWUiDQojbWVyZ2UgYHNpZ3RhYmAgYW5kIGBwYXRod2F5X21hcGZpbGVgDQpzaWd0YWIgPC0gaW5uZXJfam9pbihzaWd0YWIsIHBhdGh3YXlfbWFwZmlsZSwgYnkgPSBjKCJwYXRod2F5IiA9ICJhYmJyZXZpYXRpb24iKSkNCg0KDQojIHBhdGh3YXkgb3JkZXINCnggPSB0YXBwbHkoc2lndGFiJGxvZzJGb2xkQ2hhbmdlLCBzaWd0YWIkcGF0aHdheV9uYW1lLCBmdW5jdGlvbih4KSBtYXgoeCkpDQp4ID0gc29ydCh4LCBUUlVFKQ0Kc2lndGFiJHBhdGh3YXlfbmFtZSA9IGZhY3Rvcihhcy5jaGFyYWN0ZXIoc2lndGFiJHBhdGh3YXlfbmFtZSksIGxldmVscz1uYW1lcyh4KSkNCg0KREVTZXFfZmlnID0gZ2dwbG90KHNpZ3RhYiwgYWVzKHggPSBwYXRod2F5X25hbWUsIHkgPSBsb2cyRm9sZENoYW5nZSkpICsgDQogIGdlb21fcG9pbnQoc2l6ZT0zKSArIA0KICB5bGFiKHBhc3RlMCgiKCIsIG15X2NvbnRyYXN0WzJdLCAiLyIsIG15X2NvbnRyYXN0WzNdLCAiKVxuIiwgImxvZzJGb2xkQ2hhbmdlIikpICsNCiAgI3NjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBteV9jb2xvcnNbYyg0LDYsOCwxMCwxMiwxNCwxNiwxOCwyMCldKSArDQogICN5bGltKDAsOCkgKw0KICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IC05MCwgaGp1c3QgPSAwLCB2anVzdD0wLjIpKSsNCiAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoY29sb3IgPSAiYmxhY2siLCBzaXplID0gMTApLA0KICAgICAgICBheGlzLnRleHQueSA9ZWxlbWVudF90ZXh0KGNvbG9yID0gImJsYWNrIiwgc2l6ZSA9IDEyKSkgDQoNCkRFU2VxX2ZpZyANCmdnc2F2ZShwYXN0ZTAoIm91dHB1dC9ERVNlcTItIiwgbXlfY29udHJhc3RbMl0sICItIiwgbXlfY29udHJhc3RbM10sICIucG5nIiksIERFU2VxX2ZpZywgaGVpZ2h0ID0gMTAsIHdpZHRoID0gMTgpDQoNCg0KIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMNCiNMZXRzIHRyeSB0aGlzIHdpdGggYSBmdW5jdGlvbg0KICANCnJ1bl9kZXNlcTIgPC0gZnVuY3Rpb24odHJlYXRtZW50LCBCYXNhbCwgQlNlYTA1LCBCU2VhMTAsIEJTZWExNSl7DQogIA0KbXlfY29udHJhc3QgPSBjKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTA1IikgDQpteV9jb250cmFzdCA9IGMoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMTAiKSANCm15X2NvbnRyYXN0ID0gYygidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWExNSIpDQpteV9jb250cmFzdCA9IGMoInRyZWF0bWVudCIsICJCU2VhMDUiLCAiQlNlYTEwIikgDQpteV9jb250cmFzdCA9IGMoInRyZWF0bWVudCIsICJCU2VhMDUiLCAiQlNlYTE1IikNCm15X2NvbnRyYXN0ID0gYygidHJlYXRtZW50IiwgIkJTZWExMCIsICJCU2VhMTUiKQ0KDQpyZXMgPSByZXN1bHRzKGRpYWdkZHMsIGNvbnRyYXN0ID0gbXlfY29udHJhc3QsIGNvb2tzQ3V0b2ZmID0gRkFMU0UpDQogIA0Kc2lndGFiID0gcmVzW3doaWNoKHJlcyRwYWRqIDwgYWxwaGEpLCBdDQpzaWd0YWIgPC0gYXMoc2lndGFiLCAiZGF0YS5mcmFtZSIpDQpzaWd0YWIgPC0gc3Vic2V0KHNpZ3RhYiwgYWJzKGxvZzJGb2xkQ2hhbmdlKSA+IDIpDQoNCiAgDQogIA0KICAjTGV0J3MgbG9vayBhdCB0aGUgT1RVcyB0aGF0IHdlcmUgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgYmV0d2VlbiB0aGUgdHdvIHRyZWF0bWVudCBncm91cHMuIFRoZSBmb2xsb3dpbmcgbWFrZXMgYSBuaWNlIGdncGxvdDIgc3VtbWFyeSBvZiB0aGUgcmVzdWx0cy4NCiAgDQogIA0KICAjYWRkIGluIHBhdGh3YXkgbmFtZXMNCiAgc2lndGFiJHBhdGh3YXkgPC0gcm93Lm5hbWVzKHNpZ3RhYikNCiAgc3RyKHNpZ3RhYikNCiAgcGF0aHdheV9tYXBmaWxlIDwtIHJlYWQuZGVsaW0oIm1ldGFjeWNfcGF0aHdheXNfaW5mby50eHQiLCBzZXAgPSAiXHQiLCBoZWFkZXIgPSBGLCBxdW90ZSA9ICIiLCBzdHJpbmdzQXNGYWN0b3JzID0gRikNCiAgc3RyKHBhdGh3YXlfbWFwZmlsZSkNCiAgY29sbmFtZXMocGF0aHdheV9tYXBmaWxlKVsxXSA8LSAiYWJicmV2aWF0aW9uIg0KICBjb2xuYW1lcyhwYXRod2F5X21hcGZpbGUpWzJdIDwtICJwYXRod2F5X25hbWUiDQogIA0KICNtZXJnZSBgc2lndGFiYCBhbmQgYHBhdGh3YXlfbWFwZmlsZWANCiAgc2lndGFiIDwtIGlubmVyX2pvaW4oc2lndGFiLCBwYXRod2F5X21hcGZpbGUsIGJ5ID0gYygicGF0aHdheSIgPSAiYWJicmV2aWF0aW9uIikpDQogIA0KICAjIHBhdGh3YXkgb3JkZXINCiAgeCA9IHRhcHBseShzaWd0YWIkbG9nMkZvbGRDaGFuZ2UsIHNpZ3RhYiRwYXRod2F5X25hbWUsIGZ1bmN0aW9uKHgpIG1heCh4KSkNCiAgeCA9IHNvcnQoeCwgVFJVRSkNCiAgc2lndGFiJHBhdGh3YXlfbmFtZSA9IGZhY3Rvcihhcy5jaGFyYWN0ZXIoc2lndGFiJHBhdGh3YXlfbmFtZSksIGxldmVscz1uYW1lcyh4KSkNCiAgDQogIERFU2VxX2ZpZyA9IGdncGxvdChzaWd0YWIsIGFlcyh4ID0gcGF0aHdheV9uYW1lLCB5ID0gbG9nMkZvbGRDaGFuZ2UpKSArIA0KICAgIGdlb21fcG9pbnQoc2l6ZT0zKSArIA0KICAgIHlsYWIocGFzdGUwKCIoIiwgbXlfY29udHJhc3RbMl0sICIvIiwgbXlfY29udHJhc3RbM10sICIpXG4iLCAibG9nMkZvbGRDaGFuZ2UiKSkgKw0KICAgICNzY2FsZV9jb2xvcl9tYW51YWwodmFsdWVzID0gbXlfY29sb3JzW2MoNCw2LDgsMTAsMTIsMTQsMTYsMTgsMjApXSkgKw0KICAgICN5bGltKDAsOCkgKw0KICAgIGdlb21fdGV4dChjb2xvcj0iYmxhY2siLCB4PWxlbmd0aCh1bmlxdWUoc2lndGFiJHBhdGh3YXlfbmFtZSkpLTUsIHk9bWF4KHNpZ3RhYiRsb2cyRm9sZENoYW5nZSktMSwgbGFiZWw9bXlfY29udHJhc3RbMl0sIHNob3dfZ3VpZGUgPSBGKSArDQogICAgZ2VvbV90ZXh0KGNvbG9yPSJibGFjayIsIHg9NSwgeT1taW4oc2lndGFiJGxvZzJGb2xkQ2hhbmdlKSsxLCBsYWJlbD1teV9jb250cmFzdFszXSwgc2hvd19ndWlkZSA9IEYpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChhbmdsZSA9IC05MCwgaGp1c3QgPSAwLCB2anVzdD0wLjIpKSsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChjb2xvciA9ICJibGFjayIsIHNpemUgPSAxMCksDQogICAgICAgICAgYXhpcy50ZXh0LnkgPWVsZW1lbnRfdGV4dChjb2xvciA9ICJibGFjayIsIHNpemUgPSAxMikpIA0KICANCiAgZ2dzYXZlKHBhc3RlMCgib3V0cHV0L0RFU2VxMi0iLCBteV9jb250cmFzdFsyXSwgIi0iLCBteV9jb250cmFzdFszXSwgIi1maWx0LnBuZyIpLCBERVNlcV9maWcsIGhlaWdodCA9IDEwLCB3aWR0aCA9MjAgKQ0KfQ0KDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTA1IikNCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCYXNhbCIsICJCU2VhMDUiKQ0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJhc2FsIiwgIkJTZWExMCIpDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQmFzYWwiLCAiQlNlYTE1IikgDQpydW5fZGVzZXEyKCJ0cmVhdG1lbnQiLCAiQlNlYTA1IiwgIkJTZWExMCIpIA0KcnVuX2Rlc2VxMigidHJlYXRtZW50IiwgIkJTZWEwNSIsICJCU2VhMTUiKSANCnJ1bl9kZXNlcTIoInRyZWF0bWVudCIsICJCU2VhMTAiLCAiQlNlYTE1IikNCiMNCg0KYGBgDQoNCg0KYGBge3J9DQpXaGVuIHlvdSBzYXZlIHRoZSBub3RlYm9vaywgYW4gSFRNTCBmaWxlIGNvbnRhaW5pbmcgdGhlIGNvZGUgYW5kIG91dHB1dCB3aWxsIGJlIHNhdmVkIGFsb25nc2lkZSBpdCAoY2xpY2sgdGhlICpQcmV2aWV3KiBidXR0b24gb3IgcHJlc3MgKkN0cmwrU2hpZnQrSyogdG8gcHJldmlldyB0aGUgSFRNTCBmaWxlKS4NCg0KVGhlIHByZXZpZXcgc2hvd3MgeW91IGEgcmVuZGVyZWQgSFRNTCBjb3B5IG9mIHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLiBDb25zZXF1ZW50bHksIHVubGlrZSAqS25pdCosICpQcmV2aWV3KiBkb2VzIG5vdCBydW4gYW55IFIgY29kZSBjaHVua3MuIEluc3RlYWQsIHRoZSBvdXRwdXQgb2YgdGhlIGNodW5rIHdoZW4gaXQgd2FzIGxhc3QgcnVuIGluIHRoZSBlZGl0b3IgaXMgZGlzcGxheWVkLg==</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});

$(document).ready(function () {
  $('.knitsql-table').addClass('kable-table');
  var container = $('.kable-table');
  container.each(function() {

    // move the caption out of the table
    var table = $(this).children('table');
    var caption = table.children('caption').detach();
    caption.insertBefore($(this)).css('display', 'inherit');
  });
});

</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("ANSC 516 project data analysis.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
